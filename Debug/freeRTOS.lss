
freeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006718  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001ec  00800060  00006718  000067ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000460  0080024c  0080024c  00006998  2**0
                  ALLOC
  3 .stab         000094c8  00000000  00000000  00006998  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000544e  00000000  00000000  0000fe60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  000152ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0001544e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  00015640  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  00017a4b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00018dd1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  00019fa8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001a168  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0001a45e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001adcc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 54 24 	jmp	0x48a8	; 0x48a8 <__vector_4>
      14:	0c 94 27 24 	jmp	0x484e	; 0x484e <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ba 0c 	jmp	0x1974	; 0x1974 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 db 29 	jmp	0x53b6	; 0x53b6 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e1       	ldi	r30, 0x18	; 24
      68:	f7 e6       	ldi	r31, 0x67	; 103
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 34       	cpi	r26, 0x4C	; 76
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ac e4       	ldi	r26, 0x4C	; 76
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 3a       	cpi	r26, 0xAC	; 172
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 14 33 	call	0x6628	; 0x6628 <main>
      8a:	0c 94 8a 33 	jmp	0x6714	; 0x6714 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 41 33 	jmp	0x6682	; 0x6682 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a3 ee       	ldi	r26, 0xE3	; 227
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 5d 33 	jmp	0x66ba	; 0x66ba <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 4d 33 	jmp	0x669a	; 0x669a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 69 33 	jmp	0x66d2	; 0x66d2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 4d 33 	jmp	0x669a	; 0x669a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 69 33 	jmp	0x66d2	; 0x66d2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 41 33 	jmp	0x6682	; 0x6682 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	83 ee       	ldi	r24, 0xE3	; 227
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 5d 33 	jmp	0x66ba	; 0x66ba <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 49 33 	jmp	0x6692	; 0x6692 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	63 ee       	ldi	r22, 0xE3	; 227
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 65 33 	jmp	0x66ca	; 0x66ca <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 4d 33 	jmp	0x669a	; 0x669a <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 69 33 	jmp	0x66d2	; 0x66d2 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 4d 33 	jmp	0x669a	; 0x669a <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 69 33 	jmp	0x66d2	; 0x66d2 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 4d 33 	jmp	0x669a	; 0x669a <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 69 33 	jmp	0x66d2	; 0x66d2 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 51 33 	jmp	0x66a2	; 0x66a2 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 6d 33 	jmp	0x66da	; 0x66da <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 49 33 	jmp	0x6692	; 0x6692 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 65 33 	jmp	0x66ca	; 0x66ca <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e5 51       	subi	r30, 0x15	; 21
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	2e 97       	sbiw	r28, 0x0e	; 14
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	9e 87       	std	Y+14, r25	; 0x0e
     e44:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     e46:	1e 82       	std	Y+6, r1	; 0x06
     e48:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
     e4a:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     e4e:	80 91 4c 02 	lds	r24, 0x024C
     e52:	88 23       	and	r24, r24
     e54:	29 f4       	brne	.+10     	; 0xe60 <pvPortMalloc+0x32>
		{
			prvHeapInit();
     e56:	0e 94 7e 08 	call	0x10fc	; 0x10fc <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	80 93 4c 02 	sts	0x024C, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     e60:	8d 85       	ldd	r24, Y+13	; 0x0d
     e62:	9e 85       	ldd	r25, Y+14	; 0x0e
     e64:	00 97       	sbiw	r24, 0x00	; 0
     e66:	51 f0       	breq	.+20     	; 0xe7c <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     e68:	80 91 49 02 	lds	r24, 0x0249
     e6c:	90 91 4a 02 	lds	r25, 0x024A
     e70:	2d 85       	ldd	r18, Y+13	; 0x0d
     e72:	3e 85       	ldd	r19, Y+14	; 0x0e
     e74:	82 0f       	add	r24, r18
     e76:	93 1f       	adc	r25, r19
     e78:	9e 87       	std	Y+14, r25	; 0x0e
     e7a:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     e7c:	8d 85       	ldd	r24, Y+13	; 0x0d
     e7e:	9e 85       	ldd	r25, Y+14	; 0x0e
     e80:	00 97       	sbiw	r24, 0x00	; 0
     e82:	09 f4       	brne	.+2      	; 0xe86 <pvPortMalloc+0x58>
     e84:	af c0       	rjmp	.+350    	; 0xfe4 <pvPortMalloc+0x1b6>
     e86:	8d 85       	ldd	r24, Y+13	; 0x0d
     e88:	9e 85       	ldd	r25, Y+14	; 0x0e
     e8a:	23 e0       	ldi	r18, 0x03	; 3
     e8c:	87 3e       	cpi	r24, 0xE7	; 231
     e8e:	92 07       	cpc	r25, r18
     e90:	08 f0       	brcs	.+2      	; 0xe94 <pvPortMalloc+0x66>
     e92:	a8 c0       	rjmp	.+336    	; 0xfe4 <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     e94:	85 e3       	ldi	r24, 0x35	; 53
     e96:	96 e0       	ldi	r25, 0x06	; 6
     e98:	9a 87       	std	Y+10, r25	; 0x0a
     e9a:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
     e9c:	80 91 35 06 	lds	r24, 0x0635
     ea0:	90 91 36 06 	lds	r25, 0x0636
     ea4:	9c 87       	std	Y+12, r25	; 0x0c
     ea6:	8b 87       	std	Y+11, r24	; 0x0b
     ea8:	0a c0       	rjmp	.+20     	; 0xebe <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
     eaa:	8b 85       	ldd	r24, Y+11	; 0x0b
     eac:	9c 85       	ldd	r25, Y+12	; 0x0c
     eae:	9a 87       	std	Y+10, r25	; 0x0a
     eb0:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
     eb2:	eb 85       	ldd	r30, Y+11	; 0x0b
     eb4:	fc 85       	ldd	r31, Y+12	; 0x0c
     eb6:	80 81       	ld	r24, Z
     eb8:	91 81       	ldd	r25, Z+1	; 0x01
     eba:	9c 87       	std	Y+12, r25	; 0x0c
     ebc:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     ebe:	eb 85       	ldd	r30, Y+11	; 0x0b
     ec0:	fc 85       	ldd	r31, Y+12	; 0x0c
     ec2:	22 81       	ldd	r18, Z+2	; 0x02
     ec4:	33 81       	ldd	r19, Z+3	; 0x03
     ec6:	8d 85       	ldd	r24, Y+13	; 0x0d
     ec8:	9e 85       	ldd	r25, Y+14	; 0x0e
     eca:	28 17       	cp	r18, r24
     ecc:	39 07       	cpc	r19, r25
     ece:	30 f4       	brcc	.+12     	; 0xedc <pvPortMalloc+0xae>
     ed0:	eb 85       	ldd	r30, Y+11	; 0x0b
     ed2:	fc 85       	ldd	r31, Y+12	; 0x0c
     ed4:	80 81       	ld	r24, Z
     ed6:	91 81       	ldd	r25, Z+1	; 0x01
     ed8:	00 97       	sbiw	r24, 0x00	; 0
     eda:	39 f7       	brne	.-50     	; 0xeaa <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     edc:	8b 85       	ldd	r24, Y+11	; 0x0b
     ede:	9c 85       	ldd	r25, Y+12	; 0x0c
     ee0:	46 e0       	ldi	r20, 0x06	; 6
     ee2:	89 33       	cpi	r24, 0x39	; 57
     ee4:	94 07       	cpc	r25, r20
     ee6:	09 f4       	brne	.+2      	; 0xeea <pvPortMalloc+0xbc>
     ee8:	7d c0       	rjmp	.+250    	; 0xfe4 <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     eea:	e9 85       	ldd	r30, Y+9	; 0x09
     eec:	fa 85       	ldd	r31, Y+10	; 0x0a
     eee:	20 81       	ld	r18, Z
     ef0:	31 81       	ldd	r19, Z+1	; 0x01
     ef2:	80 91 49 02 	lds	r24, 0x0249
     ef6:	90 91 4a 02 	lds	r25, 0x024A
     efa:	82 0f       	add	r24, r18
     efc:	93 1f       	adc	r25, r19
     efe:	9e 83       	std	Y+6, r25	; 0x06
     f00:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     f02:	eb 85       	ldd	r30, Y+11	; 0x0b
     f04:	fc 85       	ldd	r31, Y+12	; 0x0c
     f06:	80 81       	ld	r24, Z
     f08:	91 81       	ldd	r25, Z+1	; 0x01
     f0a:	e9 85       	ldd	r30, Y+9	; 0x09
     f0c:	fa 85       	ldd	r31, Y+10	; 0x0a
     f0e:	91 83       	std	Z+1, r25	; 0x01
     f10:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     f12:	eb 85       	ldd	r30, Y+11	; 0x0b
     f14:	fc 85       	ldd	r31, Y+12	; 0x0c
     f16:	22 81       	ldd	r18, Z+2	; 0x02
     f18:	33 81       	ldd	r19, Z+3	; 0x03
     f1a:	8d 85       	ldd	r24, Y+13	; 0x0d
     f1c:	9e 85       	ldd	r25, Y+14	; 0x0e
     f1e:	28 1b       	sub	r18, r24
     f20:	39 0b       	sbc	r19, r25
     f22:	80 91 49 02 	lds	r24, 0x0249
     f26:	90 91 4a 02 	lds	r25, 0x024A
     f2a:	88 0f       	add	r24, r24
     f2c:	99 1f       	adc	r25, r25
     f2e:	82 17       	cp	r24, r18
     f30:	93 07       	cpc	r25, r19
     f32:	08 f0       	brcs	.+2      	; 0xf36 <pvPortMalloc+0x108>
     f34:	47 c0       	rjmp	.+142    	; 0xfc4 <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     f36:	2b 85       	ldd	r18, Y+11	; 0x0b
     f38:	3c 85       	ldd	r19, Y+12	; 0x0c
     f3a:	8d 85       	ldd	r24, Y+13	; 0x0d
     f3c:	9e 85       	ldd	r25, Y+14	; 0x0e
     f3e:	82 0f       	add	r24, r18
     f40:	93 1f       	adc	r25, r19
     f42:	98 87       	std	Y+8, r25	; 0x08
     f44:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     f46:	eb 85       	ldd	r30, Y+11	; 0x0b
     f48:	fc 85       	ldd	r31, Y+12	; 0x0c
     f4a:	22 81       	ldd	r18, Z+2	; 0x02
     f4c:	33 81       	ldd	r19, Z+3	; 0x03
     f4e:	8d 85       	ldd	r24, Y+13	; 0x0d
     f50:	9e 85       	ldd	r25, Y+14	; 0x0e
     f52:	a9 01       	movw	r20, r18
     f54:	48 1b       	sub	r20, r24
     f56:	59 0b       	sbc	r21, r25
     f58:	ca 01       	movw	r24, r20
     f5a:	ef 81       	ldd	r30, Y+7	; 0x07
     f5c:	f8 85       	ldd	r31, Y+8	; 0x08
     f5e:	93 83       	std	Z+3, r25	; 0x03
     f60:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
     f62:	eb 85       	ldd	r30, Y+11	; 0x0b
     f64:	fc 85       	ldd	r31, Y+12	; 0x0c
     f66:	8d 85       	ldd	r24, Y+13	; 0x0d
     f68:	9e 85       	ldd	r25, Y+14	; 0x0e
     f6a:	93 83       	std	Z+3, r25	; 0x03
     f6c:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     f6e:	ef 81       	ldd	r30, Y+7	; 0x07
     f70:	f8 85       	ldd	r31, Y+8	; 0x08
     f72:	82 81       	ldd	r24, Z+2	; 0x02
     f74:	93 81       	ldd	r25, Z+3	; 0x03
     f76:	9a 83       	std	Y+2, r25	; 0x02
     f78:	89 83       	std	Y+1, r24	; 0x01
     f7a:	85 e3       	ldi	r24, 0x35	; 53
     f7c:	96 e0       	ldi	r25, 0x06	; 6
     f7e:	9c 83       	std	Y+4, r25	; 0x04
     f80:	8b 83       	std	Y+3, r24	; 0x03
     f82:	06 c0       	rjmp	.+12     	; 0xf90 <pvPortMalloc+0x162>
     f84:	eb 81       	ldd	r30, Y+3	; 0x03
     f86:	fc 81       	ldd	r31, Y+4	; 0x04
     f88:	80 81       	ld	r24, Z
     f8a:	91 81       	ldd	r25, Z+1	; 0x01
     f8c:	9c 83       	std	Y+4, r25	; 0x04
     f8e:	8b 83       	std	Y+3, r24	; 0x03
     f90:	eb 81       	ldd	r30, Y+3	; 0x03
     f92:	fc 81       	ldd	r31, Y+4	; 0x04
     f94:	01 90       	ld	r0, Z+
     f96:	f0 81       	ld	r31, Z
     f98:	e0 2d       	mov	r30, r0
     f9a:	22 81       	ldd	r18, Z+2	; 0x02
     f9c:	33 81       	ldd	r19, Z+3	; 0x03
     f9e:	89 81       	ldd	r24, Y+1	; 0x01
     fa0:	9a 81       	ldd	r25, Y+2	; 0x02
     fa2:	28 17       	cp	r18, r24
     fa4:	39 07       	cpc	r19, r25
     fa6:	70 f3       	brcs	.-36     	; 0xf84 <pvPortMalloc+0x156>
     fa8:	eb 81       	ldd	r30, Y+3	; 0x03
     faa:	fc 81       	ldd	r31, Y+4	; 0x04
     fac:	80 81       	ld	r24, Z
     fae:	91 81       	ldd	r25, Z+1	; 0x01
     fb0:	ef 81       	ldd	r30, Y+7	; 0x07
     fb2:	f8 85       	ldd	r31, Y+8	; 0x08
     fb4:	91 83       	std	Z+1, r25	; 0x01
     fb6:	80 83       	st	Z, r24
     fb8:	eb 81       	ldd	r30, Y+3	; 0x03
     fba:	fc 81       	ldd	r31, Y+4	; 0x04
     fbc:	8f 81       	ldd	r24, Y+7	; 0x07
     fbe:	98 85       	ldd	r25, Y+8	; 0x08
     fc0:	91 83       	std	Z+1, r25	; 0x01
     fc2:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     fc4:	20 91 eb 01 	lds	r18, 0x01EB
     fc8:	30 91 ec 01 	lds	r19, 0x01EC
     fcc:	eb 85       	ldd	r30, Y+11	; 0x0b
     fce:	fc 85       	ldd	r31, Y+12	; 0x0c
     fd0:	82 81       	ldd	r24, Z+2	; 0x02
     fd2:	93 81       	ldd	r25, Z+3	; 0x03
     fd4:	a9 01       	movw	r20, r18
     fd6:	48 1b       	sub	r20, r24
     fd8:	59 0b       	sbc	r21, r25
     fda:	ca 01       	movw	r24, r20
     fdc:	90 93 ec 01 	sts	0x01EC, r25
     fe0:	80 93 eb 01 	sts	0x01EB, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     fe4:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     fe8:	8d 81       	ldd	r24, Y+5	; 0x05
     fea:	9e 81       	ldd	r25, Y+6	; 0x06
}
     fec:	2e 96       	adiw	r28, 0x0e	; 14
     fee:	0f b6       	in	r0, 0x3f	; 63
     ff0:	f8 94       	cli
     ff2:	de bf       	out	0x3e, r29	; 62
     ff4:	0f be       	out	0x3f, r0	; 63
     ff6:	cd bf       	out	0x3d, r28	; 61
     ff8:	cf 91       	pop	r28
     ffa:	df 91       	pop	r29
     ffc:	08 95       	ret

00000ffe <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ffe:	df 93       	push	r29
    1000:	cf 93       	push	r28
    1002:	cd b7       	in	r28, 0x3d	; 61
    1004:	de b7       	in	r29, 0x3e	; 62
    1006:	2a 97       	sbiw	r28, 0x0a	; 10
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	de bf       	out	0x3e, r29	; 62
    100e:	0f be       	out	0x3f, r0	; 63
    1010:	cd bf       	out	0x3d, r28	; 61
    1012:	9a 87       	std	Y+10, r25	; 0x0a
    1014:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    1016:	89 85       	ldd	r24, Y+9	; 0x09
    1018:	9a 85       	ldd	r25, Y+10	; 0x0a
    101a:	98 87       	std	Y+8, r25	; 0x08
    101c:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    101e:	89 85       	ldd	r24, Y+9	; 0x09
    1020:	9a 85       	ldd	r25, Y+10	; 0x0a
    1022:	00 97       	sbiw	r24, 0x00	; 0
    1024:	09 f4       	brne	.+2      	; 0x1028 <vPortFree+0x2a>
    1026:	4f c0       	rjmp	.+158    	; 0x10c6 <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1028:	80 91 49 02 	lds	r24, 0x0249
    102c:	90 91 4a 02 	lds	r25, 0x024A
    1030:	22 27       	eor	r18, r18
    1032:	33 27       	eor	r19, r19
    1034:	28 1b       	sub	r18, r24
    1036:	39 0b       	sbc	r19, r25
    1038:	8f 81       	ldd	r24, Y+7	; 0x07
    103a:	98 85       	ldd	r25, Y+8	; 0x08
    103c:	82 0f       	add	r24, r18
    103e:	93 1f       	adc	r25, r19
    1040:	98 87       	std	Y+8, r25	; 0x08
    1042:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    1044:	8f 81       	ldd	r24, Y+7	; 0x07
    1046:	98 85       	ldd	r25, Y+8	; 0x08
    1048:	9e 83       	std	Y+6, r25	; 0x06
    104a:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    104c:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1050:	ed 81       	ldd	r30, Y+5	; 0x05
    1052:	fe 81       	ldd	r31, Y+6	; 0x06
    1054:	82 81       	ldd	r24, Z+2	; 0x02
    1056:	93 81       	ldd	r25, Z+3	; 0x03
    1058:	9a 83       	std	Y+2, r25	; 0x02
    105a:	89 83       	std	Y+1, r24	; 0x01
    105c:	85 e3       	ldi	r24, 0x35	; 53
    105e:	96 e0       	ldi	r25, 0x06	; 6
    1060:	9c 83       	std	Y+4, r25	; 0x04
    1062:	8b 83       	std	Y+3, r24	; 0x03
    1064:	06 c0       	rjmp	.+12     	; 0x1072 <vPortFree+0x74>
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	80 81       	ld	r24, Z
    106c:	91 81       	ldd	r25, Z+1	; 0x01
    106e:	9c 83       	std	Y+4, r25	; 0x04
    1070:	8b 83       	std	Y+3, r24	; 0x03
    1072:	eb 81       	ldd	r30, Y+3	; 0x03
    1074:	fc 81       	ldd	r31, Y+4	; 0x04
    1076:	01 90       	ld	r0, Z+
    1078:	f0 81       	ld	r31, Z
    107a:	e0 2d       	mov	r30, r0
    107c:	22 81       	ldd	r18, Z+2	; 0x02
    107e:	33 81       	ldd	r19, Z+3	; 0x03
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	9a 81       	ldd	r25, Y+2	; 0x02
    1084:	28 17       	cp	r18, r24
    1086:	39 07       	cpc	r19, r25
    1088:	70 f3       	brcs	.-36     	; 0x1066 <vPortFree+0x68>
    108a:	eb 81       	ldd	r30, Y+3	; 0x03
    108c:	fc 81       	ldd	r31, Y+4	; 0x04
    108e:	80 81       	ld	r24, Z
    1090:	91 81       	ldd	r25, Z+1	; 0x01
    1092:	ed 81       	ldd	r30, Y+5	; 0x05
    1094:	fe 81       	ldd	r31, Y+6	; 0x06
    1096:	91 83       	std	Z+1, r25	; 0x01
    1098:	80 83       	st	Z, r24
    109a:	eb 81       	ldd	r30, Y+3	; 0x03
    109c:	fc 81       	ldd	r31, Y+4	; 0x04
    109e:	8d 81       	ldd	r24, Y+5	; 0x05
    10a0:	9e 81       	ldd	r25, Y+6	; 0x06
    10a2:	91 83       	std	Z+1, r25	; 0x01
    10a4:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    10a6:	ed 81       	ldd	r30, Y+5	; 0x05
    10a8:	fe 81       	ldd	r31, Y+6	; 0x06
    10aa:	22 81       	ldd	r18, Z+2	; 0x02
    10ac:	33 81       	ldd	r19, Z+3	; 0x03
    10ae:	80 91 eb 01 	lds	r24, 0x01EB
    10b2:	90 91 ec 01 	lds	r25, 0x01EC
    10b6:	82 0f       	add	r24, r18
    10b8:	93 1f       	adc	r25, r19
    10ba:	90 93 ec 01 	sts	0x01EC, r25
    10be:	80 93 eb 01 	sts	0x01EB, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    10c2:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
	}
}
    10c6:	2a 96       	adiw	r28, 0x0a	; 10
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	f8 94       	cli
    10cc:	de bf       	out	0x3e, r29	; 62
    10ce:	0f be       	out	0x3f, r0	; 63
    10d0:	cd bf       	out	0x3d, r28	; 61
    10d2:	cf 91       	pop	r28
    10d4:	df 91       	pop	r29
    10d6:	08 95       	ret

000010d8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    10d8:	df 93       	push	r29
    10da:	cf 93       	push	r28
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    10e0:	80 91 eb 01 	lds	r24, 0x01EB
    10e4:	90 91 ec 01 	lds	r25, 0x01EC
}
    10e8:	cf 91       	pop	r28
    10ea:	df 91       	pop	r29
    10ec:	08 95       	ret

000010ee <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    10ee:	df 93       	push	r29
    10f0:	cf 93       	push	r28
    10f2:	cd b7       	in	r28, 0x3d	; 61
    10f4:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    10f6:	cf 91       	pop	r28
    10f8:	df 91       	pop	r29
    10fa:	08 95       	ret

000010fc <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    10fc:	df 93       	push	r29
    10fe:	cf 93       	push	r28
    1100:	00 d0       	rcall	.+0      	; 0x1102 <prvHeapInit+0x6>
    1102:	00 d0       	rcall	.+0      	; 0x1104 <prvHeapInit+0x8>
    1104:	cd b7       	in	r28, 0x3d	; 61
    1106:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1108:	8e e4       	ldi	r24, 0x4E	; 78
    110a:	92 e0       	ldi	r25, 0x02	; 2
    110c:	9a 83       	std	Y+2, r25	; 0x02
    110e:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    1110:	89 81       	ldd	r24, Y+1	; 0x01
    1112:	9a 81       	ldd	r25, Y+2	; 0x02
    1114:	90 93 36 06 	sts	0x0636, r25
    1118:	80 93 35 06 	sts	0x0635, r24
	xStart.xBlockSize = ( size_t ) 0;
    111c:	10 92 38 06 	sts	0x0638, r1
    1120:	10 92 37 06 	sts	0x0637, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1124:	87 ee       	ldi	r24, 0xE7	; 231
    1126:	93 e0       	ldi	r25, 0x03	; 3
    1128:	90 93 3c 06 	sts	0x063C, r25
    112c:	80 93 3b 06 	sts	0x063B, r24
	xEnd.pxNextFreeBlock = NULL;
    1130:	10 92 3a 06 	sts	0x063A, r1
    1134:	10 92 39 06 	sts	0x0639, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    1138:	89 81       	ldd	r24, Y+1	; 0x01
    113a:	9a 81       	ldd	r25, Y+2	; 0x02
    113c:	9c 83       	std	Y+4, r25	; 0x04
    113e:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1140:	eb 81       	ldd	r30, Y+3	; 0x03
    1142:	fc 81       	ldd	r31, Y+4	; 0x04
    1144:	87 ee       	ldi	r24, 0xE7	; 231
    1146:	93 e0       	ldi	r25, 0x03	; 3
    1148:	93 83       	std	Z+3, r25	; 0x03
    114a:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    114c:	eb 81       	ldd	r30, Y+3	; 0x03
    114e:	fc 81       	ldd	r31, Y+4	; 0x04
    1150:	89 e3       	ldi	r24, 0x39	; 57
    1152:	96 e0       	ldi	r25, 0x06	; 6
    1154:	91 83       	std	Z+1, r25	; 0x01
    1156:	80 83       	st	Z, r24
}
    1158:	0f 90       	pop	r0
    115a:	0f 90       	pop	r0
    115c:	0f 90       	pop	r0
    115e:	0f 90       	pop	r0
    1160:	cf 91       	pop	r28
    1162:	df 91       	pop	r29
    1164:	08 95       	ret

00001166 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1166:	df 93       	push	r29
    1168:	cf 93       	push	r28
    116a:	00 d0       	rcall	.+0      	; 0x116c <vListInitialise+0x6>
    116c:	cd b7       	in	r28, 0x3d	; 61
    116e:	de b7       	in	r29, 0x3e	; 62
    1170:	9a 83       	std	Y+2, r25	; 0x02
    1172:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1174:	89 81       	ldd	r24, Y+1	; 0x01
    1176:	9a 81       	ldd	r25, Y+2	; 0x02
    1178:	03 96       	adiw	r24, 0x03	; 3
    117a:	e9 81       	ldd	r30, Y+1	; 0x01
    117c:	fa 81       	ldd	r31, Y+2	; 0x02
    117e:	92 83       	std	Z+2, r25	; 0x02
    1180:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1182:	e9 81       	ldd	r30, Y+1	; 0x01
    1184:	fa 81       	ldd	r31, Y+2	; 0x02
    1186:	8f ef       	ldi	r24, 0xFF	; 255
    1188:	9f ef       	ldi	r25, 0xFF	; 255
    118a:	94 83       	std	Z+4, r25	; 0x04
    118c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    118e:	89 81       	ldd	r24, Y+1	; 0x01
    1190:	9a 81       	ldd	r25, Y+2	; 0x02
    1192:	03 96       	adiw	r24, 0x03	; 3
    1194:	e9 81       	ldd	r30, Y+1	; 0x01
    1196:	fa 81       	ldd	r31, Y+2	; 0x02
    1198:	96 83       	std	Z+6, r25	; 0x06
    119a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	03 96       	adiw	r24, 0x03	; 3
    11a2:	e9 81       	ldd	r30, Y+1	; 0x01
    11a4:	fa 81       	ldd	r31, Y+2	; 0x02
    11a6:	90 87       	std	Z+8, r25	; 0x08
    11a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    11aa:	e9 81       	ldd	r30, Y+1	; 0x01
    11ac:	fa 81       	ldd	r31, Y+2	; 0x02
    11ae:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    11b0:	0f 90       	pop	r0
    11b2:	0f 90       	pop	r0
    11b4:	cf 91       	pop	r28
    11b6:	df 91       	pop	r29
    11b8:	08 95       	ret

000011ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    11ba:	df 93       	push	r29
    11bc:	cf 93       	push	r28
    11be:	00 d0       	rcall	.+0      	; 0x11c0 <vListInitialiseItem+0x6>
    11c0:	cd b7       	in	r28, 0x3d	; 61
    11c2:	de b7       	in	r29, 0x3e	; 62
    11c4:	9a 83       	std	Y+2, r25	; 0x02
    11c6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    11c8:	e9 81       	ldd	r30, Y+1	; 0x01
    11ca:	fa 81       	ldd	r31, Y+2	; 0x02
    11cc:	11 86       	std	Z+9, r1	; 0x09
    11ce:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    11d0:	0f 90       	pop	r0
    11d2:	0f 90       	pop	r0
    11d4:	cf 91       	pop	r28
    11d6:	df 91       	pop	r29
    11d8:	08 95       	ret

000011da <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11da:	df 93       	push	r29
    11dc:	cf 93       	push	r28
    11de:	00 d0       	rcall	.+0      	; 0x11e0 <vListInsertEnd+0x6>
    11e0:	00 d0       	rcall	.+0      	; 0x11e2 <vListInsertEnd+0x8>
    11e2:	00 d0       	rcall	.+0      	; 0x11e4 <vListInsertEnd+0xa>
    11e4:	cd b7       	in	r28, 0x3d	; 61
    11e6:	de b7       	in	r29, 0x3e	; 62
    11e8:	9c 83       	std	Y+4, r25	; 0x04
    11ea:	8b 83       	std	Y+3, r24	; 0x03
    11ec:	7e 83       	std	Y+6, r23	; 0x06
    11ee:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    11f0:	eb 81       	ldd	r30, Y+3	; 0x03
    11f2:	fc 81       	ldd	r31, Y+4	; 0x04
    11f4:	81 81       	ldd	r24, Z+1	; 0x01
    11f6:	92 81       	ldd	r25, Z+2	; 0x02
    11f8:	9a 83       	std	Y+2, r25	; 0x02
    11fa:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    11fc:	ed 81       	ldd	r30, Y+5	; 0x05
    11fe:	fe 81       	ldd	r31, Y+6	; 0x06
    1200:	89 81       	ldd	r24, Y+1	; 0x01
    1202:	9a 81       	ldd	r25, Y+2	; 0x02
    1204:	93 83       	std	Z+3, r25	; 0x03
    1206:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1208:	e9 81       	ldd	r30, Y+1	; 0x01
    120a:	fa 81       	ldd	r31, Y+2	; 0x02
    120c:	84 81       	ldd	r24, Z+4	; 0x04
    120e:	95 81       	ldd	r25, Z+5	; 0x05
    1210:	ed 81       	ldd	r30, Y+5	; 0x05
    1212:	fe 81       	ldd	r31, Y+6	; 0x06
    1214:	95 83       	std	Z+5, r25	; 0x05
    1216:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1218:	e9 81       	ldd	r30, Y+1	; 0x01
    121a:	fa 81       	ldd	r31, Y+2	; 0x02
    121c:	04 80       	ldd	r0, Z+4	; 0x04
    121e:	f5 81       	ldd	r31, Z+5	; 0x05
    1220:	e0 2d       	mov	r30, r0
    1222:	8d 81       	ldd	r24, Y+5	; 0x05
    1224:	9e 81       	ldd	r25, Y+6	; 0x06
    1226:	93 83       	std	Z+3, r25	; 0x03
    1228:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    122a:	e9 81       	ldd	r30, Y+1	; 0x01
    122c:	fa 81       	ldd	r31, Y+2	; 0x02
    122e:	8d 81       	ldd	r24, Y+5	; 0x05
    1230:	9e 81       	ldd	r25, Y+6	; 0x06
    1232:	95 83       	std	Z+5, r25	; 0x05
    1234:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1236:	ed 81       	ldd	r30, Y+5	; 0x05
    1238:	fe 81       	ldd	r31, Y+6	; 0x06
    123a:	8b 81       	ldd	r24, Y+3	; 0x03
    123c:	9c 81       	ldd	r25, Y+4	; 0x04
    123e:	91 87       	std	Z+9, r25	; 0x09
    1240:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1242:	eb 81       	ldd	r30, Y+3	; 0x03
    1244:	fc 81       	ldd	r31, Y+4	; 0x04
    1246:	80 81       	ld	r24, Z
    1248:	8f 5f       	subi	r24, 0xFF	; 255
    124a:	eb 81       	ldd	r30, Y+3	; 0x03
    124c:	fc 81       	ldd	r31, Y+4	; 0x04
    124e:	80 83       	st	Z, r24
}
    1250:	26 96       	adiw	r28, 0x06	; 6
    1252:	0f b6       	in	r0, 0x3f	; 63
    1254:	f8 94       	cli
    1256:	de bf       	out	0x3e, r29	; 62
    1258:	0f be       	out	0x3f, r0	; 63
    125a:	cd bf       	out	0x3d, r28	; 61
    125c:	cf 91       	pop	r28
    125e:	df 91       	pop	r29
    1260:	08 95       	ret

00001262 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1262:	df 93       	push	r29
    1264:	cf 93       	push	r28
    1266:	cd b7       	in	r28, 0x3d	; 61
    1268:	de b7       	in	r29, 0x3e	; 62
    126a:	28 97       	sbiw	r28, 0x08	; 8
    126c:	0f b6       	in	r0, 0x3f	; 63
    126e:	f8 94       	cli
    1270:	de bf       	out	0x3e, r29	; 62
    1272:	0f be       	out	0x3f, r0	; 63
    1274:	cd bf       	out	0x3d, r28	; 61
    1276:	9e 83       	std	Y+6, r25	; 0x06
    1278:	8d 83       	std	Y+5, r24	; 0x05
    127a:	78 87       	std	Y+8, r23	; 0x08
    127c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    127e:	ef 81       	ldd	r30, Y+7	; 0x07
    1280:	f8 85       	ldd	r31, Y+8	; 0x08
    1282:	80 81       	ld	r24, Z
    1284:	91 81       	ldd	r25, Z+1	; 0x01
    1286:	9a 83       	std	Y+2, r25	; 0x02
    1288:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    128a:	89 81       	ldd	r24, Y+1	; 0x01
    128c:	9a 81       	ldd	r25, Y+2	; 0x02
    128e:	2f ef       	ldi	r18, 0xFF	; 255
    1290:	8f 3f       	cpi	r24, 0xFF	; 255
    1292:	92 07       	cpc	r25, r18
    1294:	39 f4       	brne	.+14     	; 0x12a4 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1296:	ed 81       	ldd	r30, Y+5	; 0x05
    1298:	fe 81       	ldd	r31, Y+6	; 0x06
    129a:	87 81       	ldd	r24, Z+7	; 0x07
    129c:	90 85       	ldd	r25, Z+8	; 0x08
    129e:	9c 83       	std	Y+4, r25	; 0x04
    12a0:	8b 83       	std	Y+3, r24	; 0x03
    12a2:	18 c0       	rjmp	.+48     	; 0x12d4 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12a4:	8d 81       	ldd	r24, Y+5	; 0x05
    12a6:	9e 81       	ldd	r25, Y+6	; 0x06
    12a8:	03 96       	adiw	r24, 0x03	; 3
    12aa:	9c 83       	std	Y+4, r25	; 0x04
    12ac:	8b 83       	std	Y+3, r24	; 0x03
    12ae:	06 c0       	rjmp	.+12     	; 0x12bc <vListInsert+0x5a>
    12b0:	eb 81       	ldd	r30, Y+3	; 0x03
    12b2:	fc 81       	ldd	r31, Y+4	; 0x04
    12b4:	82 81       	ldd	r24, Z+2	; 0x02
    12b6:	93 81       	ldd	r25, Z+3	; 0x03
    12b8:	9c 83       	std	Y+4, r25	; 0x04
    12ba:	8b 83       	std	Y+3, r24	; 0x03
    12bc:	eb 81       	ldd	r30, Y+3	; 0x03
    12be:	fc 81       	ldd	r31, Y+4	; 0x04
    12c0:	02 80       	ldd	r0, Z+2	; 0x02
    12c2:	f3 81       	ldd	r31, Z+3	; 0x03
    12c4:	e0 2d       	mov	r30, r0
    12c6:	20 81       	ld	r18, Z
    12c8:	31 81       	ldd	r19, Z+1	; 0x01
    12ca:	89 81       	ldd	r24, Y+1	; 0x01
    12cc:	9a 81       	ldd	r25, Y+2	; 0x02
    12ce:	82 17       	cp	r24, r18
    12d0:	93 07       	cpc	r25, r19
    12d2:	70 f7       	brcc	.-36     	; 0x12b0 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    12d4:	eb 81       	ldd	r30, Y+3	; 0x03
    12d6:	fc 81       	ldd	r31, Y+4	; 0x04
    12d8:	82 81       	ldd	r24, Z+2	; 0x02
    12da:	93 81       	ldd	r25, Z+3	; 0x03
    12dc:	ef 81       	ldd	r30, Y+7	; 0x07
    12de:	f8 85       	ldd	r31, Y+8	; 0x08
    12e0:	93 83       	std	Z+3, r25	; 0x03
    12e2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    12e4:	ef 81       	ldd	r30, Y+7	; 0x07
    12e6:	f8 85       	ldd	r31, Y+8	; 0x08
    12e8:	02 80       	ldd	r0, Z+2	; 0x02
    12ea:	f3 81       	ldd	r31, Z+3	; 0x03
    12ec:	e0 2d       	mov	r30, r0
    12ee:	8f 81       	ldd	r24, Y+7	; 0x07
    12f0:	98 85       	ldd	r25, Y+8	; 0x08
    12f2:	95 83       	std	Z+5, r25	; 0x05
    12f4:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    12f6:	ef 81       	ldd	r30, Y+7	; 0x07
    12f8:	f8 85       	ldd	r31, Y+8	; 0x08
    12fa:	8b 81       	ldd	r24, Y+3	; 0x03
    12fc:	9c 81       	ldd	r25, Y+4	; 0x04
    12fe:	95 83       	std	Z+5, r25	; 0x05
    1300:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1302:	eb 81       	ldd	r30, Y+3	; 0x03
    1304:	fc 81       	ldd	r31, Y+4	; 0x04
    1306:	8f 81       	ldd	r24, Y+7	; 0x07
    1308:	98 85       	ldd	r25, Y+8	; 0x08
    130a:	93 83       	std	Z+3, r25	; 0x03
    130c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    130e:	ef 81       	ldd	r30, Y+7	; 0x07
    1310:	f8 85       	ldd	r31, Y+8	; 0x08
    1312:	8d 81       	ldd	r24, Y+5	; 0x05
    1314:	9e 81       	ldd	r25, Y+6	; 0x06
    1316:	91 87       	std	Z+9, r25	; 0x09
    1318:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    131a:	ed 81       	ldd	r30, Y+5	; 0x05
    131c:	fe 81       	ldd	r31, Y+6	; 0x06
    131e:	80 81       	ld	r24, Z
    1320:	8f 5f       	subi	r24, 0xFF	; 255
    1322:	ed 81       	ldd	r30, Y+5	; 0x05
    1324:	fe 81       	ldd	r31, Y+6	; 0x06
    1326:	80 83       	st	Z, r24
}
    1328:	28 96       	adiw	r28, 0x08	; 8
    132a:	0f b6       	in	r0, 0x3f	; 63
    132c:	f8 94       	cli
    132e:	de bf       	out	0x3e, r29	; 62
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	cd bf       	out	0x3d, r28	; 61
    1334:	cf 91       	pop	r28
    1336:	df 91       	pop	r29
    1338:	08 95       	ret

0000133a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    133a:	df 93       	push	r29
    133c:	cf 93       	push	r28
    133e:	00 d0       	rcall	.+0      	; 0x1340 <uxListRemove+0x6>
    1340:	00 d0       	rcall	.+0      	; 0x1342 <uxListRemove+0x8>
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
    1346:	9c 83       	std	Y+4, r25	; 0x04
    1348:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    134a:	eb 81       	ldd	r30, Y+3	; 0x03
    134c:	fc 81       	ldd	r31, Y+4	; 0x04
    134e:	80 85       	ldd	r24, Z+8	; 0x08
    1350:	91 85       	ldd	r25, Z+9	; 0x09
    1352:	9a 83       	std	Y+2, r25	; 0x02
    1354:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1356:	eb 81       	ldd	r30, Y+3	; 0x03
    1358:	fc 81       	ldd	r31, Y+4	; 0x04
    135a:	a2 81       	ldd	r26, Z+2	; 0x02
    135c:	b3 81       	ldd	r27, Z+3	; 0x03
    135e:	eb 81       	ldd	r30, Y+3	; 0x03
    1360:	fc 81       	ldd	r31, Y+4	; 0x04
    1362:	84 81       	ldd	r24, Z+4	; 0x04
    1364:	95 81       	ldd	r25, Z+5	; 0x05
    1366:	15 96       	adiw	r26, 0x05	; 5
    1368:	9c 93       	st	X, r25
    136a:	8e 93       	st	-X, r24
    136c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    136e:	eb 81       	ldd	r30, Y+3	; 0x03
    1370:	fc 81       	ldd	r31, Y+4	; 0x04
    1372:	a4 81       	ldd	r26, Z+4	; 0x04
    1374:	b5 81       	ldd	r27, Z+5	; 0x05
    1376:	eb 81       	ldd	r30, Y+3	; 0x03
    1378:	fc 81       	ldd	r31, Y+4	; 0x04
    137a:	82 81       	ldd	r24, Z+2	; 0x02
    137c:	93 81       	ldd	r25, Z+3	; 0x03
    137e:	13 96       	adiw	r26, 0x03	; 3
    1380:	9c 93       	st	X, r25
    1382:	8e 93       	st	-X, r24
    1384:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1386:	e9 81       	ldd	r30, Y+1	; 0x01
    1388:	fa 81       	ldd	r31, Y+2	; 0x02
    138a:	21 81       	ldd	r18, Z+1	; 0x01
    138c:	32 81       	ldd	r19, Z+2	; 0x02
    138e:	8b 81       	ldd	r24, Y+3	; 0x03
    1390:	9c 81       	ldd	r25, Y+4	; 0x04
    1392:	28 17       	cp	r18, r24
    1394:	39 07       	cpc	r19, r25
    1396:	41 f4       	brne	.+16     	; 0x13a8 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1398:	eb 81       	ldd	r30, Y+3	; 0x03
    139a:	fc 81       	ldd	r31, Y+4	; 0x04
    139c:	84 81       	ldd	r24, Z+4	; 0x04
    139e:	95 81       	ldd	r25, Z+5	; 0x05
    13a0:	e9 81       	ldd	r30, Y+1	; 0x01
    13a2:	fa 81       	ldd	r31, Y+2	; 0x02
    13a4:	92 83       	std	Z+2, r25	; 0x02
    13a6:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    13a8:	eb 81       	ldd	r30, Y+3	; 0x03
    13aa:	fc 81       	ldd	r31, Y+4	; 0x04
    13ac:	11 86       	std	Z+9, r1	; 0x09
    13ae:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    13b0:	e9 81       	ldd	r30, Y+1	; 0x01
    13b2:	fa 81       	ldd	r31, Y+2	; 0x02
    13b4:	80 81       	ld	r24, Z
    13b6:	81 50       	subi	r24, 0x01	; 1
    13b8:	e9 81       	ldd	r30, Y+1	; 0x01
    13ba:	fa 81       	ldd	r31, Y+2	; 0x02
    13bc:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    13be:	e9 81       	ldd	r30, Y+1	; 0x01
    13c0:	fa 81       	ldd	r31, Y+2	; 0x02
    13c2:	80 81       	ld	r24, Z
}
    13c4:	0f 90       	pop	r0
    13c6:	0f 90       	pop	r0
    13c8:	0f 90       	pop	r0
    13ca:	0f 90       	pop	r0
    13cc:	cf 91       	pop	r28
    13ce:	df 91       	pop	r29
    13d0:	08 95       	ret

000013d2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    13d2:	df 93       	push	r29
    13d4:	cf 93       	push	r28
    13d6:	cd b7       	in	r28, 0x3d	; 61
    13d8:	de b7       	in	r29, 0x3e	; 62
    13da:	28 97       	sbiw	r28, 0x08	; 8
    13dc:	0f b6       	in	r0, 0x3f	; 63
    13de:	f8 94       	cli
    13e0:	de bf       	out	0x3e, r29	; 62
    13e2:	0f be       	out	0x3f, r0	; 63
    13e4:	cd bf       	out	0x3d, r28	; 61
    13e6:	9c 83       	std	Y+4, r25	; 0x04
    13e8:	8b 83       	std	Y+3, r24	; 0x03
    13ea:	7e 83       	std	Y+6, r23	; 0x06
    13ec:	6d 83       	std	Y+5, r22	; 0x05
    13ee:	58 87       	std	Y+8, r21	; 0x08
    13f0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    13f2:	eb 81       	ldd	r30, Y+3	; 0x03
    13f4:	fc 81       	ldd	r31, Y+4	; 0x04
    13f6:	81 e1       	ldi	r24, 0x11	; 17
    13f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    13fa:	8b 81       	ldd	r24, Y+3	; 0x03
    13fc:	9c 81       	ldd	r25, Y+4	; 0x04
    13fe:	01 97       	sbiw	r24, 0x01	; 1
    1400:	9c 83       	std	Y+4, r25	; 0x04
    1402:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1404:	eb 81       	ldd	r30, Y+3	; 0x03
    1406:	fc 81       	ldd	r31, Y+4	; 0x04
    1408:	82 e2       	ldi	r24, 0x22	; 34
    140a:	80 83       	st	Z, r24
	pxTopOfStack--;
    140c:	8b 81       	ldd	r24, Y+3	; 0x03
    140e:	9c 81       	ldd	r25, Y+4	; 0x04
    1410:	01 97       	sbiw	r24, 0x01	; 1
    1412:	9c 83       	std	Y+4, r25	; 0x04
    1414:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1416:	eb 81       	ldd	r30, Y+3	; 0x03
    1418:	fc 81       	ldd	r31, Y+4	; 0x04
    141a:	83 e3       	ldi	r24, 0x33	; 51
    141c:	80 83       	st	Z, r24
	pxTopOfStack--;
    141e:	8b 81       	ldd	r24, Y+3	; 0x03
    1420:	9c 81       	ldd	r25, Y+4	; 0x04
    1422:	01 97       	sbiw	r24, 0x01	; 1
    1424:	9c 83       	std	Y+4, r25	; 0x04
    1426:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1428:	8d 81       	ldd	r24, Y+5	; 0x05
    142a:	9e 81       	ldd	r25, Y+6	; 0x06
    142c:	9a 83       	std	Y+2, r25	; 0x02
    142e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1430:	89 81       	ldd	r24, Y+1	; 0x01
    1432:	eb 81       	ldd	r30, Y+3	; 0x03
    1434:	fc 81       	ldd	r31, Y+4	; 0x04
    1436:	80 83       	st	Z, r24
	pxTopOfStack--;
    1438:	8b 81       	ldd	r24, Y+3	; 0x03
    143a:	9c 81       	ldd	r25, Y+4	; 0x04
    143c:	01 97       	sbiw	r24, 0x01	; 1
    143e:	9c 83       	std	Y+4, r25	; 0x04
    1440:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1442:	89 81       	ldd	r24, Y+1	; 0x01
    1444:	9a 81       	ldd	r25, Y+2	; 0x02
    1446:	89 2f       	mov	r24, r25
    1448:	99 27       	eor	r25, r25
    144a:	9a 83       	std	Y+2, r25	; 0x02
    144c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	eb 81       	ldd	r30, Y+3	; 0x03
    1452:	fc 81       	ldd	r31, Y+4	; 0x04
    1454:	80 83       	st	Z, r24
	pxTopOfStack--;
    1456:	8b 81       	ldd	r24, Y+3	; 0x03
    1458:	9c 81       	ldd	r25, Y+4	; 0x04
    145a:	01 97       	sbiw	r24, 0x01	; 1
    145c:	9c 83       	std	Y+4, r25	; 0x04
    145e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1460:	eb 81       	ldd	r30, Y+3	; 0x03
    1462:	fc 81       	ldd	r31, Y+4	; 0x04
    1464:	10 82       	st	Z, r1
	pxTopOfStack--;
    1466:	8b 81       	ldd	r24, Y+3	; 0x03
    1468:	9c 81       	ldd	r25, Y+4	; 0x04
    146a:	01 97       	sbiw	r24, 0x01	; 1
    146c:	9c 83       	std	Y+4, r25	; 0x04
    146e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1470:	eb 81       	ldd	r30, Y+3	; 0x03
    1472:	fc 81       	ldd	r31, Y+4	; 0x04
    1474:	80 e8       	ldi	r24, 0x80	; 128
    1476:	80 83       	st	Z, r24
	pxTopOfStack--;
    1478:	8b 81       	ldd	r24, Y+3	; 0x03
    147a:	9c 81       	ldd	r25, Y+4	; 0x04
    147c:	01 97       	sbiw	r24, 0x01	; 1
    147e:	9c 83       	std	Y+4, r25	; 0x04
    1480:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	fc 81       	ldd	r31, Y+4	; 0x04
    1486:	10 82       	st	Z, r1
	pxTopOfStack--;
    1488:	8b 81       	ldd	r24, Y+3	; 0x03
    148a:	9c 81       	ldd	r25, Y+4	; 0x04
    148c:	01 97       	sbiw	r24, 0x01	; 1
    148e:	9c 83       	std	Y+4, r25	; 0x04
    1490:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1492:	eb 81       	ldd	r30, Y+3	; 0x03
    1494:	fc 81       	ldd	r31, Y+4	; 0x04
    1496:	82 e0       	ldi	r24, 0x02	; 2
    1498:	80 83       	st	Z, r24
	pxTopOfStack--;
    149a:	8b 81       	ldd	r24, Y+3	; 0x03
    149c:	9c 81       	ldd	r25, Y+4	; 0x04
    149e:	01 97       	sbiw	r24, 0x01	; 1
    14a0:	9c 83       	std	Y+4, r25	; 0x04
    14a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	83 e0       	ldi	r24, 0x03	; 3
    14aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ac:	8b 81       	ldd	r24, Y+3	; 0x03
    14ae:	9c 81       	ldd	r25, Y+4	; 0x04
    14b0:	01 97       	sbiw	r24, 0x01	; 1
    14b2:	9c 83       	std	Y+4, r25	; 0x04
    14b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    14b6:	eb 81       	ldd	r30, Y+3	; 0x03
    14b8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ba:	84 e0       	ldi	r24, 0x04	; 4
    14bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    14be:	8b 81       	ldd	r24, Y+3	; 0x03
    14c0:	9c 81       	ldd	r25, Y+4	; 0x04
    14c2:	01 97       	sbiw	r24, 0x01	; 1
    14c4:	9c 83       	std	Y+4, r25	; 0x04
    14c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    14c8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ca:	fc 81       	ldd	r31, Y+4	; 0x04
    14cc:	85 e0       	ldi	r24, 0x05	; 5
    14ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    14d0:	8b 81       	ldd	r24, Y+3	; 0x03
    14d2:	9c 81       	ldd	r25, Y+4	; 0x04
    14d4:	01 97       	sbiw	r24, 0x01	; 1
    14d6:	9c 83       	std	Y+4, r25	; 0x04
    14d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    14da:	eb 81       	ldd	r30, Y+3	; 0x03
    14dc:	fc 81       	ldd	r31, Y+4	; 0x04
    14de:	86 e0       	ldi	r24, 0x06	; 6
    14e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e2:	8b 81       	ldd	r24, Y+3	; 0x03
    14e4:	9c 81       	ldd	r25, Y+4	; 0x04
    14e6:	01 97       	sbiw	r24, 0x01	; 1
    14e8:	9c 83       	std	Y+4, r25	; 0x04
    14ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    14ec:	eb 81       	ldd	r30, Y+3	; 0x03
    14ee:	fc 81       	ldd	r31, Y+4	; 0x04
    14f0:	87 e0       	ldi	r24, 0x07	; 7
    14f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f4:	8b 81       	ldd	r24, Y+3	; 0x03
    14f6:	9c 81       	ldd	r25, Y+4	; 0x04
    14f8:	01 97       	sbiw	r24, 0x01	; 1
    14fa:	9c 83       	std	Y+4, r25	; 0x04
    14fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    14fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1500:	fc 81       	ldd	r31, Y+4	; 0x04
    1502:	88 e0       	ldi	r24, 0x08	; 8
    1504:	80 83       	st	Z, r24
	pxTopOfStack--;
    1506:	8b 81       	ldd	r24, Y+3	; 0x03
    1508:	9c 81       	ldd	r25, Y+4	; 0x04
    150a:	01 97       	sbiw	r24, 0x01	; 1
    150c:	9c 83       	std	Y+4, r25	; 0x04
    150e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1510:	eb 81       	ldd	r30, Y+3	; 0x03
    1512:	fc 81       	ldd	r31, Y+4	; 0x04
    1514:	89 e0       	ldi	r24, 0x09	; 9
    1516:	80 83       	st	Z, r24
	pxTopOfStack--;
    1518:	8b 81       	ldd	r24, Y+3	; 0x03
    151a:	9c 81       	ldd	r25, Y+4	; 0x04
    151c:	01 97       	sbiw	r24, 0x01	; 1
    151e:	9c 83       	std	Y+4, r25	; 0x04
    1520:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1522:	eb 81       	ldd	r30, Y+3	; 0x03
    1524:	fc 81       	ldd	r31, Y+4	; 0x04
    1526:	80 e1       	ldi	r24, 0x10	; 16
    1528:	80 83       	st	Z, r24
	pxTopOfStack--;
    152a:	8b 81       	ldd	r24, Y+3	; 0x03
    152c:	9c 81       	ldd	r25, Y+4	; 0x04
    152e:	01 97       	sbiw	r24, 0x01	; 1
    1530:	9c 83       	std	Y+4, r25	; 0x04
    1532:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1534:	eb 81       	ldd	r30, Y+3	; 0x03
    1536:	fc 81       	ldd	r31, Y+4	; 0x04
    1538:	81 e1       	ldi	r24, 0x11	; 17
    153a:	80 83       	st	Z, r24
	pxTopOfStack--;
    153c:	8b 81       	ldd	r24, Y+3	; 0x03
    153e:	9c 81       	ldd	r25, Y+4	; 0x04
    1540:	01 97       	sbiw	r24, 0x01	; 1
    1542:	9c 83       	std	Y+4, r25	; 0x04
    1544:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1546:	eb 81       	ldd	r30, Y+3	; 0x03
    1548:	fc 81       	ldd	r31, Y+4	; 0x04
    154a:	82 e1       	ldi	r24, 0x12	; 18
    154c:	80 83       	st	Z, r24
	pxTopOfStack--;
    154e:	8b 81       	ldd	r24, Y+3	; 0x03
    1550:	9c 81       	ldd	r25, Y+4	; 0x04
    1552:	01 97       	sbiw	r24, 0x01	; 1
    1554:	9c 83       	std	Y+4, r25	; 0x04
    1556:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1558:	eb 81       	ldd	r30, Y+3	; 0x03
    155a:	fc 81       	ldd	r31, Y+4	; 0x04
    155c:	83 e1       	ldi	r24, 0x13	; 19
    155e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1560:	8b 81       	ldd	r24, Y+3	; 0x03
    1562:	9c 81       	ldd	r25, Y+4	; 0x04
    1564:	01 97       	sbiw	r24, 0x01	; 1
    1566:	9c 83       	std	Y+4, r25	; 0x04
    1568:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    156a:	eb 81       	ldd	r30, Y+3	; 0x03
    156c:	fc 81       	ldd	r31, Y+4	; 0x04
    156e:	84 e1       	ldi	r24, 0x14	; 20
    1570:	80 83       	st	Z, r24
	pxTopOfStack--;
    1572:	8b 81       	ldd	r24, Y+3	; 0x03
    1574:	9c 81       	ldd	r25, Y+4	; 0x04
    1576:	01 97       	sbiw	r24, 0x01	; 1
    1578:	9c 83       	std	Y+4, r25	; 0x04
    157a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    157c:	eb 81       	ldd	r30, Y+3	; 0x03
    157e:	fc 81       	ldd	r31, Y+4	; 0x04
    1580:	85 e1       	ldi	r24, 0x15	; 21
    1582:	80 83       	st	Z, r24
	pxTopOfStack--;
    1584:	8b 81       	ldd	r24, Y+3	; 0x03
    1586:	9c 81       	ldd	r25, Y+4	; 0x04
    1588:	01 97       	sbiw	r24, 0x01	; 1
    158a:	9c 83       	std	Y+4, r25	; 0x04
    158c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    158e:	eb 81       	ldd	r30, Y+3	; 0x03
    1590:	fc 81       	ldd	r31, Y+4	; 0x04
    1592:	86 e1       	ldi	r24, 0x16	; 22
    1594:	80 83       	st	Z, r24
	pxTopOfStack--;
    1596:	8b 81       	ldd	r24, Y+3	; 0x03
    1598:	9c 81       	ldd	r25, Y+4	; 0x04
    159a:	01 97       	sbiw	r24, 0x01	; 1
    159c:	9c 83       	std	Y+4, r25	; 0x04
    159e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    15a0:	eb 81       	ldd	r30, Y+3	; 0x03
    15a2:	fc 81       	ldd	r31, Y+4	; 0x04
    15a4:	87 e1       	ldi	r24, 0x17	; 23
    15a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    15a8:	8b 81       	ldd	r24, Y+3	; 0x03
    15aa:	9c 81       	ldd	r25, Y+4	; 0x04
    15ac:	01 97       	sbiw	r24, 0x01	; 1
    15ae:	9c 83       	std	Y+4, r25	; 0x04
    15b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    15b2:	eb 81       	ldd	r30, Y+3	; 0x03
    15b4:	fc 81       	ldd	r31, Y+4	; 0x04
    15b6:	88 e1       	ldi	r24, 0x18	; 24
    15b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ba:	8b 81       	ldd	r24, Y+3	; 0x03
    15bc:	9c 81       	ldd	r25, Y+4	; 0x04
    15be:	01 97       	sbiw	r24, 0x01	; 1
    15c0:	9c 83       	std	Y+4, r25	; 0x04
    15c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    15c4:	eb 81       	ldd	r30, Y+3	; 0x03
    15c6:	fc 81       	ldd	r31, Y+4	; 0x04
    15c8:	89 e1       	ldi	r24, 0x19	; 25
    15ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    15cc:	8b 81       	ldd	r24, Y+3	; 0x03
    15ce:	9c 81       	ldd	r25, Y+4	; 0x04
    15d0:	01 97       	sbiw	r24, 0x01	; 1
    15d2:	9c 83       	std	Y+4, r25	; 0x04
    15d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    15d6:	eb 81       	ldd	r30, Y+3	; 0x03
    15d8:	fc 81       	ldd	r31, Y+4	; 0x04
    15da:	80 e2       	ldi	r24, 0x20	; 32
    15dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    15de:	8b 81       	ldd	r24, Y+3	; 0x03
    15e0:	9c 81       	ldd	r25, Y+4	; 0x04
    15e2:	01 97       	sbiw	r24, 0x01	; 1
    15e4:	9c 83       	std	Y+4, r25	; 0x04
    15e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    15e8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ea:	fc 81       	ldd	r31, Y+4	; 0x04
    15ec:	81 e2       	ldi	r24, 0x21	; 33
    15ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    15f0:	8b 81       	ldd	r24, Y+3	; 0x03
    15f2:	9c 81       	ldd	r25, Y+4	; 0x04
    15f4:	01 97       	sbiw	r24, 0x01	; 1
    15f6:	9c 83       	std	Y+4, r25	; 0x04
    15f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    15fa:	eb 81       	ldd	r30, Y+3	; 0x03
    15fc:	fc 81       	ldd	r31, Y+4	; 0x04
    15fe:	82 e2       	ldi	r24, 0x22	; 34
    1600:	80 83       	st	Z, r24
	pxTopOfStack--;
    1602:	8b 81       	ldd	r24, Y+3	; 0x03
    1604:	9c 81       	ldd	r25, Y+4	; 0x04
    1606:	01 97       	sbiw	r24, 0x01	; 1
    1608:	9c 83       	std	Y+4, r25	; 0x04
    160a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    160c:	eb 81       	ldd	r30, Y+3	; 0x03
    160e:	fc 81       	ldd	r31, Y+4	; 0x04
    1610:	83 e2       	ldi	r24, 0x23	; 35
    1612:	80 83       	st	Z, r24
	pxTopOfStack--;
    1614:	8b 81       	ldd	r24, Y+3	; 0x03
    1616:	9c 81       	ldd	r25, Y+4	; 0x04
    1618:	01 97       	sbiw	r24, 0x01	; 1
    161a:	9c 83       	std	Y+4, r25	; 0x04
    161c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    161e:	8f 81       	ldd	r24, Y+7	; 0x07
    1620:	98 85       	ldd	r25, Y+8	; 0x08
    1622:	9a 83       	std	Y+2, r25	; 0x02
    1624:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	eb 81       	ldd	r30, Y+3	; 0x03
    162a:	fc 81       	ldd	r31, Y+4	; 0x04
    162c:	80 83       	st	Z, r24
	pxTopOfStack--;
    162e:	8b 81       	ldd	r24, Y+3	; 0x03
    1630:	9c 81       	ldd	r25, Y+4	; 0x04
    1632:	01 97       	sbiw	r24, 0x01	; 1
    1634:	9c 83       	std	Y+4, r25	; 0x04
    1636:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1638:	89 81       	ldd	r24, Y+1	; 0x01
    163a:	9a 81       	ldd	r25, Y+2	; 0x02
    163c:	89 2f       	mov	r24, r25
    163e:	99 27       	eor	r25, r25
    1640:	9a 83       	std	Y+2, r25	; 0x02
    1642:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1644:	89 81       	ldd	r24, Y+1	; 0x01
    1646:	eb 81       	ldd	r30, Y+3	; 0x03
    1648:	fc 81       	ldd	r31, Y+4	; 0x04
    164a:	80 83       	st	Z, r24
	pxTopOfStack--;
    164c:	8b 81       	ldd	r24, Y+3	; 0x03
    164e:	9c 81       	ldd	r25, Y+4	; 0x04
    1650:	01 97       	sbiw	r24, 0x01	; 1
    1652:	9c 83       	std	Y+4, r25	; 0x04
    1654:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1656:	eb 81       	ldd	r30, Y+3	; 0x03
    1658:	fc 81       	ldd	r31, Y+4	; 0x04
    165a:	86 e2       	ldi	r24, 0x26	; 38
    165c:	80 83       	st	Z, r24
	pxTopOfStack--;
    165e:	8b 81       	ldd	r24, Y+3	; 0x03
    1660:	9c 81       	ldd	r25, Y+4	; 0x04
    1662:	01 97       	sbiw	r24, 0x01	; 1
    1664:	9c 83       	std	Y+4, r25	; 0x04
    1666:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1668:	eb 81       	ldd	r30, Y+3	; 0x03
    166a:	fc 81       	ldd	r31, Y+4	; 0x04
    166c:	87 e2       	ldi	r24, 0x27	; 39
    166e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1670:	8b 81       	ldd	r24, Y+3	; 0x03
    1672:	9c 81       	ldd	r25, Y+4	; 0x04
    1674:	01 97       	sbiw	r24, 0x01	; 1
    1676:	9c 83       	std	Y+4, r25	; 0x04
    1678:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    167a:	eb 81       	ldd	r30, Y+3	; 0x03
    167c:	fc 81       	ldd	r31, Y+4	; 0x04
    167e:	88 e2       	ldi	r24, 0x28	; 40
    1680:	80 83       	st	Z, r24
	pxTopOfStack--;
    1682:	8b 81       	ldd	r24, Y+3	; 0x03
    1684:	9c 81       	ldd	r25, Y+4	; 0x04
    1686:	01 97       	sbiw	r24, 0x01	; 1
    1688:	9c 83       	std	Y+4, r25	; 0x04
    168a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    168c:	eb 81       	ldd	r30, Y+3	; 0x03
    168e:	fc 81       	ldd	r31, Y+4	; 0x04
    1690:	89 e2       	ldi	r24, 0x29	; 41
    1692:	80 83       	st	Z, r24
	pxTopOfStack--;
    1694:	8b 81       	ldd	r24, Y+3	; 0x03
    1696:	9c 81       	ldd	r25, Y+4	; 0x04
    1698:	01 97       	sbiw	r24, 0x01	; 1
    169a:	9c 83       	std	Y+4, r25	; 0x04
    169c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    169e:	eb 81       	ldd	r30, Y+3	; 0x03
    16a0:	fc 81       	ldd	r31, Y+4	; 0x04
    16a2:	80 e3       	ldi	r24, 0x30	; 48
    16a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16a6:	8b 81       	ldd	r24, Y+3	; 0x03
    16a8:	9c 81       	ldd	r25, Y+4	; 0x04
    16aa:	01 97       	sbiw	r24, 0x01	; 1
    16ac:	9c 83       	std	Y+4, r25	; 0x04
    16ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    16b0:	eb 81       	ldd	r30, Y+3	; 0x03
    16b2:	fc 81       	ldd	r31, Y+4	; 0x04
    16b4:	81 e3       	ldi	r24, 0x31	; 49
    16b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    16b8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ba:	9c 81       	ldd	r25, Y+4	; 0x04
    16bc:	01 97       	sbiw	r24, 0x01	; 1
    16be:	9c 83       	std	Y+4, r25	; 0x04
    16c0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    16c2:	8b 81       	ldd	r24, Y+3	; 0x03
    16c4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    16c6:	28 96       	adiw	r28, 0x08	; 8
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	de bf       	out	0x3e, r29	; 62
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	cd bf       	out	0x3d, r28	; 61
    16d2:	cf 91       	pop	r28
    16d4:	df 91       	pop	r29
    16d6:	08 95       	ret

000016d8 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    16d8:	df 93       	push	r29
    16da:	cf 93       	push	r28
    16dc:	cd b7       	in	r28, 0x3d	; 61
    16de:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    16e0:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    16e4:	a0 91 3d 06 	lds	r26, 0x063D
    16e8:	b0 91 3e 06 	lds	r27, 0x063E
    16ec:	cd 91       	ld	r28, X+
    16ee:	cd bf       	out	0x3d, r28	; 61
    16f0:	dd 91       	ld	r29, X+
    16f2:	de bf       	out	0x3e, r29	; 62
    16f4:	ff 91       	pop	r31
    16f6:	ef 91       	pop	r30
    16f8:	df 91       	pop	r29
    16fa:	cf 91       	pop	r28
    16fc:	bf 91       	pop	r27
    16fe:	af 91       	pop	r26
    1700:	9f 91       	pop	r25
    1702:	8f 91       	pop	r24
    1704:	7f 91       	pop	r23
    1706:	6f 91       	pop	r22
    1708:	5f 91       	pop	r21
    170a:	4f 91       	pop	r20
    170c:	3f 91       	pop	r19
    170e:	2f 91       	pop	r18
    1710:	1f 91       	pop	r17
    1712:	0f 91       	pop	r16
    1714:	ff 90       	pop	r15
    1716:	ef 90       	pop	r14
    1718:	df 90       	pop	r13
    171a:	cf 90       	pop	r12
    171c:	bf 90       	pop	r11
    171e:	af 90       	pop	r10
    1720:	9f 90       	pop	r9
    1722:	8f 90       	pop	r8
    1724:	7f 90       	pop	r7
    1726:	6f 90       	pop	r6
    1728:	5f 90       	pop	r5
    172a:	4f 90       	pop	r4
    172c:	3f 90       	pop	r3
    172e:	2f 90       	pop	r2
    1730:	1f 90       	pop	r1
    1732:	0f 90       	pop	r0
    1734:	0f be       	out	0x3f, r0	; 63
    1736:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1738:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    173a:	81 e0       	ldi	r24, 0x01	; 1
}
    173c:	cf 91       	pop	r28
    173e:	df 91       	pop	r29
    1740:	08 95       	ret

00001742 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1742:	df 93       	push	r29
    1744:	cf 93       	push	r28
    1746:	cd b7       	in	r28, 0x3d	; 61
    1748:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    174a:	cf 91       	pop	r28
    174c:	df 91       	pop	r29
    174e:	08 95       	ret

00001750 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1750:	0f 92       	push	r0
    1752:	0f b6       	in	r0, 0x3f	; 63
    1754:	f8 94       	cli
    1756:	0f 92       	push	r0
    1758:	1f 92       	push	r1
    175a:	11 24       	eor	r1, r1
    175c:	2f 92       	push	r2
    175e:	3f 92       	push	r3
    1760:	4f 92       	push	r4
    1762:	5f 92       	push	r5
    1764:	6f 92       	push	r6
    1766:	7f 92       	push	r7
    1768:	8f 92       	push	r8
    176a:	9f 92       	push	r9
    176c:	af 92       	push	r10
    176e:	bf 92       	push	r11
    1770:	cf 92       	push	r12
    1772:	df 92       	push	r13
    1774:	ef 92       	push	r14
    1776:	ff 92       	push	r15
    1778:	0f 93       	push	r16
    177a:	1f 93       	push	r17
    177c:	2f 93       	push	r18
    177e:	3f 93       	push	r19
    1780:	4f 93       	push	r20
    1782:	5f 93       	push	r21
    1784:	6f 93       	push	r22
    1786:	7f 93       	push	r23
    1788:	8f 93       	push	r24
    178a:	9f 93       	push	r25
    178c:	af 93       	push	r26
    178e:	bf 93       	push	r27
    1790:	cf 93       	push	r28
    1792:	df 93       	push	r29
    1794:	ef 93       	push	r30
    1796:	ff 93       	push	r31
    1798:	a0 91 3d 06 	lds	r26, 0x063D
    179c:	b0 91 3e 06 	lds	r27, 0x063E
    17a0:	0d b6       	in	r0, 0x3d	; 61
    17a2:	0d 92       	st	X+, r0
    17a4:	0e b6       	in	r0, 0x3e	; 62
    17a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    17a8:	0e 94 04 1a 	call	0x3408	; 0x3408 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17ac:	a0 91 3d 06 	lds	r26, 0x063D
    17b0:	b0 91 3e 06 	lds	r27, 0x063E
    17b4:	cd 91       	ld	r28, X+
    17b6:	cd bf       	out	0x3d, r28	; 61
    17b8:	dd 91       	ld	r29, X+
    17ba:	de bf       	out	0x3e, r29	; 62
    17bc:	ff 91       	pop	r31
    17be:	ef 91       	pop	r30
    17c0:	df 91       	pop	r29
    17c2:	cf 91       	pop	r28
    17c4:	bf 91       	pop	r27
    17c6:	af 91       	pop	r26
    17c8:	9f 91       	pop	r25
    17ca:	8f 91       	pop	r24
    17cc:	7f 91       	pop	r23
    17ce:	6f 91       	pop	r22
    17d0:	5f 91       	pop	r21
    17d2:	4f 91       	pop	r20
    17d4:	3f 91       	pop	r19
    17d6:	2f 91       	pop	r18
    17d8:	1f 91       	pop	r17
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	cf 90       	pop	r12
    17e4:	bf 90       	pop	r11
    17e6:	af 90       	pop	r10
    17e8:	9f 90       	pop	r9
    17ea:	8f 90       	pop	r8
    17ec:	7f 90       	pop	r7
    17ee:	6f 90       	pop	r6
    17f0:	5f 90       	pop	r5
    17f2:	4f 90       	pop	r4
    17f4:	3f 90       	pop	r3
    17f6:	2f 90       	pop	r2
    17f8:	1f 90       	pop	r1
    17fa:	0f 90       	pop	r0
    17fc:	0f be       	out	0x3f, r0	; 63
    17fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1800:	08 95       	ret

00001802 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1802:	0f 92       	push	r0
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	0f 92       	push	r0
    180a:	1f 92       	push	r1
    180c:	11 24       	eor	r1, r1
    180e:	2f 92       	push	r2
    1810:	3f 92       	push	r3
    1812:	4f 92       	push	r4
    1814:	5f 92       	push	r5
    1816:	6f 92       	push	r6
    1818:	7f 92       	push	r7
    181a:	8f 92       	push	r8
    181c:	9f 92       	push	r9
    181e:	af 92       	push	r10
    1820:	bf 92       	push	r11
    1822:	cf 92       	push	r12
    1824:	df 92       	push	r13
    1826:	ef 92       	push	r14
    1828:	ff 92       	push	r15
    182a:	0f 93       	push	r16
    182c:	1f 93       	push	r17
    182e:	2f 93       	push	r18
    1830:	3f 93       	push	r19
    1832:	4f 93       	push	r20
    1834:	5f 93       	push	r21
    1836:	6f 93       	push	r22
    1838:	7f 93       	push	r23
    183a:	8f 93       	push	r24
    183c:	9f 93       	push	r25
    183e:	af 93       	push	r26
    1840:	bf 93       	push	r27
    1842:	cf 93       	push	r28
    1844:	df 93       	push	r29
    1846:	ef 93       	push	r30
    1848:	ff 93       	push	r31
    184a:	a0 91 3d 06 	lds	r26, 0x063D
    184e:	b0 91 3e 06 	lds	r27, 0x063E
    1852:	0d b6       	in	r0, 0x3d	; 61
    1854:	0d 92       	st	X+, r0
    1856:	0e b6       	in	r0, 0x3e	; 62
    1858:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    185a:	0e 94 1f 19 	call	0x323e	; 0x323e <xTaskIncrementTick>
    185e:	88 23       	and	r24, r24
    1860:	11 f0       	breq	.+4      	; 0x1866 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1862:	0e 94 04 1a 	call	0x3408	; 0x3408 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1866:	a0 91 3d 06 	lds	r26, 0x063D
    186a:	b0 91 3e 06 	lds	r27, 0x063E
    186e:	cd 91       	ld	r28, X+
    1870:	cd bf       	out	0x3d, r28	; 61
    1872:	dd 91       	ld	r29, X+
    1874:	de bf       	out	0x3e, r29	; 62
    1876:	ff 91       	pop	r31
    1878:	ef 91       	pop	r30
    187a:	df 91       	pop	r29
    187c:	cf 91       	pop	r28
    187e:	bf 91       	pop	r27
    1880:	af 91       	pop	r26
    1882:	9f 91       	pop	r25
    1884:	8f 91       	pop	r24
    1886:	7f 91       	pop	r23
    1888:	6f 91       	pop	r22
    188a:	5f 91       	pop	r21
    188c:	4f 91       	pop	r20
    188e:	3f 91       	pop	r19
    1890:	2f 91       	pop	r18
    1892:	1f 91       	pop	r17
    1894:	0f 91       	pop	r16
    1896:	ff 90       	pop	r15
    1898:	ef 90       	pop	r14
    189a:	df 90       	pop	r13
    189c:	cf 90       	pop	r12
    189e:	bf 90       	pop	r11
    18a0:	af 90       	pop	r10
    18a2:	9f 90       	pop	r9
    18a4:	8f 90       	pop	r8
    18a6:	7f 90       	pop	r7
    18a8:	6f 90       	pop	r6
    18aa:	5f 90       	pop	r5
    18ac:	4f 90       	pop	r4
    18ae:	3f 90       	pop	r3
    18b0:	2f 90       	pop	r2
    18b2:	1f 90       	pop	r1
    18b4:	0f 90       	pop	r0
    18b6:	0f be       	out	0x3f, r0	; 63
    18b8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18ba:	08 95       	ret

000018bc <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    18bc:	df 93       	push	r29
    18be:	cf 93       	push	r28
    18c0:	00 d0       	rcall	.+0      	; 0x18c2 <prvSetupTimerInterrupt+0x6>
    18c2:	00 d0       	rcall	.+0      	; 0x18c4 <prvSetupTimerInterrupt+0x8>
    18c4:	00 d0       	rcall	.+0      	; 0x18c6 <prvSetupTimerInterrupt+0xa>
    18c6:	cd b7       	in	r28, 0x3d	; 61
    18c8:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    18ca:	80 e8       	ldi	r24, 0x80	; 128
    18cc:	9e e3       	ldi	r25, 0x3E	; 62
    18ce:	a0 e0       	ldi	r26, 0x00	; 0
    18d0:	b0 e0       	ldi	r27, 0x00	; 0
    18d2:	8b 83       	std	Y+3, r24	; 0x03
    18d4:	9c 83       	std	Y+4, r25	; 0x04
    18d6:	ad 83       	std	Y+5, r26	; 0x05
    18d8:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    18da:	8b 81       	ldd	r24, Y+3	; 0x03
    18dc:	9c 81       	ldd	r25, Y+4	; 0x04
    18de:	ad 81       	ldd	r26, Y+5	; 0x05
    18e0:	be 81       	ldd	r27, Y+6	; 0x06
    18e2:	68 94       	set
    18e4:	15 f8       	bld	r1, 5
    18e6:	b6 95       	lsr	r27
    18e8:	a7 95       	ror	r26
    18ea:	97 95       	ror	r25
    18ec:	87 95       	ror	r24
    18ee:	16 94       	lsr	r1
    18f0:	d1 f7       	brne	.-12     	; 0x18e6 <prvSetupTimerInterrupt+0x2a>
    18f2:	8b 83       	std	Y+3, r24	; 0x03
    18f4:	9c 83       	std	Y+4, r25	; 0x04
    18f6:	ad 83       	std	Y+5, r26	; 0x05
    18f8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    18fa:	8b 81       	ldd	r24, Y+3	; 0x03
    18fc:	9c 81       	ldd	r25, Y+4	; 0x04
    18fe:	ad 81       	ldd	r26, Y+5	; 0x05
    1900:	be 81       	ldd	r27, Y+6	; 0x06
    1902:	01 97       	sbiw	r24, 0x01	; 1
    1904:	a1 09       	sbc	r26, r1
    1906:	b1 09       	sbc	r27, r1
    1908:	8b 83       	std	Y+3, r24	; 0x03
    190a:	9c 83       	std	Y+4, r25	; 0x04
    190c:	ad 83       	std	Y+5, r26	; 0x05
    190e:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1910:	8b 81       	ldd	r24, Y+3	; 0x03
    1912:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1914:	8b 81       	ldd	r24, Y+3	; 0x03
    1916:	9c 81       	ldd	r25, Y+4	; 0x04
    1918:	ad 81       	ldd	r26, Y+5	; 0x05
    191a:	be 81       	ldd	r27, Y+6	; 0x06
    191c:	89 2f       	mov	r24, r25
    191e:	9a 2f       	mov	r25, r26
    1920:	ab 2f       	mov	r26, r27
    1922:	bb 27       	eor	r27, r27
    1924:	8b 83       	std	Y+3, r24	; 0x03
    1926:	9c 83       	std	Y+4, r25	; 0x04
    1928:	ad 83       	std	Y+5, r26	; 0x05
    192a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    192c:	8b 81       	ldd	r24, Y+3	; 0x03
    192e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1930:	eb e4       	ldi	r30, 0x4B	; 75
    1932:	f0 e0       	ldi	r31, 0x00	; 0
    1934:	8a 81       	ldd	r24, Y+2	; 0x02
    1936:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1938:	ea e4       	ldi	r30, 0x4A	; 74
    193a:	f0 e0       	ldi	r31, 0x00	; 0
    193c:	89 81       	ldd	r24, Y+1	; 0x01
    193e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1940:	8b e0       	ldi	r24, 0x0B	; 11
    1942:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1944:	ee e4       	ldi	r30, 0x4E	; 78
    1946:	f0 e0       	ldi	r31, 0x00	; 0
    1948:	89 81       	ldd	r24, Y+1	; 0x01
    194a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    194c:	e9 e5       	ldi	r30, 0x59	; 89
    194e:	f0 e0       	ldi	r31, 0x00	; 0
    1950:	80 81       	ld	r24, Z
    1952:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	80 61       	ori	r24, 0x10	; 16
    1958:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    195a:	e9 e5       	ldi	r30, 0x59	; 89
    195c:	f0 e0       	ldi	r31, 0x00	; 0
    195e:	89 81       	ldd	r24, Y+1	; 0x01
    1960:	80 83       	st	Z, r24
}
    1962:	26 96       	adiw	r28, 0x06	; 6
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	f8 94       	cli
    1968:	de bf       	out	0x3e, r29	; 62
    196a:	0f be       	out	0x3f, r0	; 63
    196c:	cd bf       	out	0x3d, r28	; 61
    196e:	cf 91       	pop	r28
    1970:	df 91       	pop	r29
    1972:	08 95       	ret

00001974 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1974:	0e 94 01 0c 	call	0x1802	; 0x1802 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1978:	18 95       	reti

0000197a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    197a:	df 93       	push	r29
    197c:	cf 93       	push	r28
    197e:	00 d0       	rcall	.+0      	; 0x1980 <xQueueGenericReset+0x6>
    1980:	00 d0       	rcall	.+0      	; 0x1982 <xQueueGenericReset+0x8>
    1982:	0f 92       	push	r0
    1984:	cd b7       	in	r28, 0x3d	; 61
    1986:	de b7       	in	r29, 0x3e	; 62
    1988:	9c 83       	std	Y+4, r25	; 0x04
    198a:	8b 83       	std	Y+3, r24	; 0x03
    198c:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	9c 81       	ldd	r25, Y+4	; 0x04
    1992:	9a 83       	std	Y+2, r25	; 0x02
    1994:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    199c:	e9 81       	ldd	r30, Y+1	; 0x01
    199e:	fa 81       	ldd	r31, Y+2	; 0x02
    19a0:	40 81       	ld	r20, Z
    19a2:	51 81       	ldd	r21, Z+1	; 0x01
    19a4:	e9 81       	ldd	r30, Y+1	; 0x01
    19a6:	fa 81       	ldd	r31, Y+2	; 0x02
    19a8:	83 8d       	ldd	r24, Z+27	; 0x1b
    19aa:	28 2f       	mov	r18, r24
    19ac:	30 e0       	ldi	r19, 0x00	; 0
    19ae:	e9 81       	ldd	r30, Y+1	; 0x01
    19b0:	fa 81       	ldd	r31, Y+2	; 0x02
    19b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	bc 01       	movw	r22, r24
    19ba:	26 9f       	mul	r18, r22
    19bc:	c0 01       	movw	r24, r0
    19be:	27 9f       	mul	r18, r23
    19c0:	90 0d       	add	r25, r0
    19c2:	36 9f       	mul	r19, r22
    19c4:	90 0d       	add	r25, r0
    19c6:	11 24       	eor	r1, r1
    19c8:	84 0f       	add	r24, r20
    19ca:	95 1f       	adc	r25, r21
    19cc:	e9 81       	ldd	r30, Y+1	; 0x01
    19ce:	fa 81       	ldd	r31, Y+2	; 0x02
    19d0:	93 83       	std	Z+3, r25	; 0x03
    19d2:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19d4:	e9 81       	ldd	r30, Y+1	; 0x01
    19d6:	fa 81       	ldd	r31, Y+2	; 0x02
    19d8:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    19da:	e9 81       	ldd	r30, Y+1	; 0x01
    19dc:	fa 81       	ldd	r31, Y+2	; 0x02
    19de:	80 81       	ld	r24, Z
    19e0:	91 81       	ldd	r25, Z+1	; 0x01
    19e2:	e9 81       	ldd	r30, Y+1	; 0x01
    19e4:	fa 81       	ldd	r31, Y+2	; 0x02
    19e6:	95 83       	std	Z+5, r25	; 0x05
    19e8:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    19ea:	e9 81       	ldd	r30, Y+1	; 0x01
    19ec:	fa 81       	ldd	r31, Y+2	; 0x02
    19ee:	40 81       	ld	r20, Z
    19f0:	51 81       	ldd	r21, Z+1	; 0x01
    19f2:	e9 81       	ldd	r30, Y+1	; 0x01
    19f4:	fa 81       	ldd	r31, Y+2	; 0x02
    19f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    19f8:	88 2f       	mov	r24, r24
    19fa:	90 e0       	ldi	r25, 0x00	; 0
    19fc:	9c 01       	movw	r18, r24
    19fe:	21 50       	subi	r18, 0x01	; 1
    1a00:	30 40       	sbci	r19, 0x00	; 0
    1a02:	e9 81       	ldd	r30, Y+1	; 0x01
    1a04:	fa 81       	ldd	r31, Y+2	; 0x02
    1a06:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a08:	88 2f       	mov	r24, r24
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	bc 01       	movw	r22, r24
    1a0e:	26 9f       	mul	r18, r22
    1a10:	c0 01       	movw	r24, r0
    1a12:	27 9f       	mul	r18, r23
    1a14:	90 0d       	add	r25, r0
    1a16:	36 9f       	mul	r19, r22
    1a18:	90 0d       	add	r25, r0
    1a1a:	11 24       	eor	r1, r1
    1a1c:	84 0f       	add	r24, r20
    1a1e:	95 1f       	adc	r25, r21
    1a20:	e9 81       	ldd	r30, Y+1	; 0x01
    1a22:	fa 81       	ldd	r31, Y+2	; 0x02
    1a24:	97 83       	std	Z+7, r25	; 0x07
    1a26:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1a28:	e9 81       	ldd	r30, Y+1	; 0x01
    1a2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a2c:	8f ef       	ldi	r24, 0xFF	; 255
    1a2e:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1a30:	e9 81       	ldd	r30, Y+1	; 0x01
    1a32:	fa 81       	ldd	r31, Y+2	; 0x02
    1a34:	8f ef       	ldi	r24, 0xFF	; 255
    1a36:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1a38:	8d 81       	ldd	r24, Y+5	; 0x05
    1a3a:	88 23       	and	r24, r24
    1a3c:	79 f4       	brne	.+30     	; 0x1a5c <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a40:	fa 81       	ldd	r31, Y+2	; 0x02
    1a42:	80 85       	ldd	r24, Z+8	; 0x08
    1a44:	88 23       	and	r24, r24
    1a46:	a1 f0       	breq	.+40     	; 0x1a70 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a48:	89 81       	ldd	r24, Y+1	; 0x01
    1a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a4c:	08 96       	adiw	r24, 0x08	; 8
    1a4e:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    1a52:	88 23       	and	r24, r24
    1a54:	69 f0       	breq	.+26     	; 0x1a70 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1a56:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
    1a5a:	0a c0       	rjmp	.+20     	; 0x1a70 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a60:	08 96       	adiw	r24, 0x08	; 8
    1a62:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1a66:	89 81       	ldd	r24, Y+1	; 0x01
    1a68:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6a:	41 96       	adiw	r24, 0x11	; 17
    1a6c:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1a70:	0f 90       	pop	r0
    1a72:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
}
    1a76:	0f 90       	pop	r0
    1a78:	0f 90       	pop	r0
    1a7a:	0f 90       	pop	r0
    1a7c:	0f 90       	pop	r0
    1a7e:	0f 90       	pop	r0
    1a80:	cf 91       	pop	r28
    1a82:	df 91       	pop	r29
    1a84:	08 95       	ret

00001a86 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1a86:	0f 93       	push	r16
    1a88:	1f 93       	push	r17
    1a8a:	df 93       	push	r29
    1a8c:	cf 93       	push	r28
    1a8e:	cd b7       	in	r28, 0x3d	; 61
    1a90:	de b7       	in	r29, 0x3e	; 62
    1a92:	29 97       	sbiw	r28, 0x09	; 9
    1a94:	0f b6       	in	r0, 0x3f	; 63
    1a96:	f8 94       	cli
    1a98:	de bf       	out	0x3e, r29	; 62
    1a9a:	0f be       	out	0x3f, r0	; 63
    1a9c:	cd bf       	out	0x3d, r28	; 61
    1a9e:	8f 83       	std	Y+7, r24	; 0x07
    1aa0:	68 87       	std	Y+8, r22	; 0x08
    1aa2:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1aa4:	88 85       	ldd	r24, Y+8	; 0x08
    1aa6:	88 23       	and	r24, r24
    1aa8:	19 f4       	brne	.+6      	; 0x1ab0 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1aaa:	1c 82       	std	Y+4, r1	; 0x04
    1aac:	1b 82       	std	Y+3, r1	; 0x03
    1aae:	10 c0       	rjmp	.+32     	; 0x1ad0 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ab0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ab2:	28 2f       	mov	r18, r24
    1ab4:	30 e0       	ldi	r19, 0x00	; 0
    1ab6:	88 85       	ldd	r24, Y+8	; 0x08
    1ab8:	88 2f       	mov	r24, r24
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	ac 01       	movw	r20, r24
    1abe:	24 9f       	mul	r18, r20
    1ac0:	c0 01       	movw	r24, r0
    1ac2:	25 9f       	mul	r18, r21
    1ac4:	90 0d       	add	r25, r0
    1ac6:	34 9f       	mul	r19, r20
    1ac8:	90 0d       	add	r25, r0
    1aca:	11 24       	eor	r1, r1
    1acc:	9c 83       	std	Y+4, r25	; 0x04
    1ace:	8b 83       	std	Y+3, r24	; 0x03
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad4:	4f 96       	adiw	r24, 0x1f	; 31
    1ad6:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    1ada:	9e 83       	std	Y+6, r25	; 0x06
    1adc:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1ade:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae2:	00 97       	sbiw	r24, 0x00	; 0
    1ae4:	81 f0       	breq	.+32     	; 0x1b06 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    1ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    1aea:	4f 96       	adiw	r24, 0x1f	; 31
    1aec:	9a 83       	std	Y+2, r25	; 0x02
    1aee:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1af0:	29 81       	ldd	r18, Y+1	; 0x01
    1af2:	3a 81       	ldd	r19, Y+2	; 0x02
    1af4:	ed 81       	ldd	r30, Y+5	; 0x05
    1af6:	fe 81       	ldd	r31, Y+6	; 0x06
    1af8:	8f 81       	ldd	r24, Y+7	; 0x07
    1afa:	68 85       	ldd	r22, Y+8	; 0x08
    1afc:	a9 01       	movw	r20, r18
    1afe:	29 85       	ldd	r18, Y+9	; 0x09
    1b00:	8f 01       	movw	r16, r30
    1b02:	0e 94 90 0d 	call	0x1b20	; 0x1b20 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
    1b06:	8d 81       	ldd	r24, Y+5	; 0x05
    1b08:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1b0a:	29 96       	adiw	r28, 0x09	; 9
    1b0c:	0f b6       	in	r0, 0x3f	; 63
    1b0e:	f8 94       	cli
    1b10:	de bf       	out	0x3e, r29	; 62
    1b12:	0f be       	out	0x3f, r0	; 63
    1b14:	cd bf       	out	0x3d, r28	; 61
    1b16:	cf 91       	pop	r28
    1b18:	df 91       	pop	r29
    1b1a:	1f 91       	pop	r17
    1b1c:	0f 91       	pop	r16
    1b1e:	08 95       	ret

00001b20 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1b20:	0f 93       	push	r16
    1b22:	1f 93       	push	r17
    1b24:	df 93       	push	r29
    1b26:	cf 93       	push	r28
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
    1b2c:	27 97       	sbiw	r28, 0x07	; 7
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	de bf       	out	0x3e, r29	; 62
    1b34:	0f be       	out	0x3f, r0	; 63
    1b36:	cd bf       	out	0x3d, r28	; 61
    1b38:	89 83       	std	Y+1, r24	; 0x01
    1b3a:	6a 83       	std	Y+2, r22	; 0x02
    1b3c:	5c 83       	std	Y+4, r21	; 0x04
    1b3e:	4b 83       	std	Y+3, r20	; 0x03
    1b40:	2d 83       	std	Y+5, r18	; 0x05
    1b42:	1f 83       	std	Y+7, r17	; 0x07
    1b44:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1b46:	8a 81       	ldd	r24, Y+2	; 0x02
    1b48:	88 23       	and	r24, r24
    1b4a:	39 f4       	brne	.+14     	; 0x1b5a <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1b4c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b4e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b50:	ee 81       	ldd	r30, Y+6	; 0x06
    1b52:	ff 81       	ldd	r31, Y+7	; 0x07
    1b54:	91 83       	std	Z+1, r25	; 0x01
    1b56:	80 83       	st	Z, r24
    1b58:	06 c0       	rjmp	.+12     	; 0x1b66 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5e:	ee 81       	ldd	r30, Y+6	; 0x06
    1b60:	ff 81       	ldd	r31, Y+7	; 0x07
    1b62:	91 83       	std	Z+1, r25	; 0x01
    1b64:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1b66:	ee 81       	ldd	r30, Y+6	; 0x06
    1b68:	ff 81       	ldd	r31, Y+7	; 0x07
    1b6a:	89 81       	ldd	r24, Y+1	; 0x01
    1b6c:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1b6e:	ee 81       	ldd	r30, Y+6	; 0x06
    1b70:	ff 81       	ldd	r31, Y+7	; 0x07
    1b72:	8a 81       	ldd	r24, Y+2	; 0x02
    1b74:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1b76:	8e 81       	ldd	r24, Y+6	; 0x06
    1b78:	9f 81       	ldd	r25, Y+7	; 0x07
    1b7a:	61 e0       	ldi	r22, 0x01	; 1
    1b7c:	0e 94 bd 0c 	call	0x197a	; 0x197a <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1b80:	27 96       	adiw	r28, 0x07	; 7
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	de bf       	out	0x3e, r29	; 62
    1b88:	0f be       	out	0x3f, r0	; 63
    1b8a:	cd bf       	out	0x3d, r28	; 61
    1b8c:	cf 91       	pop	r28
    1b8e:	df 91       	pop	r29
    1b90:	1f 91       	pop	r17
    1b92:	0f 91       	pop	r16
    1b94:	08 95       	ret

00001b96 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    1b96:	df 93       	push	r29
    1b98:	cf 93       	push	r28
    1b9a:	00 d0       	rcall	.+0      	; 0x1b9c <prvInitialiseMutex+0x6>
    1b9c:	cd b7       	in	r28, 0x3d	; 61
    1b9e:	de b7       	in	r29, 0x3e	; 62
    1ba0:	9a 83       	std	Y+2, r25	; 0x02
    1ba2:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba8:	00 97       	sbiw	r24, 0x00	; 0
    1baa:	a1 f0       	breq	.+40     	; 0x1bd4 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1bac:	e9 81       	ldd	r30, Y+1	; 0x01
    1bae:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb0:	13 82       	std	Z+3, r1	; 0x03
    1bb2:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb8:	11 82       	std	Z+1, r1	; 0x01
    1bba:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1bbc:	e9 81       	ldd	r30, Y+1	; 0x01
    1bbe:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc0:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1bc2:	89 81       	ldd	r24, Y+1	; 0x01
    1bc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc6:	60 e0       	ldi	r22, 0x00	; 0
    1bc8:	70 e0       	ldi	r23, 0x00	; 0
    1bca:	40 e0       	ldi	r20, 0x00	; 0
    1bcc:	50 e0       	ldi	r21, 0x00	; 0
    1bce:	20 e0       	ldi	r18, 0x00	; 0
    1bd0:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    1bd4:	0f 90       	pop	r0
    1bd6:	0f 90       	pop	r0
    1bd8:	cf 91       	pop	r28
    1bda:	df 91       	pop	r29
    1bdc:	08 95       	ret

00001bde <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1bde:	df 93       	push	r29
    1be0:	cf 93       	push	r28
    1be2:	00 d0       	rcall	.+0      	; 0x1be4 <xQueueCreateMutex+0x6>
    1be4:	00 d0       	rcall	.+0      	; 0x1be6 <xQueueCreateMutex+0x8>
    1be6:	0f 92       	push	r0
    1be8:	cd b7       	in	r28, 0x3d	; 61
    1bea:	de b7       	in	r29, 0x3e	; 62
    1bec:	8d 83       	std	Y+5, r24	; 0x05
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	8a 83       	std	Y+2, r24	; 0x02
    1bf2:	19 82       	std	Y+1, r1	; 0x01

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf6:	69 81       	ldd	r22, Y+1	; 0x01
    1bf8:	4d 81       	ldd	r20, Y+5	; 0x05
    1bfa:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <xQueueGenericCreate>
    1bfe:	9c 83       	std	Y+4, r25	; 0x04
    1c00:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( pxNewQueue );
    1c02:	8b 81       	ldd	r24, Y+3	; 0x03
    1c04:	9c 81       	ldd	r25, Y+4	; 0x04
    1c06:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <prvInitialiseMutex>

		return pxNewQueue;
    1c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0c:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    1c0e:	0f 90       	pop	r0
    1c10:	0f 90       	pop	r0
    1c12:	0f 90       	pop	r0
    1c14:	0f 90       	pop	r0
    1c16:	0f 90       	pop	r0
    1c18:	cf 91       	pop	r28
    1c1a:	df 91       	pop	r29
    1c1c:	08 95       	ret

00001c1e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1c1e:	df 93       	push	r29
    1c20:	cf 93       	push	r28
    1c22:	cd b7       	in	r28, 0x3d	; 61
    1c24:	de b7       	in	r29, 0x3e	; 62
    1c26:	2f 97       	sbiw	r28, 0x0f	; 15
    1c28:	0f b6       	in	r0, 0x3f	; 63
    1c2a:	f8 94       	cli
    1c2c:	de bf       	out	0x3e, r29	; 62
    1c2e:	0f be       	out	0x3f, r0	; 63
    1c30:	cd bf       	out	0x3d, r28	; 61
    1c32:	99 87       	std	Y+9, r25	; 0x09
    1c34:	88 87       	std	Y+8, r24	; 0x08
    1c36:	7b 87       	std	Y+11, r23	; 0x0b
    1c38:	6a 87       	std	Y+10, r22	; 0x0a
    1c3a:	5d 87       	std	Y+13, r21	; 0x0d
    1c3c:	4c 87       	std	Y+12, r20	; 0x0c
    1c3e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1c40:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1c42:	88 85       	ldd	r24, Y+8	; 0x08
    1c44:	99 85       	ldd	r25, Y+9	; 0x09
    1c46:	9a 83       	std	Y+2, r25	; 0x02
    1c48:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c56:	e9 81       	ldd	r30, Y+1	; 0x01
    1c58:	fa 81       	ldd	r31, Y+2	; 0x02
    1c5a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c5c:	98 17       	cp	r25, r24
    1c5e:	18 f0       	brcs	.+6      	; 0x1c66 <xQueueGenericSend+0x48>
    1c60:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c62:	82 30       	cpi	r24, 0x02	; 2
    1c64:	11 f5       	brne	.+68     	; 0x1caa <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c66:	89 81       	ldd	r24, Y+1	; 0x01
    1c68:	9a 81       	ldd	r25, Y+2	; 0x02
    1c6a:	2a 85       	ldd	r18, Y+10	; 0x0a
    1c6c:	3b 85       	ldd	r19, Y+11	; 0x0b
    1c6e:	b9 01       	movw	r22, r18
    1c70:	4e 85       	ldd	r20, Y+14	; 0x0e
    1c72:	0e 94 43 11 	call	0x2286	; 0x2286 <prvCopyDataToQueue>
    1c76:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c78:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7c:	81 89       	ldd	r24, Z+17	; 0x11
    1c7e:	88 23       	and	r24, r24
    1c80:	51 f0       	breq	.+20     	; 0x1c96 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	9a 81       	ldd	r25, Y+2	; 0x02
    1c86:	41 96       	adiw	r24, 0x11	; 17
    1c88:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    1c8c:	88 23       	and	r24, r24
    1c8e:	41 f0       	breq	.+16     	; 0x1ca0 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1c90:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
    1c94:	05 c0       	rjmp	.+10     	; 0x1ca0 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1c96:	8b 81       	ldd	r24, Y+3	; 0x03
    1c98:	88 23       	and	r24, r24
    1c9a:	11 f0       	breq	.+4      	; 0x1ca0 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1c9c:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	8f 87       	std	Y+15, r24	; 0x0f
    1ca8:	5c c0       	rjmp	.+184    	; 0x1d62 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1caa:	8c 85       	ldd	r24, Y+12	; 0x0c
    1cac:	9d 85       	ldd	r25, Y+13	; 0x0d
    1cae:	00 97       	sbiw	r24, 0x00	; 0
    1cb0:	21 f4       	brne	.+8      	; 0x1cba <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1cb2:	0f 90       	pop	r0
    1cb4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1cb6:	1f 86       	std	Y+15, r1	; 0x0f
    1cb8:	54 c0       	rjmp	.+168    	; 0x1d62 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1cba:	8c 81       	ldd	r24, Y+4	; 0x04
    1cbc:	88 23       	and	r24, r24
    1cbe:	31 f4       	brne	.+12     	; 0x1ccc <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1cc0:	ce 01       	movw	r24, r28
    1cc2:	05 96       	adiw	r24, 0x05	; 5
    1cc4:	0e 94 93 1b 	call	0x3726	; 0x3726 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1ccc:	0f 90       	pop	r0
    1cce:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1cd0:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	0f 92       	push	r0
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ce0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce2:	19 f4       	brne	.+6      	; 0x1cea <xQueueGenericSend+0xcc>
    1ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce8:	15 8e       	std	Z+29, r1	; 0x1d
    1cea:	e9 81       	ldd	r30, Y+1	; 0x01
    1cec:	fa 81       	ldd	r31, Y+2	; 0x02
    1cee:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cf0:	8f 3f       	cpi	r24, 0xFF	; 255
    1cf2:	19 f4       	brne	.+6      	; 0x1cfa <xQueueGenericSend+0xdc>
    1cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf8:	16 8e       	std	Z+30, r1	; 0x1e
    1cfa:	0f 90       	pop	r0
    1cfc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cfe:	ce 01       	movw	r24, r28
    1d00:	05 96       	adiw	r24, 0x05	; 5
    1d02:	9e 01       	movw	r18, r28
    1d04:	24 5f       	subi	r18, 0xF4	; 244
    1d06:	3f 4f       	sbci	r19, 0xFF	; 255
    1d08:	b9 01       	movw	r22, r18
    1d0a:	0e 94 ac 1b 	call	0x3758	; 0x3758 <xTaskCheckForTimeOut>
    1d0e:	88 23       	and	r24, r24
    1d10:	09 f5       	brne	.+66     	; 0x1d54 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	9a 81       	ldd	r25, Y+2	; 0x02
    1d16:	0e 94 ca 12 	call	0x2594	; 0x2594 <prvIsQueueFull>
    1d1a:	88 23       	and	r24, r24
    1d1c:	a1 f0       	breq	.+40     	; 0x1d46 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d1e:	89 81       	ldd	r24, Y+1	; 0x01
    1d20:	9a 81       	ldd	r25, Y+2	; 0x02
    1d22:	08 96       	adiw	r24, 0x08	; 8
    1d24:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d26:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d28:	b9 01       	movw	r22, r18
    1d2a:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d2e:	89 81       	ldd	r24, Y+1	; 0x01
    1d30:	9a 81       	ldd	r25, Y+2	; 0x02
    1d32:	0e 94 42 12 	call	0x2484	; 0x2484 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d36:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
    1d3a:	88 23       	and	r24, r24
    1d3c:	09 f0       	breq	.+2      	; 0x1d40 <xQueueGenericSend+0x122>
    1d3e:	85 cf       	rjmp	.-246    	; 0x1c4a <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1d40:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
    1d44:	82 cf       	rjmp	.-252    	; 0x1c4a <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d46:	89 81       	ldd	r24, Y+1	; 0x01
    1d48:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4a:	0e 94 42 12 	call	0x2484	; 0x2484 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d4e:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
    1d52:	7b cf       	rjmp	.-266    	; 0x1c4a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	9a 81       	ldd	r25, Y+2	; 0x02
    1d58:	0e 94 42 12 	call	0x2484	; 0x2484 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d5c:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d60:	1f 86       	std	Y+15, r1	; 0x0f
    1d62:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    1d64:	2f 96       	adiw	r28, 0x0f	; 15
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	f8 94       	cli
    1d6a:	de bf       	out	0x3e, r29	; 62
    1d6c:	0f be       	out	0x3f, r0	; 63
    1d6e:	cd bf       	out	0x3d, r28	; 61
    1d70:	cf 91       	pop	r28
    1d72:	df 91       	pop	r29
    1d74:	08 95       	ret

00001d76 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1d76:	df 93       	push	r29
    1d78:	cf 93       	push	r28
    1d7a:	cd b7       	in	r28, 0x3d	; 61
    1d7c:	de b7       	in	r29, 0x3e	; 62
    1d7e:	2c 97       	sbiw	r28, 0x0c	; 12
    1d80:	0f b6       	in	r0, 0x3f	; 63
    1d82:	f8 94       	cli
    1d84:	de bf       	out	0x3e, r29	; 62
    1d86:	0f be       	out	0x3f, r0	; 63
    1d88:	cd bf       	out	0x3d, r28	; 61
    1d8a:	9f 83       	std	Y+7, r25	; 0x07
    1d8c:	8e 83       	std	Y+6, r24	; 0x06
    1d8e:	79 87       	std	Y+9, r23	; 0x09
    1d90:	68 87       	std	Y+8, r22	; 0x08
    1d92:	5b 87       	std	Y+11, r21	; 0x0b
    1d94:	4a 87       	std	Y+10, r20	; 0x0a
    1d96:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d98:	8e 81       	ldd	r24, Y+6	; 0x06
    1d9a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d9c:	9b 83       	std	Y+3, r25	; 0x03
    1d9e:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1da0:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1da2:	ea 81       	ldd	r30, Y+2	; 0x02
    1da4:	fb 81       	ldd	r31, Y+3	; 0x03
    1da6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1da8:	ea 81       	ldd	r30, Y+2	; 0x02
    1daa:	fb 81       	ldd	r31, Y+3	; 0x03
    1dac:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dae:	98 17       	cp	r25, r24
    1db0:	18 f0       	brcs	.+6      	; 0x1db8 <xQueueGenericSendFromISR+0x42>
    1db2:	8c 85       	ldd	r24, Y+12	; 0x0c
    1db4:	82 30       	cpi	r24, 0x02	; 2
    1db6:	61 f5       	brne	.+88     	; 0x1e10 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1db8:	ea 81       	ldd	r30, Y+2	; 0x02
    1dba:	fb 81       	ldd	r31, Y+3	; 0x03
    1dbc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dbe:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc2:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc4:	28 85       	ldd	r18, Y+8	; 0x08
    1dc6:	39 85       	ldd	r19, Y+9	; 0x09
    1dc8:	b9 01       	movw	r22, r18
    1dca:	4c 85       	ldd	r20, Y+12	; 0x0c
    1dcc:	0e 94 43 11 	call	0x2286	; 0x2286 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1dd0:	89 81       	ldd	r24, Y+1	; 0x01
    1dd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1dd4:	a9 f4       	brne	.+42     	; 0x1e00 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1dd6:	ea 81       	ldd	r30, Y+2	; 0x02
    1dd8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dda:	81 89       	ldd	r24, Z+17	; 0x11
    1ddc:	88 23       	and	r24, r24
    1dde:	a9 f0       	breq	.+42     	; 0x1e0a <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1de0:	8a 81       	ldd	r24, Y+2	; 0x02
    1de2:	9b 81       	ldd	r25, Y+3	; 0x03
    1de4:	41 96       	adiw	r24, 0x11	; 17
    1de6:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    1dea:	88 23       	and	r24, r24
    1dec:	71 f0       	breq	.+28     	; 0x1e0a <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1dee:	8a 85       	ldd	r24, Y+10	; 0x0a
    1df0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1df2:	00 97       	sbiw	r24, 0x00	; 0
    1df4:	51 f0       	breq	.+20     	; 0x1e0a <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1df6:	ea 85       	ldd	r30, Y+10	; 0x0a
    1df8:	fb 85       	ldd	r31, Y+11	; 0x0b
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	80 83       	st	Z, r24
    1dfe:	05 c0       	rjmp	.+10     	; 0x1e0a <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1e00:	89 81       	ldd	r24, Y+1	; 0x01
    1e02:	8f 5f       	subi	r24, 0xFF	; 255
    1e04:	ea 81       	ldd	r30, Y+2	; 0x02
    1e06:	fb 81       	ldd	r31, Y+3	; 0x03
    1e08:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e0a:	81 e0       	ldi	r24, 0x01	; 1
    1e0c:	8d 83       	std	Y+5, r24	; 0x05
    1e0e:	01 c0       	rjmp	.+2      	; 0x1e12 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e10:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e12:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1e14:	2c 96       	adiw	r28, 0x0c	; 12
    1e16:	0f b6       	in	r0, 0x3f	; 63
    1e18:	f8 94       	cli
    1e1a:	de bf       	out	0x3e, r29	; 62
    1e1c:	0f be       	out	0x3f, r0	; 63
    1e1e:	cd bf       	out	0x3d, r28	; 61
    1e20:	cf 91       	pop	r28
    1e22:	df 91       	pop	r29
    1e24:	08 95       	ret

00001e26 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1e26:	df 93       	push	r29
    1e28:	cf 93       	push	r28
    1e2a:	cd b7       	in	r28, 0x3d	; 61
    1e2c:	de b7       	in	r29, 0x3e	; 62
    1e2e:	2a 97       	sbiw	r28, 0x0a	; 10
    1e30:	0f b6       	in	r0, 0x3f	; 63
    1e32:	f8 94       	cli
    1e34:	de bf       	out	0x3e, r29	; 62
    1e36:	0f be       	out	0x3f, r0	; 63
    1e38:	cd bf       	out	0x3d, r28	; 61
    1e3a:	98 87       	std	Y+8, r25	; 0x08
    1e3c:	8f 83       	std	Y+7, r24	; 0x07
    1e3e:	7a 87       	std	Y+10, r23	; 0x0a
    1e40:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1e42:	8f 81       	ldd	r24, Y+7	; 0x07
    1e44:	98 85       	ldd	r25, Y+8	; 0x08
    1e46:	9c 83       	std	Y+4, r25	; 0x04
    1e48:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e4a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e50:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e52:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1e54:	eb 81       	ldd	r30, Y+3	; 0x03
    1e56:	fc 81       	ldd	r31, Y+4	; 0x04
    1e58:	93 8d       	ldd	r25, Z+27	; 0x1b
    1e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e5c:	89 17       	cp	r24, r25
    1e5e:	48 f5       	brcc	.+82     	; 0x1eb2 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1e60:	eb 81       	ldd	r30, Y+3	; 0x03
    1e62:	fc 81       	ldd	r31, Y+4	; 0x04
    1e64:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e66:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1e68:	8a 81       	ldd	r24, Y+2	; 0x02
    1e6a:	8f 5f       	subi	r24, 0xFF	; 255
    1e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e70:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1e72:	89 81       	ldd	r24, Y+1	; 0x01
    1e74:	8f 3f       	cpi	r24, 0xFF	; 255
    1e76:	a9 f4       	brne	.+42     	; 0x1ea2 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e78:	eb 81       	ldd	r30, Y+3	; 0x03
    1e7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e7c:	81 89       	ldd	r24, Z+17	; 0x11
    1e7e:	88 23       	and	r24, r24
    1e80:	a9 f0       	breq	.+42     	; 0x1eac <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e82:	8b 81       	ldd	r24, Y+3	; 0x03
    1e84:	9c 81       	ldd	r25, Y+4	; 0x04
    1e86:	41 96       	adiw	r24, 0x11	; 17
    1e88:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    1e8c:	88 23       	and	r24, r24
    1e8e:	71 f0       	breq	.+28     	; 0x1eac <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1e90:	89 85       	ldd	r24, Y+9	; 0x09
    1e92:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e94:	00 97       	sbiw	r24, 0x00	; 0
    1e96:	51 f0       	breq	.+20     	; 0x1eac <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1e98:	e9 85       	ldd	r30, Y+9	; 0x09
    1e9a:	fa 85       	ldd	r31, Y+10	; 0x0a
    1e9c:	81 e0       	ldi	r24, 0x01	; 1
    1e9e:	80 83       	st	Z, r24
    1ea0:	05 c0       	rjmp	.+10     	; 0x1eac <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	8f 5f       	subi	r24, 0xFF	; 255
    1ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eaa:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	8e 83       	std	Y+6, r24	; 0x06
    1eb0:	01 c0       	rjmp	.+2      	; 0x1eb4 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1eb2:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1eb4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1eb6:	2a 96       	adiw	r28, 0x0a	; 10
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	de bf       	out	0x3e, r29	; 62
    1ebe:	0f be       	out	0x3f, r0	; 63
    1ec0:	cd bf       	out	0x3d, r28	; 61
    1ec2:	cf 91       	pop	r28
    1ec4:	df 91       	pop	r29
    1ec6:	08 95       	ret

00001ec8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1ec8:	df 93       	push	r29
    1eca:	cf 93       	push	r28
    1ecc:	cd b7       	in	r28, 0x3d	; 61
    1ece:	de b7       	in	r29, 0x3e	; 62
    1ed0:	61 97       	sbiw	r28, 0x11	; 17
    1ed2:	0f b6       	in	r0, 0x3f	; 63
    1ed4:	f8 94       	cli
    1ed6:	de bf       	out	0x3e, r29	; 62
    1ed8:	0f be       	out	0x3f, r0	; 63
    1eda:	cd bf       	out	0x3d, r28	; 61
    1edc:	9b 87       	std	Y+11, r25	; 0x0b
    1ede:	8a 87       	std	Y+10, r24	; 0x0a
    1ee0:	7d 87       	std	Y+13, r23	; 0x0d
    1ee2:	6c 87       	std	Y+12, r22	; 0x0c
    1ee4:	5f 87       	std	Y+15, r21	; 0x0f
    1ee6:	4e 87       	std	Y+14, r20	; 0x0e
    1ee8:	28 8b       	std	Y+16, r18	; 0x10
BaseType_t xEntryTimeSet = pdFALSE;
    1eea:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1eec:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eee:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ef0:	9b 83       	std	Y+3, r25	; 0x03
    1ef2:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ef4:	0f b6       	in	r0, 0x3f	; 63
    1ef6:	f8 94       	cli
    1ef8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1efa:	ea 81       	ldd	r30, Y+2	; 0x02
    1efc:	fb 81       	ldd	r31, Y+3	; 0x03
    1efe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f00:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f02:	89 81       	ldd	r24, Y+1	; 0x01
    1f04:	88 23       	and	r24, r24
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <xQueueGenericReceive+0x42>
    1f08:	49 c0       	rjmp	.+146    	; 0x1f9c <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1f0a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f0c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f0e:	86 81       	ldd	r24, Z+6	; 0x06
    1f10:	97 81       	ldd	r25, Z+7	; 0x07
    1f12:	9d 83       	std	Y+5, r25	; 0x05
    1f14:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f16:	8a 81       	ldd	r24, Y+2	; 0x02
    1f18:	9b 81       	ldd	r25, Y+3	; 0x03
    1f1a:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f1c:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f1e:	b9 01       	movw	r22, r18
    1f20:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1f24:	88 89       	ldd	r24, Y+16	; 0x10
    1f26:	88 23       	and	r24, r24
    1f28:	01 f5       	brne	.+64     	; 0x1f6a <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1f2a:	89 81       	ldd	r24, Y+1	; 0x01
    1f2c:	81 50       	subi	r24, 0x01	; 1
    1f2e:	ea 81       	ldd	r30, Y+2	; 0x02
    1f30:	fb 81       	ldd	r31, Y+3	; 0x03
    1f32:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f34:	ea 81       	ldd	r30, Y+2	; 0x02
    1f36:	fb 81       	ldd	r31, Y+3	; 0x03
    1f38:	80 81       	ld	r24, Z
    1f3a:	91 81       	ldd	r25, Z+1	; 0x01
    1f3c:	00 97       	sbiw	r24, 0x00	; 0
    1f3e:	31 f4       	brne	.+12     	; 0x1f4c <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1f40:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <pvTaskIncrementMutexHeldCount>
    1f44:	ea 81       	ldd	r30, Y+2	; 0x02
    1f46:	fb 81       	ldd	r31, Y+3	; 0x03
    1f48:	93 83       	std	Z+3, r25	; 0x03
    1f4a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f4c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f4e:	fb 81       	ldd	r31, Y+3	; 0x03
    1f50:	80 85       	ldd	r24, Z+8	; 0x08
    1f52:	88 23       	and	r24, r24
    1f54:	f1 f0       	breq	.+60     	; 0x1f92 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f56:	8a 81       	ldd	r24, Y+2	; 0x02
    1f58:	9b 81       	ldd	r25, Y+3	; 0x03
    1f5a:	08 96       	adiw	r24, 0x08	; 8
    1f5c:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    1f60:	88 23       	and	r24, r24
    1f62:	b9 f0       	breq	.+46     	; 0x1f92 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1f64:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
    1f68:	14 c0       	rjmp	.+40     	; 0x1f92 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1f6a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f6c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f6e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f70:	9d 81       	ldd	r25, Y+5	; 0x05
    1f72:	97 83       	std	Z+7, r25	; 0x07
    1f74:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f76:	ea 81       	ldd	r30, Y+2	; 0x02
    1f78:	fb 81       	ldd	r31, Y+3	; 0x03
    1f7a:	81 89       	ldd	r24, Z+17	; 0x11
    1f7c:	88 23       	and	r24, r24
    1f7e:	49 f0       	breq	.+18     	; 0x1f92 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f80:	8a 81       	ldd	r24, Y+2	; 0x02
    1f82:	9b 81       	ldd	r25, Y+3	; 0x03
    1f84:	41 96       	adiw	r24, 0x11	; 17
    1f86:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    1f8a:	88 23       	and	r24, r24
    1f8c:	11 f0       	breq	.+4      	; 0x1f92 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1f8e:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1f92:	0f 90       	pop	r0
    1f94:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f96:	81 e0       	ldi	r24, 0x01	; 1
    1f98:	89 8b       	std	Y+17, r24	; 0x11
    1f9a:	74 c0       	rjmp	.+232    	; 0x2084 <xQueueGenericReceive+0x1bc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f9c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f9e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1fa0:	00 97       	sbiw	r24, 0x00	; 0
    1fa2:	21 f4       	brne	.+8      	; 0x1fac <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1fa4:	0f 90       	pop	r0
    1fa6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1fa8:	19 8a       	std	Y+17, r1	; 0x11
    1faa:	6c c0       	rjmp	.+216    	; 0x2084 <xQueueGenericReceive+0x1bc>
				}
				else if( xEntryTimeSet == pdFALSE )
    1fac:	8e 81       	ldd	r24, Y+6	; 0x06
    1fae:	88 23       	and	r24, r24
    1fb0:	31 f4       	brne	.+12     	; 0x1fbe <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1fb2:	ce 01       	movw	r24, r28
    1fb4:	07 96       	adiw	r24, 0x07	; 7
    1fb6:	0e 94 93 1b 	call	0x3726	; 0x3726 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1fba:	81 e0       	ldi	r24, 0x01	; 1
    1fbc:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fbe:	0f 90       	pop	r0
    1fc0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fc2:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	0f 92       	push	r0
    1fcc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fce:	fb 81       	ldd	r31, Y+3	; 0x03
    1fd0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fd4:	19 f4       	brne	.+6      	; 0x1fdc <xQueueGenericReceive+0x114>
    1fd6:	ea 81       	ldd	r30, Y+2	; 0x02
    1fd8:	fb 81       	ldd	r31, Y+3	; 0x03
    1fda:	15 8e       	std	Z+29, r1	; 0x1d
    1fdc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fde:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fe2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fe4:	19 f4       	brne	.+6      	; 0x1fec <xQueueGenericReceive+0x124>
    1fe6:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe8:	fb 81       	ldd	r31, Y+3	; 0x03
    1fea:	16 8e       	std	Z+30, r1	; 0x1e
    1fec:	0f 90       	pop	r0
    1fee:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ff0:	ce 01       	movw	r24, r28
    1ff2:	07 96       	adiw	r24, 0x07	; 7
    1ff4:	9e 01       	movw	r18, r28
    1ff6:	22 5f       	subi	r18, 0xF2	; 242
    1ff8:	3f 4f       	sbci	r19, 0xFF	; 255
    1ffa:	b9 01       	movw	r22, r18
    1ffc:	0e 94 ac 1b 	call	0x3758	; 0x3758 <xTaskCheckForTimeOut>
    2000:	88 23       	and	r24, r24
    2002:	91 f5       	brne	.+100    	; 0x2068 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2004:	8a 81       	ldd	r24, Y+2	; 0x02
    2006:	9b 81       	ldd	r25, Y+3	; 0x03
    2008:	0e 94 95 12 	call	0x252a	; 0x252a <prvIsQueueEmpty>
    200c:	88 23       	and	r24, r24
    200e:	29 f1       	breq	.+74     	; 0x205a <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2010:	ea 81       	ldd	r30, Y+2	; 0x02
    2012:	fb 81       	ldd	r31, Y+3	; 0x03
    2014:	80 81       	ld	r24, Z
    2016:	91 81       	ldd	r25, Z+1	; 0x01
    2018:	00 97       	sbiw	r24, 0x00	; 0
    201a:	59 f4       	brne	.+22     	; 0x2032 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    201c:	0f b6       	in	r0, 0x3f	; 63
    201e:	f8 94       	cli
    2020:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2022:	ea 81       	ldd	r30, Y+2	; 0x02
    2024:	fb 81       	ldd	r31, Y+3	; 0x03
    2026:	82 81       	ldd	r24, Z+2	; 0x02
    2028:	93 81       	ldd	r25, Z+3	; 0x03
    202a:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2032:	8a 81       	ldd	r24, Y+2	; 0x02
    2034:	9b 81       	ldd	r25, Y+3	; 0x03
    2036:	41 96       	adiw	r24, 0x11	; 17
    2038:	2e 85       	ldd	r18, Y+14	; 0x0e
    203a:	3f 85       	ldd	r19, Y+15	; 0x0f
    203c:	b9 01       	movw	r22, r18
    203e:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2042:	8a 81       	ldd	r24, Y+2	; 0x02
    2044:	9b 81       	ldd	r25, Y+3	; 0x03
    2046:	0e 94 42 12 	call	0x2484	; 0x2484 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    204a:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
    204e:	88 23       	and	r24, r24
    2050:	09 f0       	breq	.+2      	; 0x2054 <xQueueGenericReceive+0x18c>
    2052:	50 cf       	rjmp	.-352    	; 0x1ef4 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    2054:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
    2058:	4d cf       	rjmp	.-358    	; 0x1ef4 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    205a:	8a 81       	ldd	r24, Y+2	; 0x02
    205c:	9b 81       	ldd	r25, Y+3	; 0x03
    205e:	0e 94 42 12 	call	0x2484	; 0x2484 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2062:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
    2066:	46 cf       	rjmp	.-372    	; 0x1ef4 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2068:	8a 81       	ldd	r24, Y+2	; 0x02
    206a:	9b 81       	ldd	r25, Y+3	; 0x03
    206c:	0e 94 42 12 	call	0x2484	; 0x2484 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2070:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2074:	8a 81       	ldd	r24, Y+2	; 0x02
    2076:	9b 81       	ldd	r25, Y+3	; 0x03
    2078:	0e 94 95 12 	call	0x252a	; 0x252a <prvIsQueueEmpty>
    207c:	88 23       	and	r24, r24
    207e:	09 f4       	brne	.+2      	; 0x2082 <xQueueGenericReceive+0x1ba>
    2080:	39 cf       	rjmp	.-398    	; 0x1ef4 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2082:	19 8a       	std	Y+17, r1	; 0x11
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2084:	89 89       	ldd	r24, Y+17	; 0x11
}
    2086:	61 96       	adiw	r28, 0x11	; 17
    2088:	0f b6       	in	r0, 0x3f	; 63
    208a:	f8 94       	cli
    208c:	de bf       	out	0x3e, r29	; 62
    208e:	0f be       	out	0x3f, r0	; 63
    2090:	cd bf       	out	0x3d, r28	; 61
    2092:	cf 91       	pop	r28
    2094:	df 91       	pop	r29
    2096:	08 95       	ret

00002098 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2098:	df 93       	push	r29
    209a:	cf 93       	push	r28
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
    20a0:	2c 97       	sbiw	r28, 0x0c	; 12
    20a2:	0f b6       	in	r0, 0x3f	; 63
    20a4:	f8 94       	cli
    20a6:	de bf       	out	0x3e, r29	; 62
    20a8:	0f be       	out	0x3f, r0	; 63
    20aa:	cd bf       	out	0x3d, r28	; 61
    20ac:	98 87       	std	Y+8, r25	; 0x08
    20ae:	8f 83       	std	Y+7, r24	; 0x07
    20b0:	7a 87       	std	Y+10, r23	; 0x0a
    20b2:	69 87       	std	Y+9, r22	; 0x09
    20b4:	5c 87       	std	Y+12, r21	; 0x0c
    20b6:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    20b8:	8f 81       	ldd	r24, Y+7	; 0x07
    20ba:	98 85       	ldd	r25, Y+8	; 0x08
    20bc:	9c 83       	std	Y+4, r25	; 0x04
    20be:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    20c0:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    20c2:	eb 81       	ldd	r30, Y+3	; 0x03
    20c4:	fc 81       	ldd	r31, Y+4	; 0x04
    20c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    20c8:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    20ca:	8a 81       	ldd	r24, Y+2	; 0x02
    20cc:	88 23       	and	r24, r24
    20ce:	81 f1       	breq	.+96     	; 0x2130 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    20d0:	eb 81       	ldd	r30, Y+3	; 0x03
    20d2:	fc 81       	ldd	r31, Y+4	; 0x04
    20d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    20d6:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    20d8:	8b 81       	ldd	r24, Y+3	; 0x03
    20da:	9c 81       	ldd	r25, Y+4	; 0x04
    20dc:	29 85       	ldd	r18, Y+9	; 0x09
    20de:	3a 85       	ldd	r19, Y+10	; 0x0a
    20e0:	b9 01       	movw	r22, r18
    20e2:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    20e6:	8a 81       	ldd	r24, Y+2	; 0x02
    20e8:	81 50       	subi	r24, 0x01	; 1
    20ea:	eb 81       	ldd	r30, Y+3	; 0x03
    20ec:	fc 81       	ldd	r31, Y+4	; 0x04
    20ee:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    20f0:	89 81       	ldd	r24, Y+1	; 0x01
    20f2:	8f 3f       	cpi	r24, 0xFF	; 255
    20f4:	a9 f4       	brne	.+42     	; 0x2120 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20f6:	eb 81       	ldd	r30, Y+3	; 0x03
    20f8:	fc 81       	ldd	r31, Y+4	; 0x04
    20fa:	80 85       	ldd	r24, Z+8	; 0x08
    20fc:	88 23       	and	r24, r24
    20fe:	a9 f0       	breq	.+42     	; 0x212a <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2100:	8b 81       	ldd	r24, Y+3	; 0x03
    2102:	9c 81       	ldd	r25, Y+4	; 0x04
    2104:	08 96       	adiw	r24, 0x08	; 8
    2106:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    210a:	88 23       	and	r24, r24
    210c:	71 f0       	breq	.+28     	; 0x212a <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    210e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2110:	9c 85       	ldd	r25, Y+12	; 0x0c
    2112:	00 97       	sbiw	r24, 0x00	; 0
    2114:	51 f0       	breq	.+20     	; 0x212a <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2116:	eb 85       	ldd	r30, Y+11	; 0x0b
    2118:	fc 85       	ldd	r31, Y+12	; 0x0c
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	80 83       	st	Z, r24
    211e:	05 c0       	rjmp	.+10     	; 0x212a <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2120:	89 81       	ldd	r24, Y+1	; 0x01
    2122:	8f 5f       	subi	r24, 0xFF	; 255
    2124:	eb 81       	ldd	r30, Y+3	; 0x03
    2126:	fc 81       	ldd	r31, Y+4	; 0x04
    2128:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    212a:	81 e0       	ldi	r24, 0x01	; 1
    212c:	8e 83       	std	Y+6, r24	; 0x06
    212e:	01 c0       	rjmp	.+2      	; 0x2132 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2130:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2132:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2134:	2c 96       	adiw	r28, 0x0c	; 12
    2136:	0f b6       	in	r0, 0x3f	; 63
    2138:	f8 94       	cli
    213a:	de bf       	out	0x3e, r29	; 62
    213c:	0f be       	out	0x3f, r0	; 63
    213e:	cd bf       	out	0x3d, r28	; 61
    2140:	cf 91       	pop	r28
    2142:	df 91       	pop	r29
    2144:	08 95       	ret

00002146 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2146:	df 93       	push	r29
    2148:	cf 93       	push	r28
    214a:	cd b7       	in	r28, 0x3d	; 61
    214c:	de b7       	in	r29, 0x3e	; 62
    214e:	2a 97       	sbiw	r28, 0x0a	; 10
    2150:	0f b6       	in	r0, 0x3f	; 63
    2152:	f8 94       	cli
    2154:	de bf       	out	0x3e, r29	; 62
    2156:	0f be       	out	0x3f, r0	; 63
    2158:	cd bf       	out	0x3d, r28	; 61
    215a:	98 87       	std	Y+8, r25	; 0x08
    215c:	8f 83       	std	Y+7, r24	; 0x07
    215e:	7a 87       	std	Y+10, r23	; 0x0a
    2160:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2162:	8f 81       	ldd	r24, Y+7	; 0x07
    2164:	98 85       	ldd	r25, Y+8	; 0x08
    2166:	9a 83       	std	Y+2, r25	; 0x02
    2168:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    216a:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    216c:	e9 81       	ldd	r30, Y+1	; 0x01
    216e:	fa 81       	ldd	r31, Y+2	; 0x02
    2170:	82 8d       	ldd	r24, Z+26	; 0x1a
    2172:	88 23       	and	r24, r24
    2174:	b1 f0       	breq	.+44     	; 0x21a2 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2176:	e9 81       	ldd	r30, Y+1	; 0x01
    2178:	fa 81       	ldd	r31, Y+2	; 0x02
    217a:	86 81       	ldd	r24, Z+6	; 0x06
    217c:	97 81       	ldd	r25, Z+7	; 0x07
    217e:	9c 83       	std	Y+4, r25	; 0x04
    2180:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	9a 81       	ldd	r25, Y+2	; 0x02
    2186:	29 85       	ldd	r18, Y+9	; 0x09
    2188:	3a 85       	ldd	r19, Y+10	; 0x0a
    218a:	b9 01       	movw	r22, r18
    218c:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2190:	e9 81       	ldd	r30, Y+1	; 0x01
    2192:	fa 81       	ldd	r31, Y+2	; 0x02
    2194:	8b 81       	ldd	r24, Y+3	; 0x03
    2196:	9c 81       	ldd	r25, Y+4	; 0x04
    2198:	97 83       	std	Z+7, r25	; 0x07
    219a:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    219c:	81 e0       	ldi	r24, 0x01	; 1
    219e:	8e 83       	std	Y+6, r24	; 0x06
    21a0:	01 c0       	rjmp	.+2      	; 0x21a4 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    21a2:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    21a4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    21a6:	2a 96       	adiw	r28, 0x0a	; 10
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	de bf       	out	0x3e, r29	; 62
    21ae:	0f be       	out	0x3f, r0	; 63
    21b0:	cd bf       	out	0x3d, r28	; 61
    21b2:	cf 91       	pop	r28
    21b4:	df 91       	pop	r29
    21b6:	08 95       	ret

000021b8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    21b8:	df 93       	push	r29
    21ba:	cf 93       	push	r28
    21bc:	00 d0       	rcall	.+0      	; 0x21be <uxQueueMessagesWaiting+0x6>
    21be:	0f 92       	push	r0
    21c0:	cd b7       	in	r28, 0x3d	; 61
    21c2:	de b7       	in	r29, 0x3e	; 62
    21c4:	9b 83       	std	Y+3, r25	; 0x03
    21c6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    21ce:	ea 81       	ldd	r30, Y+2	; 0x02
    21d0:	fb 81       	ldd	r31, Y+3	; 0x03
    21d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21d4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    21d6:	0f 90       	pop	r0
    21d8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21da:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    21dc:	0f 90       	pop	r0
    21de:	0f 90       	pop	r0
    21e0:	0f 90       	pop	r0
    21e2:	cf 91       	pop	r28
    21e4:	df 91       	pop	r29
    21e6:	08 95       	ret

000021e8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    21e8:	df 93       	push	r29
    21ea:	cf 93       	push	r28
    21ec:	00 d0       	rcall	.+0      	; 0x21ee <uxQueueSpacesAvailable+0x6>
    21ee:	00 d0       	rcall	.+0      	; 0x21f0 <uxQueueSpacesAvailable+0x8>
    21f0:	0f 92       	push	r0
    21f2:	cd b7       	in	r28, 0x3d	; 61
    21f4:	de b7       	in	r29, 0x3e	; 62
    21f6:	9d 83       	std	Y+5, r25	; 0x05
    21f8:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    21fa:	8c 81       	ldd	r24, Y+4	; 0x04
    21fc:	9d 81       	ldd	r25, Y+5	; 0x05
    21fe:	9a 83       	std	Y+2, r25	; 0x02
    2200:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2202:	0f b6       	in	r0, 0x3f	; 63
    2204:	f8 94       	cli
    2206:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	93 8d       	ldd	r25, Z+27	; 0x1b
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	82 8d       	ldd	r24, Z+26	; 0x1a
    2214:	29 2f       	mov	r18, r25
    2216:	28 1b       	sub	r18, r24
    2218:	82 2f       	mov	r24, r18
    221a:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    221c:	0f 90       	pop	r0
    221e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2220:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
    2228:	0f 90       	pop	r0
    222a:	0f 90       	pop	r0
    222c:	cf 91       	pop	r28
    222e:	df 91       	pop	r29
    2230:	08 95       	ret

00002232 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2232:	df 93       	push	r29
    2234:	cf 93       	push	r28
    2236:	00 d0       	rcall	.+0      	; 0x2238 <uxQueueMessagesWaitingFromISR+0x6>
    2238:	0f 92       	push	r0
    223a:	cd b7       	in	r28, 0x3d	; 61
    223c:	de b7       	in	r29, 0x3e	; 62
    223e:	9b 83       	std	Y+3, r25	; 0x03
    2240:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2242:	ea 81       	ldd	r30, Y+2	; 0x02
    2244:	fb 81       	ldd	r31, Y+3	; 0x03
    2246:	82 8d       	ldd	r24, Z+26	; 0x1a
    2248:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    224a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    224c:	0f 90       	pop	r0
    224e:	0f 90       	pop	r0
    2250:	0f 90       	pop	r0
    2252:	cf 91       	pop	r28
    2254:	df 91       	pop	r29
    2256:	08 95       	ret

00002258 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2258:	df 93       	push	r29
    225a:	cf 93       	push	r28
    225c:	00 d0       	rcall	.+0      	; 0x225e <vQueueDelete+0x6>
    225e:	00 d0       	rcall	.+0      	; 0x2260 <vQueueDelete+0x8>
    2260:	cd b7       	in	r28, 0x3d	; 61
    2262:	de b7       	in	r29, 0x3e	; 62
    2264:	9c 83       	std	Y+4, r25	; 0x04
    2266:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2268:	8b 81       	ldd	r24, Y+3	; 0x03
    226a:	9c 81       	ldd	r25, Y+4	; 0x04
    226c:	9a 83       	std	Y+2, r25	; 0x02
    226e:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2270:	89 81       	ldd	r24, Y+1	; 0x01
    2272:	9a 81       	ldd	r25, Y+2	; 0x02
    2274:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2278:	0f 90       	pop	r0
    227a:	0f 90       	pop	r0
    227c:	0f 90       	pop	r0
    227e:	0f 90       	pop	r0
    2280:	cf 91       	pop	r28
    2282:	df 91       	pop	r29
    2284:	08 95       	ret

00002286 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2286:	df 93       	push	r29
    2288:	cf 93       	push	r28
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	27 97       	sbiw	r28, 0x07	; 7
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	de bf       	out	0x3e, r29	; 62
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	9c 83       	std	Y+4, r25	; 0x04
    229c:	8b 83       	std	Y+3, r24	; 0x03
    229e:	7e 83       	std	Y+6, r23	; 0x06
    22a0:	6d 83       	std	Y+5, r22	; 0x05
    22a2:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    22a4:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22a6:	eb 81       	ldd	r30, Y+3	; 0x03
    22a8:	fc 81       	ldd	r31, Y+4	; 0x04
    22aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    22ac:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    22ae:	eb 81       	ldd	r30, Y+3	; 0x03
    22b0:	fc 81       	ldd	r31, Y+4	; 0x04
    22b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    22b4:	88 23       	and	r24, r24
    22b6:	99 f4       	brne	.+38     	; 0x22de <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    22b8:	eb 81       	ldd	r30, Y+3	; 0x03
    22ba:	fc 81       	ldd	r31, Y+4	; 0x04
    22bc:	80 81       	ld	r24, Z
    22be:	91 81       	ldd	r25, Z+1	; 0x01
    22c0:	00 97       	sbiw	r24, 0x00	; 0
    22c2:	09 f0       	breq	.+2      	; 0x22c6 <prvCopyDataToQueue+0x40>
    22c4:	89 c0       	rjmp	.+274    	; 0x23d8 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	82 81       	ldd	r24, Z+2	; 0x02
    22cc:	93 81       	ldd	r25, Z+3	; 0x03
    22ce:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <xTaskPriorityDisinherit>
    22d2:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->pxMutexHolder = NULL;
    22d4:	eb 81       	ldd	r30, Y+3	; 0x03
    22d6:	fc 81       	ldd	r31, Y+4	; 0x04
    22d8:	13 82       	std	Z+3, r1	; 0x03
    22da:	12 82       	std	Z+2, r1	; 0x02
    22dc:	7d c0       	rjmp	.+250    	; 0x23d8 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    22de:	8f 81       	ldd	r24, Y+7	; 0x07
    22e0:	88 23       	and	r24, r24
    22e2:	99 f5       	brne	.+102    	; 0x234a <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    22e4:	eb 81       	ldd	r30, Y+3	; 0x03
    22e6:	fc 81       	ldd	r31, Y+4	; 0x04
    22e8:	64 81       	ldd	r22, Z+4	; 0x04
    22ea:	75 81       	ldd	r23, Z+5	; 0x05
    22ec:	eb 81       	ldd	r30, Y+3	; 0x03
    22ee:	fc 81       	ldd	r31, Y+4	; 0x04
    22f0:	84 8d       	ldd	r24, Z+28	; 0x1c
    22f2:	48 2f       	mov	r20, r24
    22f4:	50 e0       	ldi	r21, 0x00	; 0
    22f6:	2d 81       	ldd	r18, Y+5	; 0x05
    22f8:	3e 81       	ldd	r19, Y+6	; 0x06
    22fa:	cb 01       	movw	r24, r22
    22fc:	b9 01       	movw	r22, r18
    22fe:	0e 94 78 33 	call	0x66f0	; 0x66f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2302:	eb 81       	ldd	r30, Y+3	; 0x03
    2304:	fc 81       	ldd	r31, Y+4	; 0x04
    2306:	24 81       	ldd	r18, Z+4	; 0x04
    2308:	35 81       	ldd	r19, Z+5	; 0x05
    230a:	eb 81       	ldd	r30, Y+3	; 0x03
    230c:	fc 81       	ldd	r31, Y+4	; 0x04
    230e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2310:	88 2f       	mov	r24, r24
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	82 0f       	add	r24, r18
    2316:	93 1f       	adc	r25, r19
    2318:	eb 81       	ldd	r30, Y+3	; 0x03
    231a:	fc 81       	ldd	r31, Y+4	; 0x04
    231c:	95 83       	std	Z+5, r25	; 0x05
    231e:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2320:	eb 81       	ldd	r30, Y+3	; 0x03
    2322:	fc 81       	ldd	r31, Y+4	; 0x04
    2324:	24 81       	ldd	r18, Z+4	; 0x04
    2326:	35 81       	ldd	r19, Z+5	; 0x05
    2328:	eb 81       	ldd	r30, Y+3	; 0x03
    232a:	fc 81       	ldd	r31, Y+4	; 0x04
    232c:	82 81       	ldd	r24, Z+2	; 0x02
    232e:	93 81       	ldd	r25, Z+3	; 0x03
    2330:	28 17       	cp	r18, r24
    2332:	39 07       	cpc	r19, r25
    2334:	08 f4       	brcc	.+2      	; 0x2338 <prvCopyDataToQueue+0xb2>
    2336:	50 c0       	rjmp	.+160    	; 0x23d8 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2338:	eb 81       	ldd	r30, Y+3	; 0x03
    233a:	fc 81       	ldd	r31, Y+4	; 0x04
    233c:	80 81       	ld	r24, Z
    233e:	91 81       	ldd	r25, Z+1	; 0x01
    2340:	eb 81       	ldd	r30, Y+3	; 0x03
    2342:	fc 81       	ldd	r31, Y+4	; 0x04
    2344:	95 83       	std	Z+5, r25	; 0x05
    2346:	84 83       	std	Z+4, r24	; 0x04
    2348:	47 c0       	rjmp	.+142    	; 0x23d8 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    234a:	eb 81       	ldd	r30, Y+3	; 0x03
    234c:	fc 81       	ldd	r31, Y+4	; 0x04
    234e:	66 81       	ldd	r22, Z+6	; 0x06
    2350:	77 81       	ldd	r23, Z+7	; 0x07
    2352:	eb 81       	ldd	r30, Y+3	; 0x03
    2354:	fc 81       	ldd	r31, Y+4	; 0x04
    2356:	84 8d       	ldd	r24, Z+28	; 0x1c
    2358:	48 2f       	mov	r20, r24
    235a:	50 e0       	ldi	r21, 0x00	; 0
    235c:	2d 81       	ldd	r18, Y+5	; 0x05
    235e:	3e 81       	ldd	r19, Y+6	; 0x06
    2360:	cb 01       	movw	r24, r22
    2362:	b9 01       	movw	r22, r18
    2364:	0e 94 78 33 	call	0x66f0	; 0x66f0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2368:	eb 81       	ldd	r30, Y+3	; 0x03
    236a:	fc 81       	ldd	r31, Y+4	; 0x04
    236c:	26 81       	ldd	r18, Z+6	; 0x06
    236e:	37 81       	ldd	r19, Z+7	; 0x07
    2370:	eb 81       	ldd	r30, Y+3	; 0x03
    2372:	fc 81       	ldd	r31, Y+4	; 0x04
    2374:	84 8d       	ldd	r24, Z+28	; 0x1c
    2376:	88 2f       	mov	r24, r24
    2378:	90 e0       	ldi	r25, 0x00	; 0
    237a:	90 95       	com	r25
    237c:	81 95       	neg	r24
    237e:	9f 4f       	sbci	r25, 0xFF	; 255
    2380:	82 0f       	add	r24, r18
    2382:	93 1f       	adc	r25, r19
    2384:	eb 81       	ldd	r30, Y+3	; 0x03
    2386:	fc 81       	ldd	r31, Y+4	; 0x04
    2388:	97 83       	std	Z+7, r25	; 0x07
    238a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    238c:	eb 81       	ldd	r30, Y+3	; 0x03
    238e:	fc 81       	ldd	r31, Y+4	; 0x04
    2390:	26 81       	ldd	r18, Z+6	; 0x06
    2392:	37 81       	ldd	r19, Z+7	; 0x07
    2394:	eb 81       	ldd	r30, Y+3	; 0x03
    2396:	fc 81       	ldd	r31, Y+4	; 0x04
    2398:	80 81       	ld	r24, Z
    239a:	91 81       	ldd	r25, Z+1	; 0x01
    239c:	28 17       	cp	r18, r24
    239e:	39 07       	cpc	r19, r25
    23a0:	90 f4       	brcc	.+36     	; 0x23c6 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    23a2:	eb 81       	ldd	r30, Y+3	; 0x03
    23a4:	fc 81       	ldd	r31, Y+4	; 0x04
    23a6:	22 81       	ldd	r18, Z+2	; 0x02
    23a8:	33 81       	ldd	r19, Z+3	; 0x03
    23aa:	eb 81       	ldd	r30, Y+3	; 0x03
    23ac:	fc 81       	ldd	r31, Y+4	; 0x04
    23ae:	84 8d       	ldd	r24, Z+28	; 0x1c
    23b0:	88 2f       	mov	r24, r24
    23b2:	90 e0       	ldi	r25, 0x00	; 0
    23b4:	90 95       	com	r25
    23b6:	81 95       	neg	r24
    23b8:	9f 4f       	sbci	r25, 0xFF	; 255
    23ba:	82 0f       	add	r24, r18
    23bc:	93 1f       	adc	r25, r19
    23be:	eb 81       	ldd	r30, Y+3	; 0x03
    23c0:	fc 81       	ldd	r31, Y+4	; 0x04
    23c2:	97 83       	std	Z+7, r25	; 0x07
    23c4:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    23c6:	8f 81       	ldd	r24, Y+7	; 0x07
    23c8:	82 30       	cpi	r24, 0x02	; 2
    23ca:	31 f4       	brne	.+12     	; 0x23d8 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    23cc:	89 81       	ldd	r24, Y+1	; 0x01
    23ce:	88 23       	and	r24, r24
    23d0:	19 f0       	breq	.+6      	; 0x23d8 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    23d2:	89 81       	ldd	r24, Y+1	; 0x01
    23d4:	81 50       	subi	r24, 0x01	; 1
    23d6:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    23d8:	89 81       	ldd	r24, Y+1	; 0x01
    23da:	8f 5f       	subi	r24, 0xFF	; 255
    23dc:	eb 81       	ldd	r30, Y+3	; 0x03
    23de:	fc 81       	ldd	r31, Y+4	; 0x04
    23e0:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    23e2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    23e4:	27 96       	adiw	r28, 0x07	; 7
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	de bf       	out	0x3e, r29	; 62
    23ec:	0f be       	out	0x3f, r0	; 63
    23ee:	cd bf       	out	0x3d, r28	; 61
    23f0:	cf 91       	pop	r28
    23f2:	df 91       	pop	r29
    23f4:	08 95       	ret

000023f6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    23f6:	df 93       	push	r29
    23f8:	cf 93       	push	r28
    23fa:	00 d0       	rcall	.+0      	; 0x23fc <prvCopyDataFromQueue+0x6>
    23fc:	00 d0       	rcall	.+0      	; 0x23fe <prvCopyDataFromQueue+0x8>
    23fe:	cd b7       	in	r28, 0x3d	; 61
    2400:	de b7       	in	r29, 0x3e	; 62
    2402:	9a 83       	std	Y+2, r25	; 0x02
    2404:	89 83       	std	Y+1, r24	; 0x01
    2406:	7c 83       	std	Y+4, r23	; 0x04
    2408:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    240a:	e9 81       	ldd	r30, Y+1	; 0x01
    240c:	fa 81       	ldd	r31, Y+2	; 0x02
    240e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2410:	88 23       	and	r24, r24
    2412:	89 f1       	breq	.+98     	; 0x2476 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2414:	e9 81       	ldd	r30, Y+1	; 0x01
    2416:	fa 81       	ldd	r31, Y+2	; 0x02
    2418:	26 81       	ldd	r18, Z+6	; 0x06
    241a:	37 81       	ldd	r19, Z+7	; 0x07
    241c:	e9 81       	ldd	r30, Y+1	; 0x01
    241e:	fa 81       	ldd	r31, Y+2	; 0x02
    2420:	84 8d       	ldd	r24, Z+28	; 0x1c
    2422:	88 2f       	mov	r24, r24
    2424:	90 e0       	ldi	r25, 0x00	; 0
    2426:	82 0f       	add	r24, r18
    2428:	93 1f       	adc	r25, r19
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	97 83       	std	Z+7, r25	; 0x07
    2430:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2432:	e9 81       	ldd	r30, Y+1	; 0x01
    2434:	fa 81       	ldd	r31, Y+2	; 0x02
    2436:	26 81       	ldd	r18, Z+6	; 0x06
    2438:	37 81       	ldd	r19, Z+7	; 0x07
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	82 81       	ldd	r24, Z+2	; 0x02
    2440:	93 81       	ldd	r25, Z+3	; 0x03
    2442:	28 17       	cp	r18, r24
    2444:	39 07       	cpc	r19, r25
    2446:	40 f0       	brcs	.+16     	; 0x2458 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2448:	e9 81       	ldd	r30, Y+1	; 0x01
    244a:	fa 81       	ldd	r31, Y+2	; 0x02
    244c:	80 81       	ld	r24, Z
    244e:	91 81       	ldd	r25, Z+1	; 0x01
    2450:	e9 81       	ldd	r30, Y+1	; 0x01
    2452:	fa 81       	ldd	r31, Y+2	; 0x02
    2454:	97 83       	std	Z+7, r25	; 0x07
    2456:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2458:	e9 81       	ldd	r30, Y+1	; 0x01
    245a:	fa 81       	ldd	r31, Y+2	; 0x02
    245c:	46 81       	ldd	r20, Z+6	; 0x06
    245e:	57 81       	ldd	r21, Z+7	; 0x07
    2460:	e9 81       	ldd	r30, Y+1	; 0x01
    2462:	fa 81       	ldd	r31, Y+2	; 0x02
    2464:	84 8d       	ldd	r24, Z+28	; 0x1c
    2466:	28 2f       	mov	r18, r24
    2468:	30 e0       	ldi	r19, 0x00	; 0
    246a:	8b 81       	ldd	r24, Y+3	; 0x03
    246c:	9c 81       	ldd	r25, Y+4	; 0x04
    246e:	ba 01       	movw	r22, r20
    2470:	a9 01       	movw	r20, r18
    2472:	0e 94 78 33 	call	0x66f0	; 0x66f0 <memcpy>
	}
}
    2476:	0f 90       	pop	r0
    2478:	0f 90       	pop	r0
    247a:	0f 90       	pop	r0
    247c:	0f 90       	pop	r0
    247e:	cf 91       	pop	r28
    2480:	df 91       	pop	r29
    2482:	08 95       	ret

00002484 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2484:	df 93       	push	r29
    2486:	cf 93       	push	r28
    2488:	00 d0       	rcall	.+0      	; 0x248a <prvUnlockQueue+0x6>
    248a:	00 d0       	rcall	.+0      	; 0x248c <prvUnlockQueue+0x8>
    248c:	cd b7       	in	r28, 0x3d	; 61
    248e:	de b7       	in	r29, 0x3e	; 62
    2490:	9c 83       	std	Y+4, r25	; 0x04
    2492:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2494:	0f b6       	in	r0, 0x3f	; 63
    2496:	f8 94       	cli
    2498:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    249a:	eb 81       	ldd	r30, Y+3	; 0x03
    249c:	fc 81       	ldd	r31, Y+4	; 0x04
    249e:	86 8d       	ldd	r24, Z+30	; 0x1e
    24a0:	8a 83       	std	Y+2, r24	; 0x02
    24a2:	11 c0       	rjmp	.+34     	; 0x24c6 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24a4:	eb 81       	ldd	r30, Y+3	; 0x03
    24a6:	fc 81       	ldd	r31, Y+4	; 0x04
    24a8:	81 89       	ldd	r24, Z+17	; 0x11
    24aa:	88 23       	and	r24, r24
    24ac:	79 f0       	breq	.+30     	; 0x24cc <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24ae:	8b 81       	ldd	r24, Y+3	; 0x03
    24b0:	9c 81       	ldd	r25, Y+4	; 0x04
    24b2:	41 96       	adiw	r24, 0x11	; 17
    24b4:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    24b8:	88 23       	and	r24, r24
    24ba:	11 f0       	breq	.+4      	; 0x24c0 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    24bc:	0e 94 19 1c 	call	0x3832	; 0x3832 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    24c0:	8a 81       	ldd	r24, Y+2	; 0x02
    24c2:	81 50       	subi	r24, 0x01	; 1
    24c4:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    24c6:	8a 81       	ldd	r24, Y+2	; 0x02
    24c8:	18 16       	cp	r1, r24
    24ca:	64 f3       	brlt	.-40     	; 0x24a4 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    24cc:	eb 81       	ldd	r30, Y+3	; 0x03
    24ce:	fc 81       	ldd	r31, Y+4	; 0x04
    24d0:	8f ef       	ldi	r24, 0xFF	; 255
    24d2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    24d4:	0f 90       	pop	r0
    24d6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    24d8:	0f b6       	in	r0, 0x3f	; 63
    24da:	f8 94       	cli
    24dc:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    24de:	eb 81       	ldd	r30, Y+3	; 0x03
    24e0:	fc 81       	ldd	r31, Y+4	; 0x04
    24e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    24e4:	89 83       	std	Y+1, r24	; 0x01
    24e6:	11 c0       	rjmp	.+34     	; 0x250a <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24e8:	eb 81       	ldd	r30, Y+3	; 0x03
    24ea:	fc 81       	ldd	r31, Y+4	; 0x04
    24ec:	80 85       	ldd	r24, Z+8	; 0x08
    24ee:	88 23       	and	r24, r24
    24f0:	79 f0       	breq	.+30     	; 0x2510 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24f2:	8b 81       	ldd	r24, Y+3	; 0x03
    24f4:	9c 81       	ldd	r25, Y+4	; 0x04
    24f6:	08 96       	adiw	r24, 0x08	; 8
    24f8:	0e 94 c3 1a 	call	0x3586	; 0x3586 <xTaskRemoveFromEventList>
    24fc:	88 23       	and	r24, r24
    24fe:	11 f0       	breq	.+4      	; 0x2504 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2500:	0e 94 19 1c 	call	0x3832	; 0x3832 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2504:	89 81       	ldd	r24, Y+1	; 0x01
    2506:	81 50       	subi	r24, 0x01	; 1
    2508:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    250a:	89 81       	ldd	r24, Y+1	; 0x01
    250c:	18 16       	cp	r1, r24
    250e:	64 f3       	brlt	.-40     	; 0x24e8 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2510:	eb 81       	ldd	r30, Y+3	; 0x03
    2512:	fc 81       	ldd	r31, Y+4	; 0x04
    2514:	8f ef       	ldi	r24, 0xFF	; 255
    2516:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2518:	0f 90       	pop	r0
    251a:	0f be       	out	0x3f, r0	; 63
}
    251c:	0f 90       	pop	r0
    251e:	0f 90       	pop	r0
    2520:	0f 90       	pop	r0
    2522:	0f 90       	pop	r0
    2524:	cf 91       	pop	r28
    2526:	df 91       	pop	r29
    2528:	08 95       	ret

0000252a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    252a:	df 93       	push	r29
    252c:	cf 93       	push	r28
    252e:	00 d0       	rcall	.+0      	; 0x2530 <prvIsQueueEmpty+0x6>
    2530:	0f 92       	push	r0
    2532:	cd b7       	in	r28, 0x3d	; 61
    2534:	de b7       	in	r29, 0x3e	; 62
    2536:	9b 83       	std	Y+3, r25	; 0x03
    2538:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    253a:	0f b6       	in	r0, 0x3f	; 63
    253c:	f8 94       	cli
    253e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2540:	ea 81       	ldd	r30, Y+2	; 0x02
    2542:	fb 81       	ldd	r31, Y+3	; 0x03
    2544:	82 8d       	ldd	r24, Z+26	; 0x1a
    2546:	88 23       	and	r24, r24
    2548:	19 f4       	brne	.+6      	; 0x2550 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    254a:	81 e0       	ldi	r24, 0x01	; 1
    254c:	89 83       	std	Y+1, r24	; 0x01
    254e:	01 c0       	rjmp	.+2      	; 0x2552 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2550:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2552:	0f 90       	pop	r0
    2554:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2556:	89 81       	ldd	r24, Y+1	; 0x01
}
    2558:	0f 90       	pop	r0
    255a:	0f 90       	pop	r0
    255c:	0f 90       	pop	r0
    255e:	cf 91       	pop	r28
    2560:	df 91       	pop	r29
    2562:	08 95       	ret

00002564 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2564:	df 93       	push	r29
    2566:	cf 93       	push	r28
    2568:	00 d0       	rcall	.+0      	; 0x256a <xQueueIsQueueEmptyFromISR+0x6>
    256a:	0f 92       	push	r0
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
    2570:	9b 83       	std	Y+3, r25	; 0x03
    2572:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2574:	ea 81       	ldd	r30, Y+2	; 0x02
    2576:	fb 81       	ldd	r31, Y+3	; 0x03
    2578:	82 8d       	ldd	r24, Z+26	; 0x1a
    257a:	88 23       	and	r24, r24
    257c:	19 f4       	brne	.+6      	; 0x2584 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	89 83       	std	Y+1, r24	; 0x01
    2582:	01 c0       	rjmp	.+2      	; 0x2586 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    2584:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2586:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2588:	0f 90       	pop	r0
    258a:	0f 90       	pop	r0
    258c:	0f 90       	pop	r0
    258e:	cf 91       	pop	r28
    2590:	df 91       	pop	r29
    2592:	08 95       	ret

00002594 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2594:	df 93       	push	r29
    2596:	cf 93       	push	r28
    2598:	00 d0       	rcall	.+0      	; 0x259a <prvIsQueueFull+0x6>
    259a:	0f 92       	push	r0
    259c:	cd b7       	in	r28, 0x3d	; 61
    259e:	de b7       	in	r29, 0x3e	; 62
    25a0:	9b 83       	std	Y+3, r25	; 0x03
    25a2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    25a4:	0f b6       	in	r0, 0x3f	; 63
    25a6:	f8 94       	cli
    25a8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    25aa:	ea 81       	ldd	r30, Y+2	; 0x02
    25ac:	fb 81       	ldd	r31, Y+3	; 0x03
    25ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    25b0:	ea 81       	ldd	r30, Y+2	; 0x02
    25b2:	fb 81       	ldd	r31, Y+3	; 0x03
    25b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    25b6:	98 17       	cp	r25, r24
    25b8:	19 f4       	brne	.+6      	; 0x25c0 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	89 83       	std	Y+1, r24	; 0x01
    25be:	01 c0       	rjmp	.+2      	; 0x25c2 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    25c0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    25c2:	0f 90       	pop	r0
    25c4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    25c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    25c8:	0f 90       	pop	r0
    25ca:	0f 90       	pop	r0
    25cc:	0f 90       	pop	r0
    25ce:	cf 91       	pop	r28
    25d0:	df 91       	pop	r29
    25d2:	08 95       	ret

000025d4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    25d4:	df 93       	push	r29
    25d6:	cf 93       	push	r28
    25d8:	00 d0       	rcall	.+0      	; 0x25da <xQueueIsQueueFullFromISR+0x6>
    25da:	0f 92       	push	r0
    25dc:	cd b7       	in	r28, 0x3d	; 61
    25de:	de b7       	in	r29, 0x3e	; 62
    25e0:	9b 83       	std	Y+3, r25	; 0x03
    25e2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    25e4:	ea 81       	ldd	r30, Y+2	; 0x02
    25e6:	fb 81       	ldd	r31, Y+3	; 0x03
    25e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    25ea:	ea 81       	ldd	r30, Y+2	; 0x02
    25ec:	fb 81       	ldd	r31, Y+3	; 0x03
    25ee:	83 8d       	ldd	r24, Z+27	; 0x1b
    25f0:	98 17       	cp	r25, r24
    25f2:	19 f4       	brne	.+6      	; 0x25fa <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	89 83       	std	Y+1, r24	; 0x01
    25f8:	01 c0       	rjmp	.+2      	; 0x25fc <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    25fa:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    25fc:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    25fe:	0f 90       	pop	r0
    2600:	0f 90       	pop	r0
    2602:	0f 90       	pop	r0
    2604:	cf 91       	pop	r28
    2606:	df 91       	pop	r29
    2608:	08 95       	ret

0000260a <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    260a:	8f 92       	push	r8
    260c:	9f 92       	push	r9
    260e:	af 92       	push	r10
    2610:	bf 92       	push	r11
    2612:	cf 92       	push	r12
    2614:	df 92       	push	r13
    2616:	ef 92       	push	r14
    2618:	ff 92       	push	r15
    261a:	0f 93       	push	r16
    261c:	1f 93       	push	r17
    261e:	df 93       	push	r29
    2620:	cf 93       	push	r28
    2622:	cd b7       	in	r28, 0x3d	; 61
    2624:	de b7       	in	r29, 0x3e	; 62
    2626:	60 97       	sbiw	r28, 0x10	; 16
    2628:	0f b6       	in	r0, 0x3f	; 63
    262a:	f8 94       	cli
    262c:	de bf       	out	0x3e, r29	; 62
    262e:	0f be       	out	0x3f, r0	; 63
    2630:	cd bf       	out	0x3d, r28	; 61
    2632:	9f 83       	std	Y+7, r25	; 0x07
    2634:	8e 83       	std	Y+6, r24	; 0x06
    2636:	79 87       	std	Y+9, r23	; 0x09
    2638:	68 87       	std	Y+8, r22	; 0x08
    263a:	5b 87       	std	Y+11, r21	; 0x0b
    263c:	4a 87       	std	Y+10, r20	; 0x0a
    263e:	3d 87       	std	Y+13, r19	; 0x0d
    2640:	2c 87       	std	Y+12, r18	; 0x0c
    2642:	0e 87       	std	Y+14, r16	; 0x0e
    2644:	f8 8a       	std	Y+16, r15	; 0x10
    2646:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2648:	8a 85       	ldd	r24, Y+10	; 0x0a
    264a:	9b 85       	ldd	r25, Y+11	; 0x0b
    264c:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    2650:	9a 83       	std	Y+2, r25	; 0x02
    2652:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2654:	89 81       	ldd	r24, Y+1	; 0x01
    2656:	9a 81       	ldd	r25, Y+2	; 0x02
    2658:	00 97       	sbiw	r24, 0x00	; 0
    265a:	b1 f0       	breq	.+44     	; 0x2688 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    265c:	80 e3       	ldi	r24, 0x30	; 48
    265e:	90 e0       	ldi	r25, 0x00	; 0
    2660:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    2664:	9d 83       	std	Y+5, r25	; 0x05
    2666:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2668:	8c 81       	ldd	r24, Y+4	; 0x04
    266a:	9d 81       	ldd	r25, Y+5	; 0x05
    266c:	00 97       	sbiw	r24, 0x00	; 0
    266e:	39 f0       	breq	.+14     	; 0x267e <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2670:	ec 81       	ldd	r30, Y+4	; 0x04
    2672:	fd 81       	ldd	r31, Y+5	; 0x05
    2674:	89 81       	ldd	r24, Y+1	; 0x01
    2676:	9a 81       	ldd	r25, Y+2	; 0x02
    2678:	90 8f       	std	Z+24, r25	; 0x18
    267a:	87 8b       	std	Z+23, r24	; 0x17
    267c:	07 c0       	rjmp	.+14     	; 0x268c <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    267e:	89 81       	ldd	r24, Y+1	; 0x01
    2680:	9a 81       	ldd	r25, Y+2	; 0x02
    2682:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
    2686:	02 c0       	rjmp	.+4      	; 0x268c <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2688:	1d 82       	std	Y+5, r1	; 0x05
    268a:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    268c:	8c 81       	ldd	r24, Y+4	; 0x04
    268e:	9d 81       	ldd	r25, Y+5	; 0x05
    2690:	00 97       	sbiw	r24, 0x00	; 0
    2692:	e9 f0       	breq	.+58     	; 0x26ce <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2694:	8a 85       	ldd	r24, Y+10	; 0x0a
    2696:	9b 85       	ldd	r25, Y+11	; 0x0b
    2698:	9c 01       	movw	r18, r24
    269a:	40 e0       	ldi	r20, 0x00	; 0
    269c:	50 e0       	ldi	r21, 0x00	; 0
    269e:	8e 81       	ldd	r24, Y+6	; 0x06
    26a0:	9f 81       	ldd	r25, Y+7	; 0x07
    26a2:	68 85       	ldd	r22, Y+8	; 0x08
    26a4:	79 85       	ldd	r23, Y+9	; 0x09
    26a6:	ec 85       	ldd	r30, Y+12	; 0x0c
    26a8:	fd 85       	ldd	r31, Y+13	; 0x0d
    26aa:	af 85       	ldd	r26, Y+15	; 0x0f
    26ac:	b8 89       	ldd	r27, Y+16	; 0x10
    26ae:	ac 80       	ldd	r10, Y+4	; 0x04
    26b0:	bd 80       	ldd	r11, Y+5	; 0x05
    26b2:	8f 01       	movw	r16, r30
    26b4:	ee 84       	ldd	r14, Y+14	; 0x0e
    26b6:	6d 01       	movw	r12, r26
    26b8:	88 24       	eor	r8, r8
    26ba:	99 24       	eor	r9, r9
    26bc:	0e 94 7d 13 	call	0x26fa	; 0x26fa <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    26c0:	8c 81       	ldd	r24, Y+4	; 0x04
    26c2:	9d 81       	ldd	r25, Y+5	; 0x05
    26c4:	0e 94 38 14 	call	0x2870	; 0x2870 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	8b 83       	std	Y+3, r24	; 0x03
    26cc:	02 c0       	rjmp	.+4      	; 0x26d2 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    26ce:	8f ef       	ldi	r24, 0xFF	; 255
    26d0:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    26d2:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    26d4:	60 96       	adiw	r28, 0x10	; 16
    26d6:	0f b6       	in	r0, 0x3f	; 63
    26d8:	f8 94       	cli
    26da:	de bf       	out	0x3e, r29	; 62
    26dc:	0f be       	out	0x3f, r0	; 63
    26de:	cd bf       	out	0x3d, r28	; 61
    26e0:	cf 91       	pop	r28
    26e2:	df 91       	pop	r29
    26e4:	1f 91       	pop	r17
    26e6:	0f 91       	pop	r16
    26e8:	ff 90       	pop	r15
    26ea:	ef 90       	pop	r14
    26ec:	df 90       	pop	r13
    26ee:	cf 90       	pop	r12
    26f0:	bf 90       	pop	r11
    26f2:	af 90       	pop	r10
    26f4:	9f 90       	pop	r9
    26f6:	8f 90       	pop	r8
    26f8:	08 95       	ret

000026fa <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    26fa:	8f 92       	push	r8
    26fc:	9f 92       	push	r9
    26fe:	af 92       	push	r10
    2700:	bf 92       	push	r11
    2702:	cf 92       	push	r12
    2704:	df 92       	push	r13
    2706:	ef 92       	push	r14
    2708:	0f 93       	push	r16
    270a:	1f 93       	push	r17
    270c:	df 93       	push	r29
    270e:	cf 93       	push	r28
    2710:	cd b7       	in	r28, 0x3d	; 61
    2712:	de b7       	in	r29, 0x3e	; 62
    2714:	64 97       	sbiw	r28, 0x14	; 20
    2716:	0f b6       	in	r0, 0x3f	; 63
    2718:	f8 94       	cli
    271a:	de bf       	out	0x3e, r29	; 62
    271c:	0f be       	out	0x3f, r0	; 63
    271e:	cd bf       	out	0x3d, r28	; 61
    2720:	9d 83       	std	Y+5, r25	; 0x05
    2722:	8c 83       	std	Y+4, r24	; 0x04
    2724:	7f 83       	std	Y+7, r23	; 0x07
    2726:	6e 83       	std	Y+6, r22	; 0x06
    2728:	28 87       	std	Y+8, r18	; 0x08
    272a:	39 87       	std	Y+9, r19	; 0x09
    272c:	4a 87       	std	Y+10, r20	; 0x0a
    272e:	5b 87       	std	Y+11, r21	; 0x0b
    2730:	1d 87       	std	Y+13, r17	; 0x0d
    2732:	0c 87       	std	Y+12, r16	; 0x0c
    2734:	ee 86       	std	Y+14, r14	; 0x0e
    2736:	d8 8a       	std	Y+16, r13	; 0x10
    2738:	cf 86       	std	Y+15, r12	; 0x0f
    273a:	ba 8a       	std	Y+18, r11	; 0x12
    273c:	a9 8a       	std	Y+17, r10	; 0x11
    273e:	9c 8a       	std	Y+20, r9	; 0x14
    2740:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    2742:	e9 89       	ldd	r30, Y+17	; 0x11
    2744:	fa 89       	ldd	r31, Y+18	; 0x12
    2746:	27 89       	ldd	r18, Z+23	; 0x17
    2748:	30 8d       	ldd	r19, Z+24	; 0x18
    274a:	88 85       	ldd	r24, Y+8	; 0x08
    274c:	99 85       	ldd	r25, Y+9	; 0x09
    274e:	01 97       	sbiw	r24, 0x01	; 1
    2750:	82 0f       	add	r24, r18
    2752:	93 1f       	adc	r25, r19
    2754:	9b 83       	std	Y+3, r25	; 0x03
    2756:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2758:	19 82       	std	Y+1, r1	; 0x01
    275a:	21 c0       	rjmp	.+66     	; 0x279e <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    275c:	89 81       	ldd	r24, Y+1	; 0x01
    275e:	48 2f       	mov	r20, r24
    2760:	50 e0       	ldi	r21, 0x00	; 0
    2762:	89 81       	ldd	r24, Y+1	; 0x01
    2764:	28 2f       	mov	r18, r24
    2766:	30 e0       	ldi	r19, 0x00	; 0
    2768:	8e 81       	ldd	r24, Y+6	; 0x06
    276a:	9f 81       	ldd	r25, Y+7	; 0x07
    276c:	fc 01       	movw	r30, r24
    276e:	e2 0f       	add	r30, r18
    2770:	f3 1f       	adc	r31, r19
    2772:	20 81       	ld	r18, Z
    2774:	89 89       	ldd	r24, Y+17	; 0x11
    2776:	9a 89       	ldd	r25, Y+18	; 0x12
    2778:	84 0f       	add	r24, r20
    277a:	95 1f       	adc	r25, r21
    277c:	fc 01       	movw	r30, r24
    277e:	79 96       	adiw	r30, 0x19	; 25
    2780:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2782:	89 81       	ldd	r24, Y+1	; 0x01
    2784:	28 2f       	mov	r18, r24
    2786:	30 e0       	ldi	r19, 0x00	; 0
    2788:	8e 81       	ldd	r24, Y+6	; 0x06
    278a:	9f 81       	ldd	r25, Y+7	; 0x07
    278c:	fc 01       	movw	r30, r24
    278e:	e2 0f       	add	r30, r18
    2790:	f3 1f       	adc	r31, r19
    2792:	80 81       	ld	r24, Z
    2794:	88 23       	and	r24, r24
    2796:	31 f0       	breq	.+12     	; 0x27a4 <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	8f 5f       	subi	r24, 0xFF	; 255
    279c:	89 83       	std	Y+1, r24	; 0x01
    279e:	89 81       	ldd	r24, Y+1	; 0x01
    27a0:	80 31       	cpi	r24, 0x10	; 16
    27a2:	e0 f2       	brcs	.-72     	; 0x275c <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    27a4:	e9 89       	ldd	r30, Y+17	; 0x11
    27a6:	fa 89       	ldd	r31, Y+18	; 0x12
    27a8:	10 a6       	std	Z+40, r1	; 0x28

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    27aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    27ac:	83 30       	cpi	r24, 0x03	; 3
    27ae:	10 f0       	brcs	.+4      	; 0x27b4 <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    27b0:	82 e0       	ldi	r24, 0x02	; 2
    27b2:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    27b4:	e9 89       	ldd	r30, Y+17	; 0x11
    27b6:	fa 89       	ldd	r31, Y+18	; 0x12
    27b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    27ba:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    27bc:	e9 89       	ldd	r30, Y+17	; 0x11
    27be:	fa 89       	ldd	r31, Y+18	; 0x12
    27c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    27c2:	81 a7       	std	Z+41, r24	; 0x29
		pxNewTCB->uxMutexesHeld = 0;
    27c4:	e9 89       	ldd	r30, Y+17	; 0x11
    27c6:	fa 89       	ldd	r31, Y+18	; 0x12
    27c8:	12 a6       	std	Z+42, r1	; 0x2a
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    27ca:	89 89       	ldd	r24, Y+17	; 0x11
    27cc:	9a 89       	ldd	r25, Y+18	; 0x12
    27ce:	02 96       	adiw	r24, 0x02	; 2
    27d0:	0e 94 dd 08 	call	0x11ba	; 0x11ba <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    27d4:	89 89       	ldd	r24, Y+17	; 0x11
    27d6:	9a 89       	ldd	r25, Y+18	; 0x12
    27d8:	0c 96       	adiw	r24, 0x0c	; 12
    27da:	0e 94 dd 08 	call	0x11ba	; 0x11ba <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    27de:	e9 89       	ldd	r30, Y+17	; 0x11
    27e0:	fa 89       	ldd	r31, Y+18	; 0x12
    27e2:	89 89       	ldd	r24, Y+17	; 0x11
    27e4:	9a 89       	ldd	r25, Y+18	; 0x12
    27e6:	91 87       	std	Z+9, r25	; 0x09
    27e8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    27ec:	28 2f       	mov	r18, r24
    27ee:	30 e0       	ldi	r19, 0x00	; 0
    27f0:	83 e0       	ldi	r24, 0x03	; 3
    27f2:	90 e0       	ldi	r25, 0x00	; 0
    27f4:	82 1b       	sub	r24, r18
    27f6:	93 0b       	sbc	r25, r19
    27f8:	e9 89       	ldd	r30, Y+17	; 0x11
    27fa:	fa 89       	ldd	r31, Y+18	; 0x12
    27fc:	95 87       	std	Z+13, r25	; 0x0d
    27fe:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2800:	e9 89       	ldd	r30, Y+17	; 0x11
    2802:	fa 89       	ldd	r31, Y+18	; 0x12
    2804:	89 89       	ldd	r24, Y+17	; 0x11
    2806:	9a 89       	ldd	r25, Y+18	; 0x12
    2808:	93 8b       	std	Z+19, r25	; 0x13
    280a:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    280c:	e9 89       	ldd	r30, Y+17	; 0x11
    280e:	fa 89       	ldd	r31, Y+18	; 0x12
    2810:	13 a6       	std	Z+43, r1	; 0x2b
    2812:	14 a6       	std	Z+44, r1	; 0x2c
    2814:	15 a6       	std	Z+45, r1	; 0x2d
    2816:	16 a6       	std	Z+46, r1	; 0x2e
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2818:	e9 89       	ldd	r30, Y+17	; 0x11
    281a:	fa 89       	ldd	r31, Y+18	; 0x12
    281c:	17 a6       	std	Z+47, r1	; 0x2f
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    281e:	8a 81       	ldd	r24, Y+2	; 0x02
    2820:	9b 81       	ldd	r25, Y+3	; 0x03
    2822:	2c 81       	ldd	r18, Y+4	; 0x04
    2824:	3d 81       	ldd	r19, Y+5	; 0x05
    2826:	4c 85       	ldd	r20, Y+12	; 0x0c
    2828:	5d 85       	ldd	r21, Y+13	; 0x0d
    282a:	b9 01       	movw	r22, r18
    282c:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <pxPortInitialiseStack>
    2830:	e9 89       	ldd	r30, Y+17	; 0x11
    2832:	fa 89       	ldd	r31, Y+18	; 0x12
    2834:	91 83       	std	Z+1, r25	; 0x01
    2836:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    2838:	8f 85       	ldd	r24, Y+15	; 0x0f
    283a:	98 89       	ldd	r25, Y+16	; 0x10
    283c:	00 97       	sbiw	r24, 0x00	; 0
    283e:	31 f0       	breq	.+12     	; 0x284c <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2840:	ef 85       	ldd	r30, Y+15	; 0x0f
    2842:	f8 89       	ldd	r31, Y+16	; 0x10
    2844:	89 89       	ldd	r24, Y+17	; 0x11
    2846:	9a 89       	ldd	r25, Y+18	; 0x12
    2848:	91 83       	std	Z+1, r25	; 0x01
    284a:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    284c:	64 96       	adiw	r28, 0x14	; 20
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	f8 94       	cli
    2852:	de bf       	out	0x3e, r29	; 62
    2854:	0f be       	out	0x3f, r0	; 63
    2856:	cd bf       	out	0x3d, r28	; 61
    2858:	cf 91       	pop	r28
    285a:	df 91       	pop	r29
    285c:	1f 91       	pop	r17
    285e:	0f 91       	pop	r16
    2860:	ef 90       	pop	r14
    2862:	df 90       	pop	r13
    2864:	cf 90       	pop	r12
    2866:	bf 90       	pop	r11
    2868:	af 90       	pop	r10
    286a:	9f 90       	pop	r9
    286c:	8f 90       	pop	r8
    286e:	08 95       	ret

00002870 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2870:	df 93       	push	r29
    2872:	cf 93       	push	r28
    2874:	00 d0       	rcall	.+0      	; 0x2876 <prvAddNewTaskToReadyList+0x6>
    2876:	cd b7       	in	r28, 0x3d	; 61
    2878:	de b7       	in	r29, 0x3e	; 62
    287a:	9a 83       	std	Y+2, r25	; 0x02
    287c:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    287e:	0f b6       	in	r0, 0x3f	; 63
    2880:	f8 94       	cli
    2882:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2884:	80 91 40 06 	lds	r24, 0x0640
    2888:	8f 5f       	subi	r24, 0xFF	; 255
    288a:	80 93 40 06 	sts	0x0640, r24
		if( pxCurrentTCB == NULL )
    288e:	80 91 3d 06 	lds	r24, 0x063D
    2892:	90 91 3e 06 	lds	r25, 0x063E
    2896:	00 97       	sbiw	r24, 0x00	; 0
    2898:	69 f4       	brne	.+26     	; 0x28b4 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	9a 81       	ldd	r25, Y+2	; 0x02
    289e:	90 93 3e 06 	sts	0x063E, r25
    28a2:	80 93 3d 06 	sts	0x063D, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    28a6:	80 91 40 06 	lds	r24, 0x0640
    28aa:	81 30       	cpi	r24, 0x01	; 1
    28ac:	b9 f4       	brne	.+46     	; 0x28dc <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    28ae:	0e 94 2d 1c 	call	0x385a	; 0x385a <prvInitialiseTaskLists>
    28b2:	14 c0       	rjmp	.+40     	; 0x28dc <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    28b4:	80 91 44 06 	lds	r24, 0x0644
    28b8:	88 23       	and	r24, r24
    28ba:	81 f4       	brne	.+32     	; 0x28dc <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    28bc:	e0 91 3d 06 	lds	r30, 0x063D
    28c0:	f0 91 3e 06 	lds	r31, 0x063E
    28c4:	96 89       	ldd	r25, Z+22	; 0x16
    28c6:	e9 81       	ldd	r30, Y+1	; 0x01
    28c8:	fa 81       	ldd	r31, Y+2	; 0x02
    28ca:	86 89       	ldd	r24, Z+22	; 0x16
    28cc:	89 17       	cp	r24, r25
    28ce:	30 f0       	brcs	.+12     	; 0x28dc <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    28d0:	89 81       	ldd	r24, Y+1	; 0x01
    28d2:	9a 81       	ldd	r25, Y+2	; 0x02
    28d4:	90 93 3e 06 	sts	0x063E, r25
    28d8:	80 93 3d 06 	sts	0x063D, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    28dc:	80 91 48 06 	lds	r24, 0x0648
    28e0:	8f 5f       	subi	r24, 0xFF	; 255
    28e2:	80 93 48 06 	sts	0x0648, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    28e6:	e9 81       	ldd	r30, Y+1	; 0x01
    28e8:	fa 81       	ldd	r31, Y+2	; 0x02
    28ea:	96 89       	ldd	r25, Z+22	; 0x16
    28ec:	80 91 43 06 	lds	r24, 0x0643
    28f0:	89 17       	cp	r24, r25
    28f2:	28 f4       	brcc	.+10     	; 0x28fe <prvAddNewTaskToReadyList+0x8e>
    28f4:	e9 81       	ldd	r30, Y+1	; 0x01
    28f6:	fa 81       	ldd	r31, Y+2	; 0x02
    28f8:	86 89       	ldd	r24, Z+22	; 0x16
    28fa:	80 93 43 06 	sts	0x0643, r24
    28fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2900:	fa 81       	ldd	r31, Y+2	; 0x02
    2902:	86 89       	ldd	r24, Z+22	; 0x16
    2904:	28 2f       	mov	r18, r24
    2906:	30 e0       	ldi	r19, 0x00	; 0
    2908:	c9 01       	movw	r24, r18
    290a:	88 0f       	add	r24, r24
    290c:	99 1f       	adc	r25, r25
    290e:	88 0f       	add	r24, r24
    2910:	99 1f       	adc	r25, r25
    2912:	88 0f       	add	r24, r24
    2914:	99 1f       	adc	r25, r25
    2916:	82 0f       	add	r24, r18
    2918:	93 1f       	adc	r25, r19
    291a:	ac 01       	movw	r20, r24
    291c:	42 5b       	subi	r20, 0xB2	; 178
    291e:	59 4f       	sbci	r21, 0xF9	; 249
    2920:	89 81       	ldd	r24, Y+1	; 0x01
    2922:	9a 81       	ldd	r25, Y+2	; 0x02
    2924:	9c 01       	movw	r18, r24
    2926:	2e 5f       	subi	r18, 0xFE	; 254
    2928:	3f 4f       	sbci	r19, 0xFF	; 255
    292a:	ca 01       	movw	r24, r20
    292c:	b9 01       	movw	r22, r18
    292e:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    2932:	0f 90       	pop	r0
    2934:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    2936:	80 91 44 06 	lds	r24, 0x0644
    293a:	88 23       	and	r24, r24
    293c:	61 f0       	breq	.+24     	; 0x2956 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    293e:	e0 91 3d 06 	lds	r30, 0x063D
    2942:	f0 91 3e 06 	lds	r31, 0x063E
    2946:	96 89       	ldd	r25, Z+22	; 0x16
    2948:	e9 81       	ldd	r30, Y+1	; 0x01
    294a:	fa 81       	ldd	r31, Y+2	; 0x02
    294c:	86 89       	ldd	r24, Z+22	; 0x16
    294e:	98 17       	cp	r25, r24
    2950:	10 f4       	brcc	.+4      	; 0x2956 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    2952:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2956:	0f 90       	pop	r0
    2958:	0f 90       	pop	r0
    295a:	cf 91       	pop	r28
    295c:	df 91       	pop	r29
    295e:	08 95       	ret

00002960 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2960:	df 93       	push	r29
    2962:	cf 93       	push	r28
    2964:	00 d0       	rcall	.+0      	; 0x2966 <vTaskDelete+0x6>
    2966:	00 d0       	rcall	.+0      	; 0x2968 <vTaskDelete+0x8>
    2968:	00 d0       	rcall	.+0      	; 0x296a <vTaskDelete+0xa>
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
    296e:	9c 83       	std	Y+4, r25	; 0x04
    2970:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2972:	0f b6       	in	r0, 0x3f	; 63
    2974:	f8 94       	cli
    2976:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
    297a:	9c 81       	ldd	r25, Y+4	; 0x04
    297c:	00 97       	sbiw	r24, 0x00	; 0
    297e:	39 f4       	brne	.+14     	; 0x298e <vTaskDelete+0x2e>
    2980:	80 91 3d 06 	lds	r24, 0x063D
    2984:	90 91 3e 06 	lds	r25, 0x063E
    2988:	9e 83       	std	Y+6, r25	; 0x06
    298a:	8d 83       	std	Y+5, r24	; 0x05
    298c:	04 c0       	rjmp	.+8      	; 0x2996 <vTaskDelete+0x36>
    298e:	8b 81       	ldd	r24, Y+3	; 0x03
    2990:	9c 81       	ldd	r25, Y+4	; 0x04
    2992:	9e 83       	std	Y+6, r25	; 0x06
    2994:	8d 83       	std	Y+5, r24	; 0x05
    2996:	8d 81       	ldd	r24, Y+5	; 0x05
    2998:	9e 81       	ldd	r25, Y+6	; 0x06
    299a:	9a 83       	std	Y+2, r25	; 0x02
    299c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    299e:	89 81       	ldd	r24, Y+1	; 0x01
    29a0:	9a 81       	ldd	r25, Y+2	; 0x02
    29a2:	02 96       	adiw	r24, 0x02	; 2
    29a4:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    29a8:	e9 81       	ldd	r30, Y+1	; 0x01
    29aa:	fa 81       	ldd	r31, Y+2	; 0x02
    29ac:	84 89       	ldd	r24, Z+20	; 0x14
    29ae:	95 89       	ldd	r25, Z+21	; 0x15
    29b0:	00 97       	sbiw	r24, 0x00	; 0
    29b2:	29 f0       	breq	.+10     	; 0x29be <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    29b4:	89 81       	ldd	r24, Y+1	; 0x01
    29b6:	9a 81       	ldd	r25, Y+2	; 0x02
    29b8:	0c 96       	adiw	r24, 0x0c	; 12
    29ba:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    29be:	80 91 48 06 	lds	r24, 0x0648
    29c2:	8f 5f       	subi	r24, 0xFF	; 255
    29c4:	80 93 48 06 	sts	0x0648, r24

			if( pxTCB == pxCurrentTCB )
    29c8:	20 91 3d 06 	lds	r18, 0x063D
    29cc:	30 91 3e 06 	lds	r19, 0x063E
    29d0:	89 81       	ldd	r24, Y+1	; 0x01
    29d2:	9a 81       	ldd	r25, Y+2	; 0x02
    29d4:	82 17       	cp	r24, r18
    29d6:	93 07       	cpc	r25, r19
    29d8:	81 f4       	brne	.+32     	; 0x29fa <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    29da:	89 81       	ldd	r24, Y+1	; 0x01
    29dc:	9a 81       	ldd	r25, Y+2	; 0x02
    29de:	9c 01       	movw	r18, r24
    29e0:	2e 5f       	subi	r18, 0xFE	; 254
    29e2:	3f 4f       	sbci	r19, 0xFF	; 255
    29e4:	88 e8       	ldi	r24, 0x88	; 136
    29e6:	96 e0       	ldi	r25, 0x06	; 6
    29e8:	b9 01       	movw	r22, r18
    29ea:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    29ee:	80 91 3f 06 	lds	r24, 0x063F
    29f2:	8f 5f       	subi	r24, 0xFF	; 255
    29f4:	80 93 3f 06 	sts	0x063F, r24
    29f8:	0b c0       	rjmp	.+22     	; 0x2a10 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    29fa:	80 91 40 06 	lds	r24, 0x0640
    29fe:	81 50       	subi	r24, 0x01	; 1
    2a00:	80 93 40 06 	sts	0x0640, r24
				prvDeleteTCB( pxTCB );
    2a04:	89 81       	ldd	r24, Y+1	; 0x01
    2a06:	9a 81       	ldd	r25, Y+2	; 0x02
    2a08:	0e 94 ad 1c 	call	0x395a	; 0x395a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    2a0c:	0e 94 c3 1c 	call	0x3986	; 0x3986 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2a10:	0f 90       	pop	r0
    2a12:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2a14:	80 91 44 06 	lds	r24, 0x0644
    2a18:	88 23       	and	r24, r24
    2a1a:	59 f0       	breq	.+22     	; 0x2a32 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    2a1c:	20 91 3d 06 	lds	r18, 0x063D
    2a20:	30 91 3e 06 	lds	r19, 0x063E
    2a24:	89 81       	ldd	r24, Y+1	; 0x01
    2a26:	9a 81       	ldd	r25, Y+2	; 0x02
    2a28:	82 17       	cp	r24, r18
    2a2a:	93 07       	cpc	r25, r19
    2a2c:	11 f4       	brne	.+4      	; 0x2a32 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2a2e:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2a32:	26 96       	adiw	r28, 0x06	; 6
    2a34:	0f b6       	in	r0, 0x3f	; 63
    2a36:	f8 94       	cli
    2a38:	de bf       	out	0x3e, r29	; 62
    2a3a:	0f be       	out	0x3f, r0	; 63
    2a3c:	cd bf       	out	0x3d, r28	; 61
    2a3e:	cf 91       	pop	r28
    2a40:	df 91       	pop	r29
    2a42:	08 95       	ret

00002a44 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2a44:	df 93       	push	r29
    2a46:	cf 93       	push	r28
    2a48:	cd b7       	in	r28, 0x3d	; 61
    2a4a:	de b7       	in	r29, 0x3e	; 62
    2a4c:	2a 97       	sbiw	r28, 0x0a	; 10
    2a4e:	0f b6       	in	r0, 0x3f	; 63
    2a50:	f8 94       	cli
    2a52:	de bf       	out	0x3e, r29	; 62
    2a54:	0f be       	out	0x3f, r0	; 63
    2a56:	cd bf       	out	0x3d, r28	; 61
    2a58:	98 87       	std	Y+8, r25	; 0x08
    2a5a:	8f 83       	std	Y+7, r24	; 0x07
    2a5c:	7a 87       	std	Y+10, r23	; 0x0a
    2a5e:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2a60:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2a62:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2a66:	80 91 41 06 	lds	r24, 0x0641
    2a6a:	90 91 42 06 	lds	r25, 0x0642
    2a6e:	9a 83       	std	Y+2, r25	; 0x02
    2a70:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a72:	ef 81       	ldd	r30, Y+7	; 0x07
    2a74:	f8 85       	ldd	r31, Y+8	; 0x08
    2a76:	20 81       	ld	r18, Z
    2a78:	31 81       	ldd	r19, Z+1	; 0x01
    2a7a:	89 85       	ldd	r24, Y+9	; 0x09
    2a7c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a7e:	82 0f       	add	r24, r18
    2a80:	93 1f       	adc	r25, r19
    2a82:	9e 83       	std	Y+6, r25	; 0x06
    2a84:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2a86:	ef 81       	ldd	r30, Y+7	; 0x07
    2a88:	f8 85       	ldd	r31, Y+8	; 0x08
    2a8a:	20 81       	ld	r18, Z
    2a8c:	31 81       	ldd	r19, Z+1	; 0x01
    2a8e:	89 81       	ldd	r24, Y+1	; 0x01
    2a90:	9a 81       	ldd	r25, Y+2	; 0x02
    2a92:	82 17       	cp	r24, r18
    2a94:	93 07       	cpc	r25, r19
    2a96:	98 f4       	brcc	.+38     	; 0x2abe <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2a98:	ef 81       	ldd	r30, Y+7	; 0x07
    2a9a:	f8 85       	ldd	r31, Y+8	; 0x08
    2a9c:	20 81       	ld	r18, Z
    2a9e:	31 81       	ldd	r19, Z+1	; 0x01
    2aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    2aa4:	82 17       	cp	r24, r18
    2aa6:	93 07       	cpc	r25, r19
    2aa8:	e0 f4       	brcc	.+56     	; 0x2ae2 <vTaskDelayUntil+0x9e>
    2aaa:	2d 81       	ldd	r18, Y+5	; 0x05
    2aac:	3e 81       	ldd	r19, Y+6	; 0x06
    2aae:	89 81       	ldd	r24, Y+1	; 0x01
    2ab0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab2:	82 17       	cp	r24, r18
    2ab4:	93 07       	cpc	r25, r19
    2ab6:	a8 f4       	brcc	.+42     	; 0x2ae2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2ab8:	81 e0       	ldi	r24, 0x01	; 1
    2aba:	8b 83       	std	Y+3, r24	; 0x03
    2abc:	12 c0       	rjmp	.+36     	; 0x2ae2 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2abe:	ef 81       	ldd	r30, Y+7	; 0x07
    2ac0:	f8 85       	ldd	r31, Y+8	; 0x08
    2ac2:	20 81       	ld	r18, Z
    2ac4:	31 81       	ldd	r19, Z+1	; 0x01
    2ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ac8:	9e 81       	ldd	r25, Y+6	; 0x06
    2aca:	82 17       	cp	r24, r18
    2acc:	93 07       	cpc	r25, r19
    2ace:	38 f0       	brcs	.+14     	; 0x2ade <vTaskDelayUntil+0x9a>
    2ad0:	2d 81       	ldd	r18, Y+5	; 0x05
    2ad2:	3e 81       	ldd	r19, Y+6	; 0x06
    2ad4:	89 81       	ldd	r24, Y+1	; 0x01
    2ad6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad8:	82 17       	cp	r24, r18
    2ada:	93 07       	cpc	r25, r19
    2adc:	10 f4       	brcc	.+4      	; 0x2ae2 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2ade:	81 e0       	ldi	r24, 0x01	; 1
    2ae0:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ae2:	ef 81       	ldd	r30, Y+7	; 0x07
    2ae4:	f8 85       	ldd	r31, Y+8	; 0x08
    2ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    2aea:	91 83       	std	Z+1, r25	; 0x01
    2aec:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2aee:	8b 81       	ldd	r24, Y+3	; 0x03
    2af0:	88 23       	and	r24, r24
    2af2:	49 f0       	breq	.+18     	; 0x2b06 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2af4:	8d 81       	ldd	r24, Y+5	; 0x05
    2af6:	9e 81       	ldd	r25, Y+6	; 0x06
    2af8:	29 81       	ldd	r18, Y+1	; 0x01
    2afa:	3a 81       	ldd	r19, Y+2	; 0x02
    2afc:	82 1b       	sub	r24, r18
    2afe:	93 0b       	sbc	r25, r19
    2b00:	60 e0       	ldi	r22, 0x00	; 0
    2b02:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2b06:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
    2b0a:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b0c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b0e:	88 23       	and	r24, r24
    2b10:	11 f4       	brne	.+4      	; 0x2b16 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2b12:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b16:	2a 96       	adiw	r28, 0x0a	; 10
    2b18:	0f b6       	in	r0, 0x3f	; 63
    2b1a:	f8 94       	cli
    2b1c:	de bf       	out	0x3e, r29	; 62
    2b1e:	0f be       	out	0x3f, r0	; 63
    2b20:	cd bf       	out	0x3d, r28	; 61
    2b22:	cf 91       	pop	r28
    2b24:	df 91       	pop	r29
    2b26:	08 95       	ret

00002b28 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2b28:	df 93       	push	r29
    2b2a:	cf 93       	push	r28
    2b2c:	00 d0       	rcall	.+0      	; 0x2b2e <vTaskDelay+0x6>
    2b2e:	0f 92       	push	r0
    2b30:	cd b7       	in	r28, 0x3d	; 61
    2b32:	de b7       	in	r29, 0x3e	; 62
    2b34:	9b 83       	std	Y+3, r25	; 0x03
    2b36:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    2b38:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3e:	00 97       	sbiw	r24, 0x00	; 0
    2b40:	51 f0       	breq	.+20     	; 0x2b56 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2b42:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2b46:	8a 81       	ldd	r24, Y+2	; 0x02
    2b48:	9b 81       	ldd	r25, Y+3	; 0x03
    2b4a:	60 e0       	ldi	r22, 0x00	; 0
    2b4c:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b50:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>
    2b54:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b56:	89 81       	ldd	r24, Y+1	; 0x01
    2b58:	88 23       	and	r24, r24
    2b5a:	11 f4       	brne	.+4      	; 0x2b60 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    2b5c:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b60:	0f 90       	pop	r0
    2b62:	0f 90       	pop	r0
    2b64:	0f 90       	pop	r0
    2b66:	cf 91       	pop	r28
    2b68:	df 91       	pop	r29
    2b6a:	08 95       	ret

00002b6c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    2b6c:	df 93       	push	r29
    2b6e:	cf 93       	push	r28
    2b70:	cd b7       	in	r28, 0x3d	; 61
    2b72:	de b7       	in	r29, 0x3e	; 62
    2b74:	2a 97       	sbiw	r28, 0x0a	; 10
    2b76:	0f b6       	in	r0, 0x3f	; 63
    2b78:	f8 94       	cli
    2b7a:	de bf       	out	0x3e, r29	; 62
    2b7c:	0f be       	out	0x3f, r0	; 63
    2b7e:	cd bf       	out	0x3d, r28	; 61
    2b80:	9f 83       	std	Y+7, r25	; 0x07
    2b82:	8e 83       	std	Y+6, r24	; 0x06
    2b84:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    2b86:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2b88:	88 85       	ldd	r24, Y+8	; 0x08
    2b8a:	83 30       	cpi	r24, 0x03	; 3
    2b8c:	10 f0       	brcs	.+4      	; 0x2b92 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2b8e:	82 e0       	ldi	r24, 0x02	; 2
    2b90:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    2b92:	0f b6       	in	r0, 0x3f	; 63
    2b94:	f8 94       	cli
    2b96:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2b98:	8e 81       	ldd	r24, Y+6	; 0x06
    2b9a:	9f 81       	ldd	r25, Y+7	; 0x07
    2b9c:	00 97       	sbiw	r24, 0x00	; 0
    2b9e:	39 f4       	brne	.+14     	; 0x2bae <vTaskPrioritySet+0x42>
    2ba0:	80 91 3d 06 	lds	r24, 0x063D
    2ba4:	90 91 3e 06 	lds	r25, 0x063E
    2ba8:	9a 87       	std	Y+10, r25	; 0x0a
    2baa:	89 87       	std	Y+9, r24	; 0x09
    2bac:	04 c0       	rjmp	.+8      	; 0x2bb6 <vTaskPrioritySet+0x4a>
    2bae:	8e 81       	ldd	r24, Y+6	; 0x06
    2bb0:	9f 81       	ldd	r25, Y+7	; 0x07
    2bb2:	9a 87       	std	Y+10, r25	; 0x0a
    2bb4:	89 87       	std	Y+9, r24	; 0x09
    2bb6:	89 85       	ldd	r24, Y+9	; 0x09
    2bb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bba:	9d 83       	std	Y+5, r25	; 0x05
    2bbc:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    2bbe:	ec 81       	ldd	r30, Y+4	; 0x04
    2bc0:	fd 81       	ldd	r31, Y+5	; 0x05
    2bc2:	81 a5       	ldd	r24, Z+41	; 0x29
    2bc4:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    2bc6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bc8:	88 85       	ldd	r24, Y+8	; 0x08
    2bca:	98 17       	cp	r25, r24
    2bcc:	09 f4       	brne	.+2      	; 0x2bd0 <vTaskPrioritySet+0x64>
    2bce:	8d c0       	rjmp	.+282    	; 0x2cea <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    2bd0:	98 85       	ldd	r25, Y+8	; 0x08
    2bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd4:	89 17       	cp	r24, r25
    2bd6:	a0 f4       	brcc	.+40     	; 0x2c00 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    2bd8:	20 91 3d 06 	lds	r18, 0x063D
    2bdc:	30 91 3e 06 	lds	r19, 0x063E
    2be0:	8c 81       	ldd	r24, Y+4	; 0x04
    2be2:	9d 81       	ldd	r25, Y+5	; 0x05
    2be4:	82 17       	cp	r24, r18
    2be6:	93 07       	cpc	r25, r19
    2be8:	b1 f0       	breq	.+44     	; 0x2c16 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    2bea:	e0 91 3d 06 	lds	r30, 0x063D
    2bee:	f0 91 3e 06 	lds	r31, 0x063E
    2bf2:	96 89       	ldd	r25, Z+22	; 0x16
    2bf4:	88 85       	ldd	r24, Y+8	; 0x08
    2bf6:	89 17       	cp	r24, r25
    2bf8:	70 f0       	brcs	.+28     	; 0x2c16 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	89 83       	std	Y+1, r24	; 0x01
    2bfe:	0b c0       	rjmp	.+22     	; 0x2c16 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    2c00:	20 91 3d 06 	lds	r18, 0x063D
    2c04:	30 91 3e 06 	lds	r19, 0x063E
    2c08:	8c 81       	ldd	r24, Y+4	; 0x04
    2c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    2c0c:	82 17       	cp	r24, r18
    2c0e:	93 07       	cpc	r25, r19
    2c10:	11 f4       	brne	.+4      	; 0x2c16 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    2c12:	81 e0       	ldi	r24, 0x01	; 1
    2c14:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    2c16:	ec 81       	ldd	r30, Y+4	; 0x04
    2c18:	fd 81       	ldd	r31, Y+5	; 0x05
    2c1a:	86 89       	ldd	r24, Z+22	; 0x16
    2c1c:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    2c1e:	ec 81       	ldd	r30, Y+4	; 0x04
    2c20:	fd 81       	ldd	r31, Y+5	; 0x05
    2c22:	91 a5       	ldd	r25, Z+41	; 0x29
    2c24:	ec 81       	ldd	r30, Y+4	; 0x04
    2c26:	fd 81       	ldd	r31, Y+5	; 0x05
    2c28:	86 89       	ldd	r24, Z+22	; 0x16
    2c2a:	98 17       	cp	r25, r24
    2c2c:	21 f4       	brne	.+8      	; 0x2c36 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    2c2e:	ec 81       	ldd	r30, Y+4	; 0x04
    2c30:	fd 81       	ldd	r31, Y+5	; 0x05
    2c32:	88 85       	ldd	r24, Y+8	; 0x08
    2c34:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    2c36:	ec 81       	ldd	r30, Y+4	; 0x04
    2c38:	fd 81       	ldd	r31, Y+5	; 0x05
    2c3a:	88 85       	ldd	r24, Y+8	; 0x08
    2c3c:	81 a7       	std	Z+41, r24	; 0x29
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2c3e:	ec 81       	ldd	r30, Y+4	; 0x04
    2c40:	fd 81       	ldd	r31, Y+5	; 0x05
    2c42:	84 85       	ldd	r24, Z+12	; 0x0c
    2c44:	95 85       	ldd	r25, Z+13	; 0x0d
    2c46:	99 23       	and	r25, r25
    2c48:	5c f0       	brlt	.+22     	; 0x2c60 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c4a:	88 85       	ldd	r24, Y+8	; 0x08
    2c4c:	28 2f       	mov	r18, r24
    2c4e:	30 e0       	ldi	r19, 0x00	; 0
    2c50:	83 e0       	ldi	r24, 0x03	; 3
    2c52:	90 e0       	ldi	r25, 0x00	; 0
    2c54:	82 1b       	sub	r24, r18
    2c56:	93 0b       	sbc	r25, r19
    2c58:	ec 81       	ldd	r30, Y+4	; 0x04
    2c5a:	fd 81       	ldd	r31, Y+5	; 0x05
    2c5c:	95 87       	std	Z+13, r25	; 0x0d
    2c5e:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2c60:	ec 81       	ldd	r30, Y+4	; 0x04
    2c62:	fd 81       	ldd	r31, Y+5	; 0x05
    2c64:	42 85       	ldd	r20, Z+10	; 0x0a
    2c66:	53 85       	ldd	r21, Z+11	; 0x0b
    2c68:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6a:	28 2f       	mov	r18, r24
    2c6c:	30 e0       	ldi	r19, 0x00	; 0
    2c6e:	c9 01       	movw	r24, r18
    2c70:	88 0f       	add	r24, r24
    2c72:	99 1f       	adc	r25, r25
    2c74:	88 0f       	add	r24, r24
    2c76:	99 1f       	adc	r25, r25
    2c78:	88 0f       	add	r24, r24
    2c7a:	99 1f       	adc	r25, r25
    2c7c:	82 0f       	add	r24, r18
    2c7e:	93 1f       	adc	r25, r19
    2c80:	82 5b       	subi	r24, 0xB2	; 178
    2c82:	99 4f       	sbci	r25, 0xF9	; 249
    2c84:	48 17       	cp	r20, r24
    2c86:	59 07       	cpc	r21, r25
    2c88:	59 f5       	brne	.+86     	; 0x2ce0 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2c8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2c8e:	02 96       	adiw	r24, 0x02	; 2
    2c90:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    2c94:	ec 81       	ldd	r30, Y+4	; 0x04
    2c96:	fd 81       	ldd	r31, Y+5	; 0x05
    2c98:	96 89       	ldd	r25, Z+22	; 0x16
    2c9a:	80 91 43 06 	lds	r24, 0x0643
    2c9e:	89 17       	cp	r24, r25
    2ca0:	28 f4       	brcc	.+10     	; 0x2cac <vTaskPrioritySet+0x140>
    2ca2:	ec 81       	ldd	r30, Y+4	; 0x04
    2ca4:	fd 81       	ldd	r31, Y+5	; 0x05
    2ca6:	86 89       	ldd	r24, Z+22	; 0x16
    2ca8:	80 93 43 06 	sts	0x0643, r24
    2cac:	ec 81       	ldd	r30, Y+4	; 0x04
    2cae:	fd 81       	ldd	r31, Y+5	; 0x05
    2cb0:	86 89       	ldd	r24, Z+22	; 0x16
    2cb2:	28 2f       	mov	r18, r24
    2cb4:	30 e0       	ldi	r19, 0x00	; 0
    2cb6:	c9 01       	movw	r24, r18
    2cb8:	88 0f       	add	r24, r24
    2cba:	99 1f       	adc	r25, r25
    2cbc:	88 0f       	add	r24, r24
    2cbe:	99 1f       	adc	r25, r25
    2cc0:	88 0f       	add	r24, r24
    2cc2:	99 1f       	adc	r25, r25
    2cc4:	82 0f       	add	r24, r18
    2cc6:	93 1f       	adc	r25, r19
    2cc8:	ac 01       	movw	r20, r24
    2cca:	42 5b       	subi	r20, 0xB2	; 178
    2ccc:	59 4f       	sbci	r21, 0xF9	; 249
    2cce:	8c 81       	ldd	r24, Y+4	; 0x04
    2cd0:	9d 81       	ldd	r25, Y+5	; 0x05
    2cd2:	9c 01       	movw	r18, r24
    2cd4:	2e 5f       	subi	r18, 0xFE	; 254
    2cd6:	3f 4f       	sbci	r19, 0xFF	; 255
    2cd8:	ca 01       	movw	r24, r20
    2cda:	b9 01       	movw	r22, r18
    2cdc:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    2ce0:	89 81       	ldd	r24, Y+1	; 0x01
    2ce2:	88 23       	and	r24, r24
    2ce4:	11 f0       	breq	.+4      	; 0x2cea <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    2ce6:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    2cea:	0f 90       	pop	r0
    2cec:	0f be       	out	0x3f, r0	; 63
	}
    2cee:	2a 96       	adiw	r28, 0x0a	; 10
    2cf0:	0f b6       	in	r0, 0x3f	; 63
    2cf2:	f8 94       	cli
    2cf4:	de bf       	out	0x3e, r29	; 62
    2cf6:	0f be       	out	0x3f, r0	; 63
    2cf8:	cd bf       	out	0x3d, r28	; 61
    2cfa:	cf 91       	pop	r28
    2cfc:	df 91       	pop	r29
    2cfe:	08 95       	ret

00002d00 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    2d00:	df 93       	push	r29
    2d02:	cf 93       	push	r28
    2d04:	00 d0       	rcall	.+0      	; 0x2d06 <vTaskSuspend+0x6>
    2d06:	00 d0       	rcall	.+0      	; 0x2d08 <vTaskSuspend+0x8>
    2d08:	00 d0       	rcall	.+0      	; 0x2d0a <vTaskSuspend+0xa>
    2d0a:	cd b7       	in	r28, 0x3d	; 61
    2d0c:	de b7       	in	r29, 0x3e	; 62
    2d0e:	9c 83       	std	Y+4, r25	; 0x04
    2d10:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2d12:	0f b6       	in	r0, 0x3f	; 63
    2d14:	f8 94       	cli
    2d16:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    2d18:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1c:	00 97       	sbiw	r24, 0x00	; 0
    2d1e:	39 f4       	brne	.+14     	; 0x2d2e <vTaskSuspend+0x2e>
    2d20:	80 91 3d 06 	lds	r24, 0x063D
    2d24:	90 91 3e 06 	lds	r25, 0x063E
    2d28:	9e 83       	std	Y+6, r25	; 0x06
    2d2a:	8d 83       	std	Y+5, r24	; 0x05
    2d2c:	04 c0       	rjmp	.+8      	; 0x2d36 <vTaskSuspend+0x36>
    2d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d30:	9c 81       	ldd	r25, Y+4	; 0x04
    2d32:	9e 83       	std	Y+6, r25	; 0x06
    2d34:	8d 83       	std	Y+5, r24	; 0x05
    2d36:	8d 81       	ldd	r24, Y+5	; 0x05
    2d38:	9e 81       	ldd	r25, Y+6	; 0x06
    2d3a:	9a 83       	std	Y+2, r25	; 0x02
    2d3c:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2d3e:	89 81       	ldd	r24, Y+1	; 0x01
    2d40:	9a 81       	ldd	r25, Y+2	; 0x02
    2d42:	02 96       	adiw	r24, 0x02	; 2
    2d44:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2d48:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4c:	84 89       	ldd	r24, Z+20	; 0x14
    2d4e:	95 89       	ldd	r25, Z+21	; 0x15
    2d50:	00 97       	sbiw	r24, 0x00	; 0
    2d52:	29 f0       	breq	.+10     	; 0x2d5e <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2d54:	89 81       	ldd	r24, Y+1	; 0x01
    2d56:	9a 81       	ldd	r25, Y+2	; 0x02
    2d58:	0c 96       	adiw	r24, 0x0c	; 12
    2d5a:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    2d5e:	89 81       	ldd	r24, Y+1	; 0x01
    2d60:	9a 81       	ldd	r25, Y+2	; 0x02
    2d62:	9c 01       	movw	r18, r24
    2d64:	2e 5f       	subi	r18, 0xFE	; 254
    2d66:	3f 4f       	sbci	r19, 0xFF	; 255
    2d68:	81 e9       	ldi	r24, 0x91	; 145
    2d6a:	96 e0       	ldi	r25, 0x06	; 6
    2d6c:	b9 01       	movw	r22, r18
    2d6e:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2d72:	0f 90       	pop	r0
    2d74:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    2d76:	80 91 44 06 	lds	r24, 0x0644
    2d7a:	88 23       	and	r24, r24
    2d7c:	39 f0       	breq	.+14     	; 0x2d8c <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    2d7e:	0f b6       	in	r0, 0x3f	; 63
    2d80:	f8 94       	cli
    2d82:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    2d84:	0e 94 c3 1c 	call	0x3986	; 0x3986 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    2d88:	0f 90       	pop	r0
    2d8a:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    2d8c:	20 91 3d 06 	lds	r18, 0x063D
    2d90:	30 91 3e 06 	lds	r19, 0x063E
    2d94:	89 81       	ldd	r24, Y+1	; 0x01
    2d96:	9a 81       	ldd	r25, Y+2	; 0x02
    2d98:	82 17       	cp	r24, r18
    2d9a:	93 07       	cpc	r25, r19
    2d9c:	a1 f4       	brne	.+40     	; 0x2dc6 <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    2d9e:	80 91 44 06 	lds	r24, 0x0644
    2da2:	88 23       	and	r24, r24
    2da4:	19 f0       	breq	.+6      	; 0x2dac <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2da6:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
    2daa:	0d c0       	rjmp	.+26     	; 0x2dc6 <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2dac:	90 91 91 06 	lds	r25, 0x0691
    2db0:	80 91 40 06 	lds	r24, 0x0640
    2db4:	98 17       	cp	r25, r24
    2db6:	29 f4       	brne	.+10     	; 0x2dc2 <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2db8:	10 92 3e 06 	sts	0x063E, r1
    2dbc:	10 92 3d 06 	sts	0x063D, r1
    2dc0:	02 c0       	rjmp	.+4      	; 0x2dc6 <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    2dc2:	0e 94 04 1a 	call	0x3408	; 0x3408 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2dc6:	26 96       	adiw	r28, 0x06	; 6
    2dc8:	0f b6       	in	r0, 0x3f	; 63
    2dca:	f8 94       	cli
    2dcc:	de bf       	out	0x3e, r29	; 62
    2dce:	0f be       	out	0x3f, r0	; 63
    2dd0:	cd bf       	out	0x3d, r28	; 61
    2dd2:	cf 91       	pop	r28
    2dd4:	df 91       	pop	r29
    2dd6:	08 95       	ret

00002dd8 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    2dd8:	df 93       	push	r29
    2dda:	cf 93       	push	r28
    2ddc:	00 d0       	rcall	.+0      	; 0x2dde <prvTaskIsTaskSuspended+0x6>
    2dde:	00 d0       	rcall	.+0      	; 0x2de0 <prvTaskIsTaskSuspended+0x8>
    2de0:	0f 92       	push	r0
    2de2:	cd b7       	in	r28, 0x3d	; 61
    2de4:	de b7       	in	r29, 0x3e	; 62
    2de6:	9d 83       	std	Y+5, r25	; 0x05
    2de8:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    2dea:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    2dec:	8c 81       	ldd	r24, Y+4	; 0x04
    2dee:	9d 81       	ldd	r25, Y+5	; 0x05
    2df0:	9a 83       	std	Y+2, r25	; 0x02
    2df2:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    2df4:	e9 81       	ldd	r30, Y+1	; 0x01
    2df6:	fa 81       	ldd	r31, Y+2	; 0x02
    2df8:	82 85       	ldd	r24, Z+10	; 0x0a
    2dfa:	93 85       	ldd	r25, Z+11	; 0x0b
    2dfc:	26 e0       	ldi	r18, 0x06	; 6
    2dfe:	81 39       	cpi	r24, 0x91	; 145
    2e00:	92 07       	cpc	r25, r18
    2e02:	81 f4       	brne	.+32     	; 0x2e24 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    2e04:	e9 81       	ldd	r30, Y+1	; 0x01
    2e06:	fa 81       	ldd	r31, Y+2	; 0x02
    2e08:	84 89       	ldd	r24, Z+20	; 0x14
    2e0a:	95 89       	ldd	r25, Z+21	; 0x15
    2e0c:	26 e0       	ldi	r18, 0x06	; 6
    2e0e:	8f 37       	cpi	r24, 0x7F	; 127
    2e10:	92 07       	cpc	r25, r18
    2e12:	41 f0       	breq	.+16     	; 0x2e24 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    2e14:	e9 81       	ldd	r30, Y+1	; 0x01
    2e16:	fa 81       	ldd	r31, Y+2	; 0x02
    2e18:	84 89       	ldd	r24, Z+20	; 0x14
    2e1a:	95 89       	ldd	r25, Z+21	; 0x15
    2e1c:	00 97       	sbiw	r24, 0x00	; 0
    2e1e:	11 f4       	brne	.+4      	; 0x2e24 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    2e20:	81 e0       	ldi	r24, 0x01	; 1
    2e22:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    2e24:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    2e26:	0f 90       	pop	r0
    2e28:	0f 90       	pop	r0
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	0f 90       	pop	r0
    2e30:	cf 91       	pop	r28
    2e32:	df 91       	pop	r29
    2e34:	08 95       	ret

00002e36 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    2e36:	df 93       	push	r29
    2e38:	cf 93       	push	r28
    2e3a:	00 d0       	rcall	.+0      	; 0x2e3c <vTaskResume+0x6>
    2e3c:	00 d0       	rcall	.+0      	; 0x2e3e <vTaskResume+0x8>
    2e3e:	cd b7       	in	r28, 0x3d	; 61
    2e40:	de b7       	in	r29, 0x3e	; 62
    2e42:	9c 83       	std	Y+4, r25	; 0x04
    2e44:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    2e46:	8b 81       	ldd	r24, Y+3	; 0x03
    2e48:	9c 81       	ldd	r25, Y+4	; 0x04
    2e4a:	9a 83       	std	Y+2, r25	; 0x02
    2e4c:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    2e4e:	89 81       	ldd	r24, Y+1	; 0x01
    2e50:	9a 81       	ldd	r25, Y+2	; 0x02
    2e52:	00 97       	sbiw	r24, 0x00	; 0
    2e54:	09 f4       	brne	.+2      	; 0x2e58 <vTaskResume+0x22>
    2e56:	4c c0       	rjmp	.+152    	; 0x2ef0 <vTaskResume+0xba>
    2e58:	20 91 3d 06 	lds	r18, 0x063D
    2e5c:	30 91 3e 06 	lds	r19, 0x063E
    2e60:	89 81       	ldd	r24, Y+1	; 0x01
    2e62:	9a 81       	ldd	r25, Y+2	; 0x02
    2e64:	82 17       	cp	r24, r18
    2e66:	93 07       	cpc	r25, r19
    2e68:	09 f4       	brne	.+2      	; 0x2e6c <vTaskResume+0x36>
    2e6a:	42 c0       	rjmp	.+132    	; 0x2ef0 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    2e6c:	0f b6       	in	r0, 0x3f	; 63
    2e6e:	f8 94       	cli
    2e70:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2e72:	89 81       	ldd	r24, Y+1	; 0x01
    2e74:	9a 81       	ldd	r25, Y+2	; 0x02
    2e76:	0e 94 ec 16 	call	0x2dd8	; 0x2dd8 <prvTaskIsTaskSuspended>
    2e7a:	88 23       	and	r24, r24
    2e7c:	b9 f1       	breq	.+110    	; 0x2eec <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    2e7e:	89 81       	ldd	r24, Y+1	; 0x01
    2e80:	9a 81       	ldd	r25, Y+2	; 0x02
    2e82:	02 96       	adiw	r24, 0x02	; 2
    2e84:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2e88:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8c:	96 89       	ldd	r25, Z+22	; 0x16
    2e8e:	80 91 43 06 	lds	r24, 0x0643
    2e92:	89 17       	cp	r24, r25
    2e94:	28 f4       	brcc	.+10     	; 0x2ea0 <vTaskResume+0x6a>
    2e96:	e9 81       	ldd	r30, Y+1	; 0x01
    2e98:	fa 81       	ldd	r31, Y+2	; 0x02
    2e9a:	86 89       	ldd	r24, Z+22	; 0x16
    2e9c:	80 93 43 06 	sts	0x0643, r24
    2ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea4:	86 89       	ldd	r24, Z+22	; 0x16
    2ea6:	28 2f       	mov	r18, r24
    2ea8:	30 e0       	ldi	r19, 0x00	; 0
    2eaa:	c9 01       	movw	r24, r18
    2eac:	88 0f       	add	r24, r24
    2eae:	99 1f       	adc	r25, r25
    2eb0:	88 0f       	add	r24, r24
    2eb2:	99 1f       	adc	r25, r25
    2eb4:	88 0f       	add	r24, r24
    2eb6:	99 1f       	adc	r25, r25
    2eb8:	82 0f       	add	r24, r18
    2eba:	93 1f       	adc	r25, r19
    2ebc:	ac 01       	movw	r20, r24
    2ebe:	42 5b       	subi	r20, 0xB2	; 178
    2ec0:	59 4f       	sbci	r21, 0xF9	; 249
    2ec2:	89 81       	ldd	r24, Y+1	; 0x01
    2ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec6:	9c 01       	movw	r18, r24
    2ec8:	2e 5f       	subi	r18, 0xFE	; 254
    2eca:	3f 4f       	sbci	r19, 0xFF	; 255
    2ecc:	ca 01       	movw	r24, r20
    2ece:	b9 01       	movw	r22, r18
    2ed0:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed8:	96 89       	ldd	r25, Z+22	; 0x16
    2eda:	e0 91 3d 06 	lds	r30, 0x063D
    2ede:	f0 91 3e 06 	lds	r31, 0x063E
    2ee2:	86 89       	ldd	r24, Z+22	; 0x16
    2ee4:	98 17       	cp	r25, r24
    2ee6:	10 f0       	brcs	.+4      	; 0x2eec <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    2ee8:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2eec:	0f 90       	pop	r0
    2eee:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2ef0:	0f 90       	pop	r0
    2ef2:	0f 90       	pop	r0
    2ef4:	0f 90       	pop	r0
    2ef6:	0f 90       	pop	r0
    2ef8:	cf 91       	pop	r28
    2efa:	df 91       	pop	r29
    2efc:	08 95       	ret

00002efe <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    2efe:	df 93       	push	r29
    2f00:	cf 93       	push	r28
    2f02:	00 d0       	rcall	.+0      	; 0x2f04 <xTaskResumeFromISR+0x6>
    2f04:	00 d0       	rcall	.+0      	; 0x2f06 <xTaskResumeFromISR+0x8>
    2f06:	00 d0       	rcall	.+0      	; 0x2f08 <xTaskResumeFromISR+0xa>
    2f08:	cd b7       	in	r28, 0x3d	; 61
    2f0a:	de b7       	in	r29, 0x3e	; 62
    2f0c:	9e 83       	std	Y+6, r25	; 0x06
    2f0e:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    2f10:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    2f12:	8d 81       	ldd	r24, Y+5	; 0x05
    2f14:	9e 81       	ldd	r25, Y+6	; 0x06
    2f16:	9b 83       	std	Y+3, r25	; 0x03
    2f18:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2f1a:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    2f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f20:	0e 94 ec 16 	call	0x2dd8	; 0x2dd8 <prvTaskIsTaskSuspended>
    2f24:	88 23       	and	r24, r24
    2f26:	09 f4       	brne	.+2      	; 0x2f2a <xTaskResumeFromISR+0x2c>
    2f28:	46 c0       	rjmp	.+140    	; 0x2fb6 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f2a:	80 91 4d 06 	lds	r24, 0x064D
    2f2e:	88 23       	and	r24, r24
    2f30:	c1 f5       	brne	.+112    	; 0x2fa2 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2f32:	ea 81       	ldd	r30, Y+2	; 0x02
    2f34:	fb 81       	ldd	r31, Y+3	; 0x03
    2f36:	96 89       	ldd	r25, Z+22	; 0x16
    2f38:	e0 91 3d 06 	lds	r30, 0x063D
    2f3c:	f0 91 3e 06 	lds	r31, 0x063E
    2f40:	86 89       	ldd	r24, Z+22	; 0x16
    2f42:	98 17       	cp	r25, r24
    2f44:	10 f0       	brcs	.+4      	; 0x2f4a <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2f4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f4e:	02 96       	adiw	r24, 0x02	; 2
    2f50:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2f54:	ea 81       	ldd	r30, Y+2	; 0x02
    2f56:	fb 81       	ldd	r31, Y+3	; 0x03
    2f58:	96 89       	ldd	r25, Z+22	; 0x16
    2f5a:	80 91 43 06 	lds	r24, 0x0643
    2f5e:	89 17       	cp	r24, r25
    2f60:	28 f4       	brcc	.+10     	; 0x2f6c <xTaskResumeFromISR+0x6e>
    2f62:	ea 81       	ldd	r30, Y+2	; 0x02
    2f64:	fb 81       	ldd	r31, Y+3	; 0x03
    2f66:	86 89       	ldd	r24, Z+22	; 0x16
    2f68:	80 93 43 06 	sts	0x0643, r24
    2f6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2f6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2f70:	86 89       	ldd	r24, Z+22	; 0x16
    2f72:	28 2f       	mov	r18, r24
    2f74:	30 e0       	ldi	r19, 0x00	; 0
    2f76:	c9 01       	movw	r24, r18
    2f78:	88 0f       	add	r24, r24
    2f7a:	99 1f       	adc	r25, r25
    2f7c:	88 0f       	add	r24, r24
    2f7e:	99 1f       	adc	r25, r25
    2f80:	88 0f       	add	r24, r24
    2f82:	99 1f       	adc	r25, r25
    2f84:	82 0f       	add	r24, r18
    2f86:	93 1f       	adc	r25, r19
    2f88:	ac 01       	movw	r20, r24
    2f8a:	42 5b       	subi	r20, 0xB2	; 178
    2f8c:	59 4f       	sbci	r21, 0xF9	; 249
    2f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f90:	9b 81       	ldd	r25, Y+3	; 0x03
    2f92:	9c 01       	movw	r18, r24
    2f94:	2e 5f       	subi	r18, 0xFE	; 254
    2f96:	3f 4f       	sbci	r19, 0xFF	; 255
    2f98:	ca 01       	movw	r24, r20
    2f9a:	b9 01       	movw	r22, r18
    2f9c:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    2fa0:	0a c0       	rjmp	.+20     	; 0x2fb6 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2fa2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa4:	9b 81       	ldd	r25, Y+3	; 0x03
    2fa6:	9c 01       	movw	r18, r24
    2fa8:	24 5f       	subi	r18, 0xF4	; 244
    2faa:	3f 4f       	sbci	r19, 0xFF	; 255
    2fac:	8f e7       	ldi	r24, 0x7F	; 127
    2fae:	96 e0       	ldi	r25, 0x06	; 6
    2fb0:	b9 01       	movw	r22, r18
    2fb2:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    2fb6:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    2fb8:	26 96       	adiw	r28, 0x06	; 6
    2fba:	0f b6       	in	r0, 0x3f	; 63
    2fbc:	f8 94       	cli
    2fbe:	de bf       	out	0x3e, r29	; 62
    2fc0:	0f be       	out	0x3f, r0	; 63
    2fc2:	cd bf       	out	0x3d, r28	; 61
    2fc4:	cf 91       	pop	r28
    2fc6:	df 91       	pop	r29
    2fc8:	08 95       	ret

00002fca <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2fca:	ef 92       	push	r14
    2fcc:	ff 92       	push	r15
    2fce:	0f 93       	push	r16
    2fd0:	df 93       	push	r29
    2fd2:	cf 93       	push	r28
    2fd4:	0f 92       	push	r0
    2fd6:	cd b7       	in	r28, 0x3d	; 61
    2fd8:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2fda:	83 e2       	ldi	r24, 0x23	; 35
    2fdc:	9c e1       	ldi	r25, 0x1C	; 28
    2fde:	20 e6       	ldi	r18, 0x60	; 96
    2fe0:	30 e0       	ldi	r19, 0x00	; 0
    2fe2:	eb e4       	ldi	r30, 0x4B	; 75
    2fe4:	f6 e0       	ldi	r31, 0x06	; 6
    2fe6:	b9 01       	movw	r22, r18
    2fe8:	48 ec       	ldi	r20, 0xC8	; 200
    2fea:	50 e0       	ldi	r21, 0x00	; 0
    2fec:	20 e0       	ldi	r18, 0x00	; 0
    2fee:	30 e0       	ldi	r19, 0x00	; 0
    2ff0:	00 e0       	ldi	r16, 0x00	; 0
    2ff2:	7f 01       	movw	r14, r30
    2ff4:	0e 94 05 13 	call	0x260a	; 0x260a <xTaskCreate>
    2ff8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2ffa:	89 81       	ldd	r24, Y+1	; 0x01
    2ffc:	81 30       	cpi	r24, 0x01	; 1
    2ffe:	81 f4       	brne	.+32     	; 0x3020 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3000:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3002:	8f ef       	ldi	r24, 0xFF	; 255
    3004:	9f ef       	ldi	r25, 0xFF	; 255
    3006:	90 93 4a 06 	sts	0x064A, r25
    300a:	80 93 49 06 	sts	0x0649, r24
		xSchedulerRunning = pdTRUE;
    300e:	81 e0       	ldi	r24, 0x01	; 1
    3010:	80 93 44 06 	sts	0x0644, r24
		xTickCount = ( TickType_t ) 0U;
    3014:	10 92 42 06 	sts	0x0642, r1
    3018:	10 92 41 06 	sts	0x0641, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    301c:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    3020:	0f 90       	pop	r0
    3022:	cf 91       	pop	r28
    3024:	df 91       	pop	r29
    3026:	0f 91       	pop	r16
    3028:	ff 90       	pop	r15
    302a:	ef 90       	pop	r14
    302c:	08 95       	ret

0000302e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    302e:	df 93       	push	r29
    3030:	cf 93       	push	r28
    3032:	cd b7       	in	r28, 0x3d	; 61
    3034:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3036:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3038:	10 92 44 06 	sts	0x0644, r1
	vPortEndScheduler();
    303c:	0e 94 a1 0b 	call	0x1742	; 0x1742 <vPortEndScheduler>
}
    3040:	cf 91       	pop	r28
    3042:	df 91       	pop	r29
    3044:	08 95       	ret

00003046 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3046:	df 93       	push	r29
    3048:	cf 93       	push	r28
    304a:	cd b7       	in	r28, 0x3d	; 61
    304c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    304e:	80 91 4d 06 	lds	r24, 0x064D
    3052:	8f 5f       	subi	r24, 0xFF	; 255
    3054:	80 93 4d 06 	sts	0x064D, r24
}
    3058:	cf 91       	pop	r28
    305a:	df 91       	pop	r29
    305c:	08 95       	ret

0000305e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    305e:	df 93       	push	r29
    3060:	cf 93       	push	r28
    3062:	00 d0       	rcall	.+0      	; 0x3064 <xTaskResumeAll+0x6>
    3064:	00 d0       	rcall	.+0      	; 0x3066 <xTaskResumeAll+0x8>
    3066:	cd b7       	in	r28, 0x3d	; 61
    3068:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    306a:	1c 82       	std	Y+4, r1	; 0x04
    306c:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    306e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3070:	0f b6       	in	r0, 0x3f	; 63
    3072:	f8 94       	cli
    3074:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3076:	80 91 4d 06 	lds	r24, 0x064D
    307a:	81 50       	subi	r24, 0x01	; 1
    307c:	80 93 4d 06 	sts	0x064D, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3080:	80 91 4d 06 	lds	r24, 0x064D
    3084:	88 23       	and	r24, r24
    3086:	09 f0       	breq	.+2      	; 0x308a <xTaskResumeAll+0x2c>
    3088:	73 c0       	rjmp	.+230    	; 0x3170 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    308a:	80 91 40 06 	lds	r24, 0x0640
    308e:	88 23       	and	r24, r24
    3090:	09 f4       	brne	.+2      	; 0x3094 <xTaskResumeAll+0x36>
    3092:	6e c0       	rjmp	.+220    	; 0x3170 <xTaskResumeAll+0x112>
    3094:	45 c0       	rjmp	.+138    	; 0x3120 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3096:	e0 91 84 06 	lds	r30, 0x0684
    309a:	f0 91 85 06 	lds	r31, 0x0685
    309e:	86 81       	ldd	r24, Z+6	; 0x06
    30a0:	97 81       	ldd	r25, Z+7	; 0x07
    30a2:	9c 83       	std	Y+4, r25	; 0x04
    30a4:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    30a6:	8b 81       	ldd	r24, Y+3	; 0x03
    30a8:	9c 81       	ldd	r25, Y+4	; 0x04
    30aa:	0c 96       	adiw	r24, 0x0c	; 12
    30ac:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    30b0:	8b 81       	ldd	r24, Y+3	; 0x03
    30b2:	9c 81       	ldd	r25, Y+4	; 0x04
    30b4:	02 96       	adiw	r24, 0x02	; 2
    30b6:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    30ba:	eb 81       	ldd	r30, Y+3	; 0x03
    30bc:	fc 81       	ldd	r31, Y+4	; 0x04
    30be:	96 89       	ldd	r25, Z+22	; 0x16
    30c0:	80 91 43 06 	lds	r24, 0x0643
    30c4:	89 17       	cp	r24, r25
    30c6:	28 f4       	brcc	.+10     	; 0x30d2 <xTaskResumeAll+0x74>
    30c8:	eb 81       	ldd	r30, Y+3	; 0x03
    30ca:	fc 81       	ldd	r31, Y+4	; 0x04
    30cc:	86 89       	ldd	r24, Z+22	; 0x16
    30ce:	80 93 43 06 	sts	0x0643, r24
    30d2:	eb 81       	ldd	r30, Y+3	; 0x03
    30d4:	fc 81       	ldd	r31, Y+4	; 0x04
    30d6:	86 89       	ldd	r24, Z+22	; 0x16
    30d8:	28 2f       	mov	r18, r24
    30da:	30 e0       	ldi	r19, 0x00	; 0
    30dc:	c9 01       	movw	r24, r18
    30de:	88 0f       	add	r24, r24
    30e0:	99 1f       	adc	r25, r25
    30e2:	88 0f       	add	r24, r24
    30e4:	99 1f       	adc	r25, r25
    30e6:	88 0f       	add	r24, r24
    30e8:	99 1f       	adc	r25, r25
    30ea:	82 0f       	add	r24, r18
    30ec:	93 1f       	adc	r25, r19
    30ee:	ac 01       	movw	r20, r24
    30f0:	42 5b       	subi	r20, 0xB2	; 178
    30f2:	59 4f       	sbci	r21, 0xF9	; 249
    30f4:	8b 81       	ldd	r24, Y+3	; 0x03
    30f6:	9c 81       	ldd	r25, Y+4	; 0x04
    30f8:	9c 01       	movw	r18, r24
    30fa:	2e 5f       	subi	r18, 0xFE	; 254
    30fc:	3f 4f       	sbci	r19, 0xFF	; 255
    30fe:	ca 01       	movw	r24, r20
    3100:	b9 01       	movw	r22, r18
    3102:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3106:	eb 81       	ldd	r30, Y+3	; 0x03
    3108:	fc 81       	ldd	r31, Y+4	; 0x04
    310a:	96 89       	ldd	r25, Z+22	; 0x16
    310c:	e0 91 3d 06 	lds	r30, 0x063D
    3110:	f0 91 3e 06 	lds	r31, 0x063E
    3114:	86 89       	ldd	r24, Z+22	; 0x16
    3116:	98 17       	cp	r25, r24
    3118:	18 f0       	brcs	.+6      	; 0x3120 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    311a:	81 e0       	ldi	r24, 0x01	; 1
    311c:	80 93 46 06 	sts	0x0646, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3120:	80 91 7f 06 	lds	r24, 0x067F
    3124:	88 23       	and	r24, r24
    3126:	09 f0       	breq	.+2      	; 0x312a <xTaskResumeAll+0xcc>
    3128:	b6 cf       	rjmp	.-148    	; 0x3096 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    312a:	8b 81       	ldd	r24, Y+3	; 0x03
    312c:	9c 81       	ldd	r25, Y+4	; 0x04
    312e:	00 97       	sbiw	r24, 0x00	; 0
    3130:	11 f0       	breq	.+4      	; 0x3136 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    3132:	0e 94 c3 1c 	call	0x3986	; 0x3986 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    3136:	80 91 45 06 	lds	r24, 0x0645
    313a:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    313c:	89 81       	ldd	r24, Y+1	; 0x01
    313e:	88 23       	and	r24, r24
    3140:	79 f0       	breq	.+30     	; 0x3160 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3142:	0e 94 1f 19 	call	0x323e	; 0x323e <xTaskIncrementTick>
    3146:	88 23       	and	r24, r24
    3148:	19 f0       	breq	.+6      	; 0x3150 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    314a:	81 e0       	ldi	r24, 0x01	; 1
    314c:	80 93 46 06 	sts	0x0646, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    3150:	89 81       	ldd	r24, Y+1	; 0x01
    3152:	81 50       	subi	r24, 0x01	; 1
    3154:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    3156:	89 81       	ldd	r24, Y+1	; 0x01
    3158:	88 23       	and	r24, r24
    315a:	99 f7       	brne	.-26     	; 0x3142 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    315c:	10 92 45 06 	sts	0x0645, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    3160:	80 91 46 06 	lds	r24, 0x0646
    3164:	88 23       	and	r24, r24
    3166:	21 f0       	breq	.+8      	; 0x3170 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    316c:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3170:	0f 90       	pop	r0
    3172:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3174:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3176:	0f 90       	pop	r0
    3178:	0f 90       	pop	r0
    317a:	0f 90       	pop	r0
    317c:	0f 90       	pop	r0
    317e:	cf 91       	pop	r28
    3180:	df 91       	pop	r29
    3182:	08 95       	ret

00003184 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3184:	df 93       	push	r29
    3186:	cf 93       	push	r28
    3188:	00 d0       	rcall	.+0      	; 0x318a <xTaskGetTickCount+0x6>
    318a:	cd b7       	in	r28, 0x3d	; 61
    318c:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    318e:	0f b6       	in	r0, 0x3f	; 63
    3190:	f8 94       	cli
    3192:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3194:	80 91 41 06 	lds	r24, 0x0641
    3198:	90 91 42 06 	lds	r25, 0x0642
    319c:	9a 83       	std	Y+2, r25	; 0x02
    319e:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    31a0:	0f 90       	pop	r0
    31a2:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    31a4:	89 81       	ldd	r24, Y+1	; 0x01
    31a6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31a8:	0f 90       	pop	r0
    31aa:	0f 90       	pop	r0
    31ac:	cf 91       	pop	r28
    31ae:	df 91       	pop	r29
    31b0:	08 95       	ret

000031b2 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    31b2:	df 93       	push	r29
    31b4:	cf 93       	push	r28
    31b6:	00 d0       	rcall	.+0      	; 0x31b8 <xTaskGetTickCountFromISR+0x6>
    31b8:	0f 92       	push	r0
    31ba:	cd b7       	in	r28, 0x3d	; 61
    31bc:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    31be:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    31c0:	80 91 41 06 	lds	r24, 0x0641
    31c4:	90 91 42 06 	lds	r25, 0x0642
    31c8:	9b 83       	std	Y+3, r25	; 0x03
    31ca:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    31cc:	8a 81       	ldd	r24, Y+2	; 0x02
    31ce:	9b 81       	ldd	r25, Y+3	; 0x03
}
    31d0:	0f 90       	pop	r0
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	cf 91       	pop	r28
    31d8:	df 91       	pop	r29
    31da:	08 95       	ret

000031dc <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    31dc:	df 93       	push	r29
    31de:	cf 93       	push	r28
    31e0:	cd b7       	in	r28, 0x3d	; 61
    31e2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    31e4:	80 91 40 06 	lds	r24, 0x0640
}
    31e8:	cf 91       	pop	r28
    31ea:	df 91       	pop	r29
    31ec:	08 95       	ret

000031ee <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    31ee:	df 93       	push	r29
    31f0:	cf 93       	push	r28
    31f2:	00 d0       	rcall	.+0      	; 0x31f4 <pcTaskGetName+0x6>
    31f4:	00 d0       	rcall	.+0      	; 0x31f6 <pcTaskGetName+0x8>
    31f6:	00 d0       	rcall	.+0      	; 0x31f8 <pcTaskGetName+0xa>
    31f8:	cd b7       	in	r28, 0x3d	; 61
    31fa:	de b7       	in	r29, 0x3e	; 62
    31fc:	9c 83       	std	Y+4, r25	; 0x04
    31fe:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3200:	8b 81       	ldd	r24, Y+3	; 0x03
    3202:	9c 81       	ldd	r25, Y+4	; 0x04
    3204:	00 97       	sbiw	r24, 0x00	; 0
    3206:	39 f4       	brne	.+14     	; 0x3216 <pcTaskGetName+0x28>
    3208:	80 91 3d 06 	lds	r24, 0x063D
    320c:	90 91 3e 06 	lds	r25, 0x063E
    3210:	9e 83       	std	Y+6, r25	; 0x06
    3212:	8d 83       	std	Y+5, r24	; 0x05
    3214:	04 c0       	rjmp	.+8      	; 0x321e <pcTaskGetName+0x30>
    3216:	8b 81       	ldd	r24, Y+3	; 0x03
    3218:	9c 81       	ldd	r25, Y+4	; 0x04
    321a:	9e 83       	std	Y+6, r25	; 0x06
    321c:	8d 83       	std	Y+5, r24	; 0x05
    321e:	8d 81       	ldd	r24, Y+5	; 0x05
    3220:	9e 81       	ldd	r25, Y+6	; 0x06
    3222:	9a 83       	std	Y+2, r25	; 0x02
    3224:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    3226:	89 81       	ldd	r24, Y+1	; 0x01
    3228:	9a 81       	ldd	r25, Y+2	; 0x02
    322a:	49 96       	adiw	r24, 0x19	; 25
}
    322c:	26 96       	adiw	r28, 0x06	; 6
    322e:	0f b6       	in	r0, 0x3f	; 63
    3230:	f8 94       	cli
    3232:	de bf       	out	0x3e, r29	; 62
    3234:	0f be       	out	0x3f, r0	; 63
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	cf 91       	pop	r28
    323a:	df 91       	pop	r29
    323c:	08 95       	ret

0000323e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    323e:	df 93       	push	r29
    3240:	cf 93       	push	r28
    3242:	cd b7       	in	r28, 0x3d	; 61
    3244:	de b7       	in	r29, 0x3e	; 62
    3246:	29 97       	sbiw	r28, 0x09	; 9
    3248:	0f b6       	in	r0, 0x3f	; 63
    324a:	f8 94       	cli
    324c:	de bf       	out	0x3e, r29	; 62
    324e:	0f be       	out	0x3f, r0	; 63
    3250:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3252:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3254:	80 91 4d 06 	lds	r24, 0x064D
    3258:	88 23       	and	r24, r24
    325a:	09 f0       	breq	.+2      	; 0x325e <xTaskIncrementTick+0x20>
    325c:	c0 c0       	rjmp	.+384    	; 0x33de <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    325e:	80 91 41 06 	lds	r24, 0x0641
    3262:	90 91 42 06 	lds	r25, 0x0642
    3266:	01 96       	adiw	r24, 0x01	; 1
    3268:	9c 83       	std	Y+4, r25	; 0x04
    326a:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    326c:	8b 81       	ldd	r24, Y+3	; 0x03
    326e:	9c 81       	ldd	r25, Y+4	; 0x04
    3270:	90 93 42 06 	sts	0x0642, r25
    3274:	80 93 41 06 	sts	0x0641, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    3278:	8b 81       	ldd	r24, Y+3	; 0x03
    327a:	9c 81       	ldd	r25, Y+4	; 0x04
    327c:	00 97       	sbiw	r24, 0x00	; 0
    327e:	d9 f4       	brne	.+54     	; 0x32b6 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    3280:	80 91 7b 06 	lds	r24, 0x067B
    3284:	90 91 7c 06 	lds	r25, 0x067C
    3288:	9a 83       	std	Y+2, r25	; 0x02
    328a:	89 83       	std	Y+1, r24	; 0x01
    328c:	80 91 7d 06 	lds	r24, 0x067D
    3290:	90 91 7e 06 	lds	r25, 0x067E
    3294:	90 93 7c 06 	sts	0x067C, r25
    3298:	80 93 7b 06 	sts	0x067B, r24
    329c:	89 81       	ldd	r24, Y+1	; 0x01
    329e:	9a 81       	ldd	r25, Y+2	; 0x02
    32a0:	90 93 7e 06 	sts	0x067E, r25
    32a4:	80 93 7d 06 	sts	0x067D, r24
    32a8:	80 91 47 06 	lds	r24, 0x0647
    32ac:	8f 5f       	subi	r24, 0xFF	; 255
    32ae:	80 93 47 06 	sts	0x0647, r24
    32b2:	0e 94 c3 1c 	call	0x3986	; 0x3986 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    32b6:	20 91 49 06 	lds	r18, 0x0649
    32ba:	30 91 4a 06 	lds	r19, 0x064A
    32be:	8b 81       	ldd	r24, Y+3	; 0x03
    32c0:	9c 81       	ldd	r25, Y+4	; 0x04
    32c2:	82 17       	cp	r24, r18
    32c4:	93 07       	cpc	r25, r19
    32c6:	08 f4       	brcc	.+2      	; 0x32ca <xTaskIncrementTick+0x8c>
    32c8:	71 c0       	rjmp	.+226    	; 0x33ac <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    32ca:	e0 91 7b 06 	lds	r30, 0x067B
    32ce:	f0 91 7c 06 	lds	r31, 0x067C
    32d2:	80 81       	ld	r24, Z
    32d4:	88 23       	and	r24, r24
    32d6:	39 f4       	brne	.+14     	; 0x32e6 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    32d8:	8f ef       	ldi	r24, 0xFF	; 255
    32da:	9f ef       	ldi	r25, 0xFF	; 255
    32dc:	90 93 4a 06 	sts	0x064A, r25
    32e0:	80 93 49 06 	sts	0x0649, r24
    32e4:	63 c0       	rjmp	.+198    	; 0x33ac <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    32e6:	e0 91 7b 06 	lds	r30, 0x067B
    32ea:	f0 91 7c 06 	lds	r31, 0x067C
    32ee:	05 80       	ldd	r0, Z+5	; 0x05
    32f0:	f6 81       	ldd	r31, Z+6	; 0x06
    32f2:	e0 2d       	mov	r30, r0
    32f4:	86 81       	ldd	r24, Z+6	; 0x06
    32f6:	97 81       	ldd	r25, Z+7	; 0x07
    32f8:	99 87       	std	Y+9, r25	; 0x09
    32fa:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    32fc:	e8 85       	ldd	r30, Y+8	; 0x08
    32fe:	f9 85       	ldd	r31, Y+9	; 0x09
    3300:	82 81       	ldd	r24, Z+2	; 0x02
    3302:	93 81       	ldd	r25, Z+3	; 0x03
    3304:	9f 83       	std	Y+7, r25	; 0x07
    3306:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    3308:	2b 81       	ldd	r18, Y+3	; 0x03
    330a:	3c 81       	ldd	r19, Y+4	; 0x04
    330c:	8e 81       	ldd	r24, Y+6	; 0x06
    330e:	9f 81       	ldd	r25, Y+7	; 0x07
    3310:	28 17       	cp	r18, r24
    3312:	39 07       	cpc	r19, r25
    3314:	38 f4       	brcc	.+14     	; 0x3324 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3316:	8e 81       	ldd	r24, Y+6	; 0x06
    3318:	9f 81       	ldd	r25, Y+7	; 0x07
    331a:	90 93 4a 06 	sts	0x064A, r25
    331e:	80 93 49 06 	sts	0x0649, r24
    3322:	44 c0       	rjmp	.+136    	; 0x33ac <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3324:	88 85       	ldd	r24, Y+8	; 0x08
    3326:	99 85       	ldd	r25, Y+9	; 0x09
    3328:	02 96       	adiw	r24, 0x02	; 2
    332a:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    332e:	e8 85       	ldd	r30, Y+8	; 0x08
    3330:	f9 85       	ldd	r31, Y+9	; 0x09
    3332:	84 89       	ldd	r24, Z+20	; 0x14
    3334:	95 89       	ldd	r25, Z+21	; 0x15
    3336:	00 97       	sbiw	r24, 0x00	; 0
    3338:	29 f0       	breq	.+10     	; 0x3344 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    333a:	88 85       	ldd	r24, Y+8	; 0x08
    333c:	99 85       	ldd	r25, Y+9	; 0x09
    333e:	0c 96       	adiw	r24, 0x0c	; 12
    3340:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3344:	e8 85       	ldd	r30, Y+8	; 0x08
    3346:	f9 85       	ldd	r31, Y+9	; 0x09
    3348:	96 89       	ldd	r25, Z+22	; 0x16
    334a:	80 91 43 06 	lds	r24, 0x0643
    334e:	89 17       	cp	r24, r25
    3350:	28 f4       	brcc	.+10     	; 0x335c <xTaskIncrementTick+0x11e>
    3352:	e8 85       	ldd	r30, Y+8	; 0x08
    3354:	f9 85       	ldd	r31, Y+9	; 0x09
    3356:	86 89       	ldd	r24, Z+22	; 0x16
    3358:	80 93 43 06 	sts	0x0643, r24
    335c:	e8 85       	ldd	r30, Y+8	; 0x08
    335e:	f9 85       	ldd	r31, Y+9	; 0x09
    3360:	86 89       	ldd	r24, Z+22	; 0x16
    3362:	28 2f       	mov	r18, r24
    3364:	30 e0       	ldi	r19, 0x00	; 0
    3366:	c9 01       	movw	r24, r18
    3368:	88 0f       	add	r24, r24
    336a:	99 1f       	adc	r25, r25
    336c:	88 0f       	add	r24, r24
    336e:	99 1f       	adc	r25, r25
    3370:	88 0f       	add	r24, r24
    3372:	99 1f       	adc	r25, r25
    3374:	82 0f       	add	r24, r18
    3376:	93 1f       	adc	r25, r19
    3378:	ac 01       	movw	r20, r24
    337a:	42 5b       	subi	r20, 0xB2	; 178
    337c:	59 4f       	sbci	r21, 0xF9	; 249
    337e:	88 85       	ldd	r24, Y+8	; 0x08
    3380:	99 85       	ldd	r25, Y+9	; 0x09
    3382:	9c 01       	movw	r18, r24
    3384:	2e 5f       	subi	r18, 0xFE	; 254
    3386:	3f 4f       	sbci	r19, 0xFF	; 255
    3388:	ca 01       	movw	r24, r20
    338a:	b9 01       	movw	r22, r18
    338c:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3390:	e8 85       	ldd	r30, Y+8	; 0x08
    3392:	f9 85       	ldd	r31, Y+9	; 0x09
    3394:	96 89       	ldd	r25, Z+22	; 0x16
    3396:	e0 91 3d 06 	lds	r30, 0x063D
    339a:	f0 91 3e 06 	lds	r31, 0x063E
    339e:	86 89       	ldd	r24, Z+22	; 0x16
    33a0:	98 17       	cp	r25, r24
    33a2:	08 f4       	brcc	.+2      	; 0x33a6 <xTaskIncrementTick+0x168>
    33a4:	92 cf       	rjmp	.-220    	; 0x32ca <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	8d 83       	std	Y+5, r24	; 0x05
    33aa:	8f cf       	rjmp	.-226    	; 0x32ca <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    33ac:	e0 91 3d 06 	lds	r30, 0x063D
    33b0:	f0 91 3e 06 	lds	r31, 0x063E
    33b4:	86 89       	ldd	r24, Z+22	; 0x16
    33b6:	28 2f       	mov	r18, r24
    33b8:	30 e0       	ldi	r19, 0x00	; 0
    33ba:	c9 01       	movw	r24, r18
    33bc:	88 0f       	add	r24, r24
    33be:	99 1f       	adc	r25, r25
    33c0:	88 0f       	add	r24, r24
    33c2:	99 1f       	adc	r25, r25
    33c4:	88 0f       	add	r24, r24
    33c6:	99 1f       	adc	r25, r25
    33c8:	82 0f       	add	r24, r18
    33ca:	93 1f       	adc	r25, r19
    33cc:	fc 01       	movw	r30, r24
    33ce:	e2 5b       	subi	r30, 0xB2	; 178
    33d0:	f9 4f       	sbci	r31, 0xF9	; 249
    33d2:	80 81       	ld	r24, Z
    33d4:	82 30       	cpi	r24, 0x02	; 2
    33d6:	40 f0       	brcs	.+16     	; 0x33e8 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    33d8:	81 e0       	ldi	r24, 0x01	; 1
    33da:	8d 83       	std	Y+5, r24	; 0x05
    33dc:	05 c0       	rjmp	.+10     	; 0x33e8 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    33de:	80 91 45 06 	lds	r24, 0x0645
    33e2:	8f 5f       	subi	r24, 0xFF	; 255
    33e4:	80 93 45 06 	sts	0x0645, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    33e8:	80 91 46 06 	lds	r24, 0x0646
    33ec:	88 23       	and	r24, r24
    33ee:	11 f0       	breq	.+4      	; 0x33f4 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    33f0:	81 e0       	ldi	r24, 0x01	; 1
    33f2:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    33f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    33f6:	29 96       	adiw	r28, 0x09	; 9
    33f8:	0f b6       	in	r0, 0x3f	; 63
    33fa:	f8 94       	cli
    33fc:	de bf       	out	0x3e, r29	; 62
    33fe:	0f be       	out	0x3f, r0	; 63
    3400:	cd bf       	out	0x3d, r28	; 61
    3402:	cf 91       	pop	r28
    3404:	df 91       	pop	r29
    3406:	08 95       	ret

00003408 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3408:	df 93       	push	r29
    340a:	cf 93       	push	r28
    340c:	00 d0       	rcall	.+0      	; 0x340e <vTaskSwitchContext+0x6>
    340e:	0f 92       	push	r0
    3410:	cd b7       	in	r28, 0x3d	; 61
    3412:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3414:	80 91 4d 06 	lds	r24, 0x064D
    3418:	88 23       	and	r24, r24
    341a:	21 f0       	breq	.+8      	; 0x3424 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    341c:	81 e0       	ldi	r24, 0x01	; 1
    341e:	80 93 46 06 	sts	0x0646, r24
    3422:	59 c0       	rjmp	.+178    	; 0x34d6 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3424:	10 92 46 06 	sts	0x0646, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3428:	80 91 43 06 	lds	r24, 0x0643
    342c:	8b 83       	std	Y+3, r24	; 0x03
    342e:	03 c0       	rjmp	.+6      	; 0x3436 <vTaskSwitchContext+0x2e>
    3430:	8b 81       	ldd	r24, Y+3	; 0x03
    3432:	81 50       	subi	r24, 0x01	; 1
    3434:	8b 83       	std	Y+3, r24	; 0x03
    3436:	8b 81       	ldd	r24, Y+3	; 0x03
    3438:	28 2f       	mov	r18, r24
    343a:	30 e0       	ldi	r19, 0x00	; 0
    343c:	c9 01       	movw	r24, r18
    343e:	88 0f       	add	r24, r24
    3440:	99 1f       	adc	r25, r25
    3442:	88 0f       	add	r24, r24
    3444:	99 1f       	adc	r25, r25
    3446:	88 0f       	add	r24, r24
    3448:	99 1f       	adc	r25, r25
    344a:	82 0f       	add	r24, r18
    344c:	93 1f       	adc	r25, r19
    344e:	fc 01       	movw	r30, r24
    3450:	e2 5b       	subi	r30, 0xB2	; 178
    3452:	f9 4f       	sbci	r31, 0xF9	; 249
    3454:	80 81       	ld	r24, Z
    3456:	88 23       	and	r24, r24
    3458:	59 f3       	breq	.-42     	; 0x3430 <vTaskSwitchContext+0x28>
    345a:	8b 81       	ldd	r24, Y+3	; 0x03
    345c:	28 2f       	mov	r18, r24
    345e:	30 e0       	ldi	r19, 0x00	; 0
    3460:	c9 01       	movw	r24, r18
    3462:	88 0f       	add	r24, r24
    3464:	99 1f       	adc	r25, r25
    3466:	88 0f       	add	r24, r24
    3468:	99 1f       	adc	r25, r25
    346a:	88 0f       	add	r24, r24
    346c:	99 1f       	adc	r25, r25
    346e:	82 0f       	add	r24, r18
    3470:	93 1f       	adc	r25, r19
    3472:	82 5b       	subi	r24, 0xB2	; 178
    3474:	99 4f       	sbci	r25, 0xF9	; 249
    3476:	9a 83       	std	Y+2, r25	; 0x02
    3478:	89 83       	std	Y+1, r24	; 0x01
    347a:	e9 81       	ldd	r30, Y+1	; 0x01
    347c:	fa 81       	ldd	r31, Y+2	; 0x02
    347e:	01 80       	ldd	r0, Z+1	; 0x01
    3480:	f2 81       	ldd	r31, Z+2	; 0x02
    3482:	e0 2d       	mov	r30, r0
    3484:	82 81       	ldd	r24, Z+2	; 0x02
    3486:	93 81       	ldd	r25, Z+3	; 0x03
    3488:	e9 81       	ldd	r30, Y+1	; 0x01
    348a:	fa 81       	ldd	r31, Y+2	; 0x02
    348c:	92 83       	std	Z+2, r25	; 0x02
    348e:	81 83       	std	Z+1, r24	; 0x01
    3490:	e9 81       	ldd	r30, Y+1	; 0x01
    3492:	fa 81       	ldd	r31, Y+2	; 0x02
    3494:	21 81       	ldd	r18, Z+1	; 0x01
    3496:	32 81       	ldd	r19, Z+2	; 0x02
    3498:	89 81       	ldd	r24, Y+1	; 0x01
    349a:	9a 81       	ldd	r25, Y+2	; 0x02
    349c:	03 96       	adiw	r24, 0x03	; 3
    349e:	28 17       	cp	r18, r24
    34a0:	39 07       	cpc	r19, r25
    34a2:	59 f4       	brne	.+22     	; 0x34ba <vTaskSwitchContext+0xb2>
    34a4:	e9 81       	ldd	r30, Y+1	; 0x01
    34a6:	fa 81       	ldd	r31, Y+2	; 0x02
    34a8:	01 80       	ldd	r0, Z+1	; 0x01
    34aa:	f2 81       	ldd	r31, Z+2	; 0x02
    34ac:	e0 2d       	mov	r30, r0
    34ae:	82 81       	ldd	r24, Z+2	; 0x02
    34b0:	93 81       	ldd	r25, Z+3	; 0x03
    34b2:	e9 81       	ldd	r30, Y+1	; 0x01
    34b4:	fa 81       	ldd	r31, Y+2	; 0x02
    34b6:	92 83       	std	Z+2, r25	; 0x02
    34b8:	81 83       	std	Z+1, r24	; 0x01
    34ba:	e9 81       	ldd	r30, Y+1	; 0x01
    34bc:	fa 81       	ldd	r31, Y+2	; 0x02
    34be:	01 80       	ldd	r0, Z+1	; 0x01
    34c0:	f2 81       	ldd	r31, Z+2	; 0x02
    34c2:	e0 2d       	mov	r30, r0
    34c4:	86 81       	ldd	r24, Z+6	; 0x06
    34c6:	97 81       	ldd	r25, Z+7	; 0x07
    34c8:	90 93 3e 06 	sts	0x063E, r25
    34cc:	80 93 3d 06 	sts	0x063D, r24
    34d0:	8b 81       	ldd	r24, Y+3	; 0x03
    34d2:	80 93 43 06 	sts	0x0643, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	0f 90       	pop	r0
    34dc:	cf 91       	pop	r28
    34de:	df 91       	pop	r29
    34e0:	08 95       	ret

000034e2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    34e2:	df 93       	push	r29
    34e4:	cf 93       	push	r28
    34e6:	00 d0       	rcall	.+0      	; 0x34e8 <vTaskPlaceOnEventList+0x6>
    34e8:	00 d0       	rcall	.+0      	; 0x34ea <vTaskPlaceOnEventList+0x8>
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
    34ee:	9a 83       	std	Y+2, r25	; 0x02
    34f0:	89 83       	std	Y+1, r24	; 0x01
    34f2:	7c 83       	std	Y+4, r23	; 0x04
    34f4:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    34f6:	80 91 3d 06 	lds	r24, 0x063D
    34fa:	90 91 3e 06 	lds	r25, 0x063E
    34fe:	9c 01       	movw	r18, r24
    3500:	24 5f       	subi	r18, 0xF4	; 244
    3502:	3f 4f       	sbci	r19, 0xFF	; 255
    3504:	89 81       	ldd	r24, Y+1	; 0x01
    3506:	9a 81       	ldd	r25, Y+2	; 0x02
    3508:	b9 01       	movw	r22, r18
    350a:	0e 94 31 09 	call	0x1262	; 0x1262 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    350e:	8b 81       	ldd	r24, Y+3	; 0x03
    3510:	9c 81       	ldd	r25, Y+4	; 0x04
    3512:	61 e0       	ldi	r22, 0x01	; 1
    3514:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvAddCurrentTaskToDelayedList>
}
    3518:	0f 90       	pop	r0
    351a:	0f 90       	pop	r0
    351c:	0f 90       	pop	r0
    351e:	0f 90       	pop	r0
    3520:	cf 91       	pop	r28
    3522:	df 91       	pop	r29
    3524:	08 95       	ret

00003526 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3526:	df 93       	push	r29
    3528:	cf 93       	push	r28
    352a:	00 d0       	rcall	.+0      	; 0x352c <vTaskPlaceOnUnorderedEventList+0x6>
    352c:	00 d0       	rcall	.+0      	; 0x352e <vTaskPlaceOnUnorderedEventList+0x8>
    352e:	00 d0       	rcall	.+0      	; 0x3530 <vTaskPlaceOnUnorderedEventList+0xa>
    3530:	cd b7       	in	r28, 0x3d	; 61
    3532:	de b7       	in	r29, 0x3e	; 62
    3534:	9a 83       	std	Y+2, r25	; 0x02
    3536:	89 83       	std	Y+1, r24	; 0x01
    3538:	7c 83       	std	Y+4, r23	; 0x04
    353a:	6b 83       	std	Y+3, r22	; 0x03
    353c:	5e 83       	std	Y+6, r21	; 0x06
    353e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3540:	e0 91 3d 06 	lds	r30, 0x063D
    3544:	f0 91 3e 06 	lds	r31, 0x063E
    3548:	8b 81       	ldd	r24, Y+3	; 0x03
    354a:	9c 81       	ldd	r25, Y+4	; 0x04
    354c:	90 68       	ori	r25, 0x80	; 128
    354e:	95 87       	std	Z+13, r25	; 0x0d
    3550:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3552:	80 91 3d 06 	lds	r24, 0x063D
    3556:	90 91 3e 06 	lds	r25, 0x063E
    355a:	9c 01       	movw	r18, r24
    355c:	24 5f       	subi	r18, 0xF4	; 244
    355e:	3f 4f       	sbci	r19, 0xFF	; 255
    3560:	89 81       	ldd	r24, Y+1	; 0x01
    3562:	9a 81       	ldd	r25, Y+2	; 0x02
    3564:	b9 01       	movw	r22, r18
    3566:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    356a:	8d 81       	ldd	r24, Y+5	; 0x05
    356c:	9e 81       	ldd	r25, Y+6	; 0x06
    356e:	61 e0       	ldi	r22, 0x01	; 1
    3570:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvAddCurrentTaskToDelayedList>
}
    3574:	26 96       	adiw	r28, 0x06	; 6
    3576:	0f b6       	in	r0, 0x3f	; 63
    3578:	f8 94       	cli
    357a:	de bf       	out	0x3e, r29	; 62
    357c:	0f be       	out	0x3f, r0	; 63
    357e:	cd bf       	out	0x3d, r28	; 61
    3580:	cf 91       	pop	r28
    3582:	df 91       	pop	r29
    3584:	08 95       	ret

00003586 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3586:	df 93       	push	r29
    3588:	cf 93       	push	r28
    358a:	00 d0       	rcall	.+0      	; 0x358c <xTaskRemoveFromEventList+0x6>
    358c:	00 d0       	rcall	.+0      	; 0x358e <xTaskRemoveFromEventList+0x8>
    358e:	0f 92       	push	r0
    3590:	cd b7       	in	r28, 0x3d	; 61
    3592:	de b7       	in	r29, 0x3e	; 62
    3594:	9d 83       	std	Y+5, r25	; 0x05
    3596:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3598:	ec 81       	ldd	r30, Y+4	; 0x04
    359a:	fd 81       	ldd	r31, Y+5	; 0x05
    359c:	05 80       	ldd	r0, Z+5	; 0x05
    359e:	f6 81       	ldd	r31, Z+6	; 0x06
    35a0:	e0 2d       	mov	r30, r0
    35a2:	86 81       	ldd	r24, Z+6	; 0x06
    35a4:	97 81       	ldd	r25, Z+7	; 0x07
    35a6:	9b 83       	std	Y+3, r25	; 0x03
    35a8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    35aa:	8a 81       	ldd	r24, Y+2	; 0x02
    35ac:	9b 81       	ldd	r25, Y+3	; 0x03
    35ae:	0c 96       	adiw	r24, 0x0c	; 12
    35b0:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35b4:	80 91 4d 06 	lds	r24, 0x064D
    35b8:	88 23       	and	r24, r24
    35ba:	61 f5       	brne	.+88     	; 0x3614 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    35bc:	8a 81       	ldd	r24, Y+2	; 0x02
    35be:	9b 81       	ldd	r25, Y+3	; 0x03
    35c0:	02 96       	adiw	r24, 0x02	; 2
    35c2:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    35c6:	ea 81       	ldd	r30, Y+2	; 0x02
    35c8:	fb 81       	ldd	r31, Y+3	; 0x03
    35ca:	96 89       	ldd	r25, Z+22	; 0x16
    35cc:	80 91 43 06 	lds	r24, 0x0643
    35d0:	89 17       	cp	r24, r25
    35d2:	28 f4       	brcc	.+10     	; 0x35de <xTaskRemoveFromEventList+0x58>
    35d4:	ea 81       	ldd	r30, Y+2	; 0x02
    35d6:	fb 81       	ldd	r31, Y+3	; 0x03
    35d8:	86 89       	ldd	r24, Z+22	; 0x16
    35da:	80 93 43 06 	sts	0x0643, r24
    35de:	ea 81       	ldd	r30, Y+2	; 0x02
    35e0:	fb 81       	ldd	r31, Y+3	; 0x03
    35e2:	86 89       	ldd	r24, Z+22	; 0x16
    35e4:	28 2f       	mov	r18, r24
    35e6:	30 e0       	ldi	r19, 0x00	; 0
    35e8:	c9 01       	movw	r24, r18
    35ea:	88 0f       	add	r24, r24
    35ec:	99 1f       	adc	r25, r25
    35ee:	88 0f       	add	r24, r24
    35f0:	99 1f       	adc	r25, r25
    35f2:	88 0f       	add	r24, r24
    35f4:	99 1f       	adc	r25, r25
    35f6:	82 0f       	add	r24, r18
    35f8:	93 1f       	adc	r25, r19
    35fa:	ac 01       	movw	r20, r24
    35fc:	42 5b       	subi	r20, 0xB2	; 178
    35fe:	59 4f       	sbci	r21, 0xF9	; 249
    3600:	8a 81       	ldd	r24, Y+2	; 0x02
    3602:	9b 81       	ldd	r25, Y+3	; 0x03
    3604:	9c 01       	movw	r18, r24
    3606:	2e 5f       	subi	r18, 0xFE	; 254
    3608:	3f 4f       	sbci	r19, 0xFF	; 255
    360a:	ca 01       	movw	r24, r20
    360c:	b9 01       	movw	r22, r18
    360e:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    3612:	0a c0       	rjmp	.+20     	; 0x3628 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3614:	8a 81       	ldd	r24, Y+2	; 0x02
    3616:	9b 81       	ldd	r25, Y+3	; 0x03
    3618:	9c 01       	movw	r18, r24
    361a:	24 5f       	subi	r18, 0xF4	; 244
    361c:	3f 4f       	sbci	r19, 0xFF	; 255
    361e:	8f e7       	ldi	r24, 0x7F	; 127
    3620:	96 e0       	ldi	r25, 0x06	; 6
    3622:	b9 01       	movw	r22, r18
    3624:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3628:	ea 81       	ldd	r30, Y+2	; 0x02
    362a:	fb 81       	ldd	r31, Y+3	; 0x03
    362c:	96 89       	ldd	r25, Z+22	; 0x16
    362e:	e0 91 3d 06 	lds	r30, 0x063D
    3632:	f0 91 3e 06 	lds	r31, 0x063E
    3636:	86 89       	ldd	r24, Z+22	; 0x16
    3638:	89 17       	cp	r24, r25
    363a:	30 f4       	brcc	.+12     	; 0x3648 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    363c:	81 e0       	ldi	r24, 0x01	; 1
    363e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3640:	81 e0       	ldi	r24, 0x01	; 1
    3642:	80 93 46 06 	sts	0x0646, r24
    3646:	01 c0       	rjmp	.+2      	; 0x364a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3648:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    364a:	89 81       	ldd	r24, Y+1	; 0x01
}
    364c:	0f 90       	pop	r0
    364e:	0f 90       	pop	r0
    3650:	0f 90       	pop	r0
    3652:	0f 90       	pop	r0
    3654:	0f 90       	pop	r0
    3656:	cf 91       	pop	r28
    3658:	df 91       	pop	r29
    365a:	08 95       	ret

0000365c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    365c:	df 93       	push	r29
    365e:	cf 93       	push	r28
    3660:	cd b7       	in	r28, 0x3d	; 61
    3662:	de b7       	in	r29, 0x3e	; 62
    3664:	27 97       	sbiw	r28, 0x07	; 7
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	de bf       	out	0x3e, r29	; 62
    366c:	0f be       	out	0x3f, r0	; 63
    366e:	cd bf       	out	0x3d, r28	; 61
    3670:	9d 83       	std	Y+5, r25	; 0x05
    3672:	8c 83       	std	Y+4, r24	; 0x04
    3674:	7f 83       	std	Y+7, r23	; 0x07
    3676:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3678:	8e 81       	ldd	r24, Y+6	; 0x06
    367a:	9f 81       	ldd	r25, Y+7	; 0x07
    367c:	90 68       	ori	r25, 0x80	; 128
    367e:	ec 81       	ldd	r30, Y+4	; 0x04
    3680:	fd 81       	ldd	r31, Y+5	; 0x05
    3682:	91 83       	std	Z+1, r25	; 0x01
    3684:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    3686:	ec 81       	ldd	r30, Y+4	; 0x04
    3688:	fd 81       	ldd	r31, Y+5	; 0x05
    368a:	86 81       	ldd	r24, Z+6	; 0x06
    368c:	97 81       	ldd	r25, Z+7	; 0x07
    368e:	9b 83       	std	Y+3, r25	; 0x03
    3690:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3692:	8c 81       	ldd	r24, Y+4	; 0x04
    3694:	9d 81       	ldd	r25, Y+5	; 0x05
    3696:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    369a:	8a 81       	ldd	r24, Y+2	; 0x02
    369c:	9b 81       	ldd	r25, Y+3	; 0x03
    369e:	02 96       	adiw	r24, 0x02	; 2
    36a0:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    36a4:	ea 81       	ldd	r30, Y+2	; 0x02
    36a6:	fb 81       	ldd	r31, Y+3	; 0x03
    36a8:	96 89       	ldd	r25, Z+22	; 0x16
    36aa:	80 91 43 06 	lds	r24, 0x0643
    36ae:	89 17       	cp	r24, r25
    36b0:	28 f4       	brcc	.+10     	; 0x36bc <xTaskRemoveFromUnorderedEventList+0x60>
    36b2:	ea 81       	ldd	r30, Y+2	; 0x02
    36b4:	fb 81       	ldd	r31, Y+3	; 0x03
    36b6:	86 89       	ldd	r24, Z+22	; 0x16
    36b8:	80 93 43 06 	sts	0x0643, r24
    36bc:	ea 81       	ldd	r30, Y+2	; 0x02
    36be:	fb 81       	ldd	r31, Y+3	; 0x03
    36c0:	86 89       	ldd	r24, Z+22	; 0x16
    36c2:	28 2f       	mov	r18, r24
    36c4:	30 e0       	ldi	r19, 0x00	; 0
    36c6:	c9 01       	movw	r24, r18
    36c8:	88 0f       	add	r24, r24
    36ca:	99 1f       	adc	r25, r25
    36cc:	88 0f       	add	r24, r24
    36ce:	99 1f       	adc	r25, r25
    36d0:	88 0f       	add	r24, r24
    36d2:	99 1f       	adc	r25, r25
    36d4:	82 0f       	add	r24, r18
    36d6:	93 1f       	adc	r25, r19
    36d8:	ac 01       	movw	r20, r24
    36da:	42 5b       	subi	r20, 0xB2	; 178
    36dc:	59 4f       	sbci	r21, 0xF9	; 249
    36de:	8a 81       	ldd	r24, Y+2	; 0x02
    36e0:	9b 81       	ldd	r25, Y+3	; 0x03
    36e2:	9c 01       	movw	r18, r24
    36e4:	2e 5f       	subi	r18, 0xFE	; 254
    36e6:	3f 4f       	sbci	r19, 0xFF	; 255
    36e8:	ca 01       	movw	r24, r20
    36ea:	b9 01       	movw	r22, r18
    36ec:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    36f0:	ea 81       	ldd	r30, Y+2	; 0x02
    36f2:	fb 81       	ldd	r31, Y+3	; 0x03
    36f4:	96 89       	ldd	r25, Z+22	; 0x16
    36f6:	e0 91 3d 06 	lds	r30, 0x063D
    36fa:	f0 91 3e 06 	lds	r31, 0x063E
    36fe:	86 89       	ldd	r24, Z+22	; 0x16
    3700:	89 17       	cp	r24, r25
    3702:	30 f4       	brcc	.+12     	; 0x3710 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3704:	81 e0       	ldi	r24, 0x01	; 1
    3706:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3708:	81 e0       	ldi	r24, 0x01	; 1
    370a:	80 93 46 06 	sts	0x0646, r24
    370e:	01 c0       	rjmp	.+2      	; 0x3712 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    3710:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3712:	89 81       	ldd	r24, Y+1	; 0x01
}
    3714:	27 96       	adiw	r28, 0x07	; 7
    3716:	0f b6       	in	r0, 0x3f	; 63
    3718:	f8 94       	cli
    371a:	de bf       	out	0x3e, r29	; 62
    371c:	0f be       	out	0x3f, r0	; 63
    371e:	cd bf       	out	0x3d, r28	; 61
    3720:	cf 91       	pop	r28
    3722:	df 91       	pop	r29
    3724:	08 95       	ret

00003726 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3726:	df 93       	push	r29
    3728:	cf 93       	push	r28
    372a:	00 d0       	rcall	.+0      	; 0x372c <vTaskSetTimeOutState+0x6>
    372c:	cd b7       	in	r28, 0x3d	; 61
    372e:	de b7       	in	r29, 0x3e	; 62
    3730:	9a 83       	std	Y+2, r25	; 0x02
    3732:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3734:	80 91 47 06 	lds	r24, 0x0647
    3738:	e9 81       	ldd	r30, Y+1	; 0x01
    373a:	fa 81       	ldd	r31, Y+2	; 0x02
    373c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    373e:	80 91 41 06 	lds	r24, 0x0641
    3742:	90 91 42 06 	lds	r25, 0x0642
    3746:	e9 81       	ldd	r30, Y+1	; 0x01
    3748:	fa 81       	ldd	r31, Y+2	; 0x02
    374a:	92 83       	std	Z+2, r25	; 0x02
    374c:	81 83       	std	Z+1, r24	; 0x01
}
    374e:	0f 90       	pop	r0
    3750:	0f 90       	pop	r0
    3752:	cf 91       	pop	r28
    3754:	df 91       	pop	r29
    3756:	08 95       	ret

00003758 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3758:	df 93       	push	r29
    375a:	cf 93       	push	r28
    375c:	cd b7       	in	r28, 0x3d	; 61
    375e:	de b7       	in	r29, 0x3e	; 62
    3760:	27 97       	sbiw	r28, 0x07	; 7
    3762:	0f b6       	in	r0, 0x3f	; 63
    3764:	f8 94       	cli
    3766:	de bf       	out	0x3e, r29	; 62
    3768:	0f be       	out	0x3f, r0	; 63
    376a:	cd bf       	out	0x3d, r28	; 61
    376c:	9d 83       	std	Y+5, r25	; 0x05
    376e:	8c 83       	std	Y+4, r24	; 0x04
    3770:	7f 83       	std	Y+7, r23	; 0x07
    3772:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3774:	0f b6       	in	r0, 0x3f	; 63
    3776:	f8 94       	cli
    3778:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    377a:	80 91 41 06 	lds	r24, 0x0641
    377e:	90 91 42 06 	lds	r25, 0x0642
    3782:	9a 83       	std	Y+2, r25	; 0x02
    3784:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3786:	ee 81       	ldd	r30, Y+6	; 0x06
    3788:	ff 81       	ldd	r31, Y+7	; 0x07
    378a:	80 81       	ld	r24, Z
    378c:	91 81       	ldd	r25, Z+1	; 0x01
    378e:	2f ef       	ldi	r18, 0xFF	; 255
    3790:	8f 3f       	cpi	r24, 0xFF	; 255
    3792:	92 07       	cpc	r25, r18
    3794:	11 f4       	brne	.+4      	; 0x379a <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3796:	1b 82       	std	Y+3, r1	; 0x03
    3798:	40 c0       	rjmp	.+128    	; 0x381a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    379a:	ec 81       	ldd	r30, Y+4	; 0x04
    379c:	fd 81       	ldd	r31, Y+5	; 0x05
    379e:	90 81       	ld	r25, Z
    37a0:	80 91 47 06 	lds	r24, 0x0647
    37a4:	98 17       	cp	r25, r24
    37a6:	61 f0       	breq	.+24     	; 0x37c0 <xTaskCheckForTimeOut+0x68>
    37a8:	ec 81       	ldd	r30, Y+4	; 0x04
    37aa:	fd 81       	ldd	r31, Y+5	; 0x05
    37ac:	21 81       	ldd	r18, Z+1	; 0x01
    37ae:	32 81       	ldd	r19, Z+2	; 0x02
    37b0:	89 81       	ldd	r24, Y+1	; 0x01
    37b2:	9a 81       	ldd	r25, Y+2	; 0x02
    37b4:	82 17       	cp	r24, r18
    37b6:	93 07       	cpc	r25, r19
    37b8:	18 f0       	brcs	.+6      	; 0x37c0 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    37ba:	81 e0       	ldi	r24, 0x01	; 1
    37bc:	8b 83       	std	Y+3, r24	; 0x03
    37be:	2d c0       	rjmp	.+90     	; 0x381a <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    37c0:	ec 81       	ldd	r30, Y+4	; 0x04
    37c2:	fd 81       	ldd	r31, Y+5	; 0x05
    37c4:	21 81       	ldd	r18, Z+1	; 0x01
    37c6:	32 81       	ldd	r19, Z+2	; 0x02
    37c8:	89 81       	ldd	r24, Y+1	; 0x01
    37ca:	9a 81       	ldd	r25, Y+2	; 0x02
    37cc:	ac 01       	movw	r20, r24
    37ce:	42 1b       	sub	r20, r18
    37d0:	53 0b       	sbc	r21, r19
    37d2:	9a 01       	movw	r18, r20
    37d4:	ee 81       	ldd	r30, Y+6	; 0x06
    37d6:	ff 81       	ldd	r31, Y+7	; 0x07
    37d8:	80 81       	ld	r24, Z
    37da:	91 81       	ldd	r25, Z+1	; 0x01
    37dc:	28 17       	cp	r18, r24
    37de:	39 07       	cpc	r19, r25
    37e0:	d0 f4       	brcc	.+52     	; 0x3816 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    37e2:	ee 81       	ldd	r30, Y+6	; 0x06
    37e4:	ff 81       	ldd	r31, Y+7	; 0x07
    37e6:	40 81       	ld	r20, Z
    37e8:	51 81       	ldd	r21, Z+1	; 0x01
    37ea:	ec 81       	ldd	r30, Y+4	; 0x04
    37ec:	fd 81       	ldd	r31, Y+5	; 0x05
    37ee:	21 81       	ldd	r18, Z+1	; 0x01
    37f0:	32 81       	ldd	r19, Z+2	; 0x02
    37f2:	89 81       	ldd	r24, Y+1	; 0x01
    37f4:	9a 81       	ldd	r25, Y+2	; 0x02
    37f6:	b9 01       	movw	r22, r18
    37f8:	68 1b       	sub	r22, r24
    37fa:	79 0b       	sbc	r23, r25
    37fc:	cb 01       	movw	r24, r22
    37fe:	84 0f       	add	r24, r20
    3800:	95 1f       	adc	r25, r21
    3802:	ee 81       	ldd	r30, Y+6	; 0x06
    3804:	ff 81       	ldd	r31, Y+7	; 0x07
    3806:	91 83       	std	Z+1, r25	; 0x01
    3808:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    380a:	8c 81       	ldd	r24, Y+4	; 0x04
    380c:	9d 81       	ldd	r25, Y+5	; 0x05
    380e:	0e 94 93 1b 	call	0x3726	; 0x3726 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3812:	1b 82       	std	Y+3, r1	; 0x03
    3814:	02 c0       	rjmp	.+4      	; 0x381a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    3816:	81 e0       	ldi	r24, 0x01	; 1
    3818:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    381a:	0f 90       	pop	r0
    381c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    381e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3820:	27 96       	adiw	r28, 0x07	; 7
    3822:	0f b6       	in	r0, 0x3f	; 63
    3824:	f8 94       	cli
    3826:	de bf       	out	0x3e, r29	; 62
    3828:	0f be       	out	0x3f, r0	; 63
    382a:	cd bf       	out	0x3d, r28	; 61
    382c:	cf 91       	pop	r28
    382e:	df 91       	pop	r29
    3830:	08 95       	ret

00003832 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3832:	df 93       	push	r29
    3834:	cf 93       	push	r28
    3836:	cd b7       	in	r28, 0x3d	; 61
    3838:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    383a:	81 e0       	ldi	r24, 0x01	; 1
    383c:	80 93 46 06 	sts	0x0646, r24
}
    3840:	cf 91       	pop	r28
    3842:	df 91       	pop	r29
    3844:	08 95       	ret

00003846 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3846:	df 93       	push	r29
    3848:	cf 93       	push	r28
    384a:	00 d0       	rcall	.+0      	; 0x384c <prvIdleTask+0x6>
    384c:	cd b7       	in	r28, 0x3d	; 61
    384e:	de b7       	in	r29, 0x3e	; 62
    3850:	9a 83       	std	Y+2, r25	; 0x02
    3852:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3854:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <prvCheckTasksWaitingTermination>
    3858:	fd cf       	rjmp	.-6      	; 0x3854 <prvIdleTask+0xe>

0000385a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    385a:	df 93       	push	r29
    385c:	cf 93       	push	r28
    385e:	0f 92       	push	r0
    3860:	cd b7       	in	r28, 0x3d	; 61
    3862:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3864:	19 82       	std	Y+1, r1	; 0x01
    3866:	13 c0       	rjmp	.+38     	; 0x388e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3868:	89 81       	ldd	r24, Y+1	; 0x01
    386a:	28 2f       	mov	r18, r24
    386c:	30 e0       	ldi	r19, 0x00	; 0
    386e:	c9 01       	movw	r24, r18
    3870:	88 0f       	add	r24, r24
    3872:	99 1f       	adc	r25, r25
    3874:	88 0f       	add	r24, r24
    3876:	99 1f       	adc	r25, r25
    3878:	88 0f       	add	r24, r24
    387a:	99 1f       	adc	r25, r25
    387c:	82 0f       	add	r24, r18
    387e:	93 1f       	adc	r25, r19
    3880:	82 5b       	subi	r24, 0xB2	; 178
    3882:	99 4f       	sbci	r25, 0xF9	; 249
    3884:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3888:	89 81       	ldd	r24, Y+1	; 0x01
    388a:	8f 5f       	subi	r24, 0xFF	; 255
    388c:	89 83       	std	Y+1, r24	; 0x01
    388e:	89 81       	ldd	r24, Y+1	; 0x01
    3890:	83 30       	cpi	r24, 0x03	; 3
    3892:	50 f3       	brcs	.-44     	; 0x3868 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3894:	89 e6       	ldi	r24, 0x69	; 105
    3896:	96 e0       	ldi	r25, 0x06	; 6
    3898:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    389c:	82 e7       	ldi	r24, 0x72	; 114
    389e:	96 e0       	ldi	r25, 0x06	; 6
    38a0:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    38a4:	8f e7       	ldi	r24, 0x7F	; 127
    38a6:	96 e0       	ldi	r25, 0x06	; 6
    38a8:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    38ac:	88 e8       	ldi	r24, 0x88	; 136
    38ae:	96 e0       	ldi	r25, 0x06	; 6
    38b0:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    38b4:	81 e9       	ldi	r24, 0x91	; 145
    38b6:	96 e0       	ldi	r25, 0x06	; 6
    38b8:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    38bc:	89 e6       	ldi	r24, 0x69	; 105
    38be:	96 e0       	ldi	r25, 0x06	; 6
    38c0:	90 93 7c 06 	sts	0x067C, r25
    38c4:	80 93 7b 06 	sts	0x067B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    38c8:	82 e7       	ldi	r24, 0x72	; 114
    38ca:	96 e0       	ldi	r25, 0x06	; 6
    38cc:	90 93 7e 06 	sts	0x067E, r25
    38d0:	80 93 7d 06 	sts	0x067D, r24
}
    38d4:	0f 90       	pop	r0
    38d6:	cf 91       	pop	r28
    38d8:	df 91       	pop	r29
    38da:	08 95       	ret

000038dc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    38dc:	df 93       	push	r29
    38de:	cf 93       	push	r28
    38e0:	00 d0       	rcall	.+0      	; 0x38e2 <prvCheckTasksWaitingTermination+0x6>
    38e2:	0f 92       	push	r0
    38e4:	cd b7       	in	r28, 0x3d	; 61
    38e6:	de b7       	in	r29, 0x3e	; 62
    38e8:	2e c0       	rjmp	.+92     	; 0x3946 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    38ea:	0e 94 23 18 	call	0x3046	; 0x3046 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    38ee:	80 91 88 06 	lds	r24, 0x0688
    38f2:	1b 82       	std	Y+3, r1	; 0x03
    38f4:	88 23       	and	r24, r24
    38f6:	11 f4       	brne	.+4      	; 0x38fc <prvCheckTasksWaitingTermination+0x20>
    38f8:	81 e0       	ldi	r24, 0x01	; 1
    38fa:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    38fc:	0e 94 2f 18 	call	0x305e	; 0x305e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3900:	8b 81       	ldd	r24, Y+3	; 0x03
    3902:	88 23       	and	r24, r24
    3904:	01 f5       	brne	.+64     	; 0x3946 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    3906:	0f b6       	in	r0, 0x3f	; 63
    3908:	f8 94       	cli
    390a:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    390c:	e0 91 8d 06 	lds	r30, 0x068D
    3910:	f0 91 8e 06 	lds	r31, 0x068E
    3914:	86 81       	ldd	r24, Z+6	; 0x06
    3916:	97 81       	ldd	r25, Z+7	; 0x07
    3918:	9a 83       	std	Y+2, r25	; 0x02
    391a:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	9a 81       	ldd	r25, Y+2	; 0x02
    3920:	02 96       	adiw	r24, 0x02	; 2
    3922:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					--uxCurrentNumberOfTasks;
    3926:	80 91 40 06 	lds	r24, 0x0640
    392a:	81 50       	subi	r24, 0x01	; 1
    392c:	80 93 40 06 	sts	0x0640, r24
					--uxDeletedTasksWaitingCleanUp;
    3930:	80 91 3f 06 	lds	r24, 0x063F
    3934:	81 50       	subi	r24, 0x01	; 1
    3936:	80 93 3f 06 	sts	0x063F, r24
				}
				taskEXIT_CRITICAL();
    393a:	0f 90       	pop	r0
    393c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    393e:	89 81       	ldd	r24, Y+1	; 0x01
    3940:	9a 81       	ldd	r25, Y+2	; 0x02
    3942:	0e 94 ad 1c 	call	0x395a	; 0x395a <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3946:	80 91 3f 06 	lds	r24, 0x063F
    394a:	88 23       	and	r24, r24
    394c:	71 f6       	brne	.-100    	; 0x38ea <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    394e:	0f 90       	pop	r0
    3950:	0f 90       	pop	r0
    3952:	0f 90       	pop	r0
    3954:	cf 91       	pop	r28
    3956:	df 91       	pop	r29
    3958:	08 95       	ret

0000395a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    395a:	df 93       	push	r29
    395c:	cf 93       	push	r28
    395e:	00 d0       	rcall	.+0      	; 0x3960 <prvDeleteTCB+0x6>
    3960:	cd b7       	in	r28, 0x3d	; 61
    3962:	de b7       	in	r29, 0x3e	; 62
    3964:	9a 83       	std	Y+2, r25	; 0x02
    3966:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3968:	e9 81       	ldd	r30, Y+1	; 0x01
    396a:	fa 81       	ldd	r31, Y+2	; 0x02
    396c:	87 89       	ldd	r24, Z+23	; 0x17
    396e:	90 8d       	ldd	r25, Z+24	; 0x18
    3970:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
			vPortFree( pxTCB );
    3974:	89 81       	ldd	r24, Y+1	; 0x01
    3976:	9a 81       	ldd	r25, Y+2	; 0x02
    3978:	0e 94 ff 07 	call	0xffe	; 0xffe <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    397c:	0f 90       	pop	r0
    397e:	0f 90       	pop	r0
    3980:	cf 91       	pop	r28
    3982:	df 91       	pop	r29
    3984:	08 95       	ret

00003986 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3986:	df 93       	push	r29
    3988:	cf 93       	push	r28
    398a:	00 d0       	rcall	.+0      	; 0x398c <prvResetNextTaskUnblockTime+0x6>
    398c:	cd b7       	in	r28, 0x3d	; 61
    398e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3990:	e0 91 7b 06 	lds	r30, 0x067B
    3994:	f0 91 7c 06 	lds	r31, 0x067C
    3998:	80 81       	ld	r24, Z
    399a:	88 23       	and	r24, r24
    399c:	39 f4       	brne	.+14     	; 0x39ac <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    399e:	8f ef       	ldi	r24, 0xFF	; 255
    39a0:	9f ef       	ldi	r25, 0xFF	; 255
    39a2:	90 93 4a 06 	sts	0x064A, r25
    39a6:	80 93 49 06 	sts	0x0649, r24
    39aa:	13 c0       	rjmp	.+38     	; 0x39d2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    39ac:	e0 91 7b 06 	lds	r30, 0x067B
    39b0:	f0 91 7c 06 	lds	r31, 0x067C
    39b4:	05 80       	ldd	r0, Z+5	; 0x05
    39b6:	f6 81       	ldd	r31, Z+6	; 0x06
    39b8:	e0 2d       	mov	r30, r0
    39ba:	86 81       	ldd	r24, Z+6	; 0x06
    39bc:	97 81       	ldd	r25, Z+7	; 0x07
    39be:	9a 83       	std	Y+2, r25	; 0x02
    39c0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    39c2:	e9 81       	ldd	r30, Y+1	; 0x01
    39c4:	fa 81       	ldd	r31, Y+2	; 0x02
    39c6:	82 81       	ldd	r24, Z+2	; 0x02
    39c8:	93 81       	ldd	r25, Z+3	; 0x03
    39ca:	90 93 4a 06 	sts	0x064A, r25
    39ce:	80 93 49 06 	sts	0x0649, r24
	}
}
    39d2:	0f 90       	pop	r0
    39d4:	0f 90       	pop	r0
    39d6:	cf 91       	pop	r28
    39d8:	df 91       	pop	r29
    39da:	08 95       	ret

000039dc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    39dc:	df 93       	push	r29
    39de:	cf 93       	push	r28
    39e0:	00 d0       	rcall	.+0      	; 0x39e2 <xTaskGetCurrentTaskHandle+0x6>
    39e2:	cd b7       	in	r28, 0x3d	; 61
    39e4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    39e6:	80 91 3d 06 	lds	r24, 0x063D
    39ea:	90 91 3e 06 	lds	r25, 0x063E
    39ee:	9a 83       	std	Y+2, r25	; 0x02
    39f0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    39f2:	89 81       	ldd	r24, Y+1	; 0x01
    39f4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    39f6:	0f 90       	pop	r0
    39f8:	0f 90       	pop	r0
    39fa:	cf 91       	pop	r28
    39fc:	df 91       	pop	r29
    39fe:	08 95       	ret

00003a00 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    3a00:	df 93       	push	r29
    3a02:	cf 93       	push	r28
    3a04:	00 d0       	rcall	.+0      	; 0x3a06 <vTaskPriorityInherit+0x6>
    3a06:	00 d0       	rcall	.+0      	; 0x3a08 <vTaskPriorityInherit+0x8>
    3a08:	cd b7       	in	r28, 0x3d	; 61
    3a0a:	de b7       	in	r29, 0x3e	; 62
    3a0c:	9c 83       	std	Y+4, r25	; 0x04
    3a0e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    3a10:	8b 81       	ldd	r24, Y+3	; 0x03
    3a12:	9c 81       	ldd	r25, Y+4	; 0x04
    3a14:	9a 83       	std	Y+2, r25	; 0x02
    3a16:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    3a18:	8b 81       	ldd	r24, Y+3	; 0x03
    3a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1c:	00 97       	sbiw	r24, 0x00	; 0
    3a1e:	09 f4       	brne	.+2      	; 0x3a22 <vTaskPriorityInherit+0x22>
    3a20:	73 c0       	rjmp	.+230    	; 0x3b08 <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    3a22:	e9 81       	ldd	r30, Y+1	; 0x01
    3a24:	fa 81       	ldd	r31, Y+2	; 0x02
    3a26:	96 89       	ldd	r25, Z+22	; 0x16
    3a28:	e0 91 3d 06 	lds	r30, 0x063D
    3a2c:	f0 91 3e 06 	lds	r31, 0x063E
    3a30:	86 89       	ldd	r24, Z+22	; 0x16
    3a32:	98 17       	cp	r25, r24
    3a34:	08 f0       	brcs	.+2      	; 0x3a38 <vTaskPriorityInherit+0x38>
    3a36:	68 c0       	rjmp	.+208    	; 0x3b08 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3a38:	e9 81       	ldd	r30, Y+1	; 0x01
    3a3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a3c:	84 85       	ldd	r24, Z+12	; 0x0c
    3a3e:	95 85       	ldd	r25, Z+13	; 0x0d
    3a40:	99 23       	and	r25, r25
    3a42:	7c f0       	brlt	.+30     	; 0x3a62 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3a44:	e0 91 3d 06 	lds	r30, 0x063D
    3a48:	f0 91 3e 06 	lds	r31, 0x063E
    3a4c:	86 89       	ldd	r24, Z+22	; 0x16
    3a4e:	28 2f       	mov	r18, r24
    3a50:	30 e0       	ldi	r19, 0x00	; 0
    3a52:	83 e0       	ldi	r24, 0x03	; 3
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	82 1b       	sub	r24, r18
    3a58:	93 0b       	sbc	r25, r19
    3a5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a5e:	95 87       	std	Z+13, r25	; 0x0d
    3a60:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    3a62:	e9 81       	ldd	r30, Y+1	; 0x01
    3a64:	fa 81       	ldd	r31, Y+2	; 0x02
    3a66:	42 85       	ldd	r20, Z+10	; 0x0a
    3a68:	53 85       	ldd	r21, Z+11	; 0x0b
    3a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a6e:	86 89       	ldd	r24, Z+22	; 0x16
    3a70:	28 2f       	mov	r18, r24
    3a72:	30 e0       	ldi	r19, 0x00	; 0
    3a74:	c9 01       	movw	r24, r18
    3a76:	88 0f       	add	r24, r24
    3a78:	99 1f       	adc	r25, r25
    3a7a:	88 0f       	add	r24, r24
    3a7c:	99 1f       	adc	r25, r25
    3a7e:	88 0f       	add	r24, r24
    3a80:	99 1f       	adc	r25, r25
    3a82:	82 0f       	add	r24, r18
    3a84:	93 1f       	adc	r25, r19
    3a86:	82 5b       	subi	r24, 0xB2	; 178
    3a88:	99 4f       	sbci	r25, 0xF9	; 249
    3a8a:	48 17       	cp	r20, r24
    3a8c:	59 07       	cpc	r21, r25
    3a8e:	a1 f5       	brne	.+104    	; 0x3af8 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3a90:	89 81       	ldd	r24, Y+1	; 0x01
    3a92:	9a 81       	ldd	r25, Y+2	; 0x02
    3a94:	02 96       	adiw	r24, 0x02	; 2
    3a96:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3a9a:	e0 91 3d 06 	lds	r30, 0x063D
    3a9e:	f0 91 3e 06 	lds	r31, 0x063E
    3aa2:	86 89       	ldd	r24, Z+22	; 0x16
    3aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    3aa8:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    3aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    3aac:	fa 81       	ldd	r31, Y+2	; 0x02
    3aae:	96 89       	ldd	r25, Z+22	; 0x16
    3ab0:	80 91 43 06 	lds	r24, 0x0643
    3ab4:	89 17       	cp	r24, r25
    3ab6:	28 f4       	brcc	.+10     	; 0x3ac2 <vTaskPriorityInherit+0xc2>
    3ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    3aba:	fa 81       	ldd	r31, Y+2	; 0x02
    3abc:	86 89       	ldd	r24, Z+22	; 0x16
    3abe:	80 93 43 06 	sts	0x0643, r24
    3ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac6:	86 89       	ldd	r24, Z+22	; 0x16
    3ac8:	28 2f       	mov	r18, r24
    3aca:	30 e0       	ldi	r19, 0x00	; 0
    3acc:	c9 01       	movw	r24, r18
    3ace:	88 0f       	add	r24, r24
    3ad0:	99 1f       	adc	r25, r25
    3ad2:	88 0f       	add	r24, r24
    3ad4:	99 1f       	adc	r25, r25
    3ad6:	88 0f       	add	r24, r24
    3ad8:	99 1f       	adc	r25, r25
    3ada:	82 0f       	add	r24, r18
    3adc:	93 1f       	adc	r25, r19
    3ade:	ac 01       	movw	r20, r24
    3ae0:	42 5b       	subi	r20, 0xB2	; 178
    3ae2:	59 4f       	sbci	r21, 0xF9	; 249
    3ae4:	89 81       	ldd	r24, Y+1	; 0x01
    3ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae8:	9c 01       	movw	r18, r24
    3aea:	2e 5f       	subi	r18, 0xFE	; 254
    3aec:	3f 4f       	sbci	r19, 0xFF	; 255
    3aee:	ca 01       	movw	r24, r20
    3af0:	b9 01       	movw	r22, r18
    3af2:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    3af6:	08 c0       	rjmp	.+16     	; 0x3b08 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3af8:	e0 91 3d 06 	lds	r30, 0x063D
    3afc:	f0 91 3e 06 	lds	r31, 0x063E
    3b00:	86 89       	ldd	r24, Z+22	; 0x16
    3b02:	e9 81       	ldd	r30, Y+1	; 0x01
    3b04:	fa 81       	ldd	r31, Y+2	; 0x02
    3b06:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3b08:	0f 90       	pop	r0
    3b0a:	0f 90       	pop	r0
    3b0c:	0f 90       	pop	r0
    3b0e:	0f 90       	pop	r0
    3b10:	cf 91       	pop	r28
    3b12:	df 91       	pop	r29
    3b14:	08 95       	ret

00003b16 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    3b16:	df 93       	push	r29
    3b18:	cf 93       	push	r28
    3b1a:	00 d0       	rcall	.+0      	; 0x3b1c <xTaskPriorityDisinherit+0x6>
    3b1c:	00 d0       	rcall	.+0      	; 0x3b1e <xTaskPriorityDisinherit+0x8>
    3b1e:	0f 92       	push	r0
    3b20:	cd b7       	in	r28, 0x3d	; 61
    3b22:	de b7       	in	r29, 0x3e	; 62
    3b24:	9d 83       	std	Y+5, r25	; 0x05
    3b26:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    3b28:	8c 81       	ldd	r24, Y+4	; 0x04
    3b2a:	9d 81       	ldd	r25, Y+5	; 0x05
    3b2c:	9b 83       	std	Y+3, r25	; 0x03
    3b2e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    3b30:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    3b32:	8c 81       	ldd	r24, Y+4	; 0x04
    3b34:	9d 81       	ldd	r25, Y+5	; 0x05
    3b36:	00 97       	sbiw	r24, 0x00	; 0
    3b38:	09 f4       	brne	.+2      	; 0x3b3c <xTaskPriorityDisinherit+0x26>
    3b3a:	56 c0       	rjmp	.+172    	; 0x3be8 <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    3b3c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b3e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b40:	82 a5       	ldd	r24, Z+42	; 0x2a
    3b42:	81 50       	subi	r24, 0x01	; 1
    3b44:	ea 81       	ldd	r30, Y+2	; 0x02
    3b46:	fb 81       	ldd	r31, Y+3	; 0x03
    3b48:	82 a7       	std	Z+42, r24	; 0x2a

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3b4a:	ea 81       	ldd	r30, Y+2	; 0x02
    3b4c:	fb 81       	ldd	r31, Y+3	; 0x03
    3b4e:	96 89       	ldd	r25, Z+22	; 0x16
    3b50:	ea 81       	ldd	r30, Y+2	; 0x02
    3b52:	fb 81       	ldd	r31, Y+3	; 0x03
    3b54:	81 a5       	ldd	r24, Z+41	; 0x29
    3b56:	98 17       	cp	r25, r24
    3b58:	09 f4       	brne	.+2      	; 0x3b5c <xTaskPriorityDisinherit+0x46>
    3b5a:	46 c0       	rjmp	.+140    	; 0x3be8 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3b5c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b5e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b60:	82 a5       	ldd	r24, Z+42	; 0x2a
    3b62:	88 23       	and	r24, r24
    3b64:	09 f0       	breq	.+2      	; 0x3b68 <xTaskPriorityDisinherit+0x52>
    3b66:	40 c0       	rjmp	.+128    	; 0x3be8 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3b68:	8a 81       	ldd	r24, Y+2	; 0x02
    3b6a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b6c:	02 96       	adiw	r24, 0x02	; 2
    3b6e:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    3b72:	ea 81       	ldd	r30, Y+2	; 0x02
    3b74:	fb 81       	ldd	r31, Y+3	; 0x03
    3b76:	81 a5       	ldd	r24, Z+41	; 0x29
    3b78:	ea 81       	ldd	r30, Y+2	; 0x02
    3b7a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b7c:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b7e:	ea 81       	ldd	r30, Y+2	; 0x02
    3b80:	fb 81       	ldd	r31, Y+3	; 0x03
    3b82:	86 89       	ldd	r24, Z+22	; 0x16
    3b84:	28 2f       	mov	r18, r24
    3b86:	30 e0       	ldi	r19, 0x00	; 0
    3b88:	83 e0       	ldi	r24, 0x03	; 3
    3b8a:	90 e0       	ldi	r25, 0x00	; 0
    3b8c:	82 1b       	sub	r24, r18
    3b8e:	93 0b       	sbc	r25, r19
    3b90:	ea 81       	ldd	r30, Y+2	; 0x02
    3b92:	fb 81       	ldd	r31, Y+3	; 0x03
    3b94:	95 87       	std	Z+13, r25	; 0x0d
    3b96:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    3b98:	ea 81       	ldd	r30, Y+2	; 0x02
    3b9a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b9c:	96 89       	ldd	r25, Z+22	; 0x16
    3b9e:	80 91 43 06 	lds	r24, 0x0643
    3ba2:	89 17       	cp	r24, r25
    3ba4:	28 f4       	brcc	.+10     	; 0x3bb0 <xTaskPriorityDisinherit+0x9a>
    3ba6:	ea 81       	ldd	r30, Y+2	; 0x02
    3ba8:	fb 81       	ldd	r31, Y+3	; 0x03
    3baa:	86 89       	ldd	r24, Z+22	; 0x16
    3bac:	80 93 43 06 	sts	0x0643, r24
    3bb0:	ea 81       	ldd	r30, Y+2	; 0x02
    3bb2:	fb 81       	ldd	r31, Y+3	; 0x03
    3bb4:	86 89       	ldd	r24, Z+22	; 0x16
    3bb6:	28 2f       	mov	r18, r24
    3bb8:	30 e0       	ldi	r19, 0x00	; 0
    3bba:	c9 01       	movw	r24, r18
    3bbc:	88 0f       	add	r24, r24
    3bbe:	99 1f       	adc	r25, r25
    3bc0:	88 0f       	add	r24, r24
    3bc2:	99 1f       	adc	r25, r25
    3bc4:	88 0f       	add	r24, r24
    3bc6:	99 1f       	adc	r25, r25
    3bc8:	82 0f       	add	r24, r18
    3bca:	93 1f       	adc	r25, r19
    3bcc:	ac 01       	movw	r20, r24
    3bce:	42 5b       	subi	r20, 0xB2	; 178
    3bd0:	59 4f       	sbci	r21, 0xF9	; 249
    3bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    3bd4:	9b 81       	ldd	r25, Y+3	; 0x03
    3bd6:	9c 01       	movw	r18, r24
    3bd8:	2e 5f       	subi	r18, 0xFE	; 254
    3bda:	3f 4f       	sbci	r19, 0xFF	; 255
    3bdc:	ca 01       	movw	r24, r20
    3bde:	b9 01       	movw	r22, r18
    3be0:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3be8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3bea:	0f 90       	pop	r0
    3bec:	0f 90       	pop	r0
    3bee:	0f 90       	pop	r0
    3bf0:	0f 90       	pop	r0
    3bf2:	0f 90       	pop	r0
    3bf4:	cf 91       	pop	r28
    3bf6:	df 91       	pop	r29
    3bf8:	08 95       	ret

00003bfa <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3bfa:	df 93       	push	r29
    3bfc:	cf 93       	push	r28
    3bfe:	00 d0       	rcall	.+0      	; 0x3c00 <uxTaskResetEventItemValue+0x6>
    3c00:	cd b7       	in	r28, 0x3d	; 61
    3c02:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3c04:	e0 91 3d 06 	lds	r30, 0x063D
    3c08:	f0 91 3e 06 	lds	r31, 0x063E
    3c0c:	84 85       	ldd	r24, Z+12	; 0x0c
    3c0e:	95 85       	ldd	r25, Z+13	; 0x0d
    3c10:	9a 83       	std	Y+2, r25	; 0x02
    3c12:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3c14:	a0 91 3d 06 	lds	r26, 0x063D
    3c18:	b0 91 3e 06 	lds	r27, 0x063E
    3c1c:	e0 91 3d 06 	lds	r30, 0x063D
    3c20:	f0 91 3e 06 	lds	r31, 0x063E
    3c24:	86 89       	ldd	r24, Z+22	; 0x16
    3c26:	28 2f       	mov	r18, r24
    3c28:	30 e0       	ldi	r19, 0x00	; 0
    3c2a:	83 e0       	ldi	r24, 0x03	; 3
    3c2c:	90 e0       	ldi	r25, 0x00	; 0
    3c2e:	82 1b       	sub	r24, r18
    3c30:	93 0b       	sbc	r25, r19
    3c32:	1d 96       	adiw	r26, 0x0d	; 13
    3c34:	9c 93       	st	X, r25
    3c36:	8e 93       	st	-X, r24
    3c38:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3c3a:	89 81       	ldd	r24, Y+1	; 0x01
    3c3c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c3e:	0f 90       	pop	r0
    3c40:	0f 90       	pop	r0
    3c42:	cf 91       	pop	r28
    3c44:	df 91       	pop	r29
    3c46:	08 95       	ret

00003c48 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    3c48:	df 93       	push	r29
    3c4a:	cf 93       	push	r28
    3c4c:	cd b7       	in	r28, 0x3d	; 61
    3c4e:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    3c50:	80 91 3d 06 	lds	r24, 0x063D
    3c54:	90 91 3e 06 	lds	r25, 0x063E
    3c58:	00 97       	sbiw	r24, 0x00	; 0
    3c5a:	39 f0       	breq	.+14     	; 0x3c6a <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3c5c:	e0 91 3d 06 	lds	r30, 0x063D
    3c60:	f0 91 3e 06 	lds	r31, 0x063E
    3c64:	82 a5       	ldd	r24, Z+42	; 0x2a
    3c66:	8f 5f       	subi	r24, 0xFF	; 255
    3c68:	82 a7       	std	Z+42, r24	; 0x2a
		}

		return pxCurrentTCB;
    3c6a:	80 91 3d 06 	lds	r24, 0x063D
    3c6e:	90 91 3e 06 	lds	r25, 0x063E
	}
    3c72:	cf 91       	pop	r28
    3c74:	df 91       	pop	r29
    3c76:	08 95       	ret

00003c78 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3c78:	df 93       	push	r29
    3c7a:	cf 93       	push	r28
    3c7c:	cd b7       	in	r28, 0x3d	; 61
    3c7e:	de b7       	in	r29, 0x3e	; 62
    3c80:	27 97       	sbiw	r28, 0x07	; 7
    3c82:	0f b6       	in	r0, 0x3f	; 63
    3c84:	f8 94       	cli
    3c86:	de bf       	out	0x3e, r29	; 62
    3c88:	0f be       	out	0x3f, r0	; 63
    3c8a:	cd bf       	out	0x3d, r28	; 61
    3c8c:	8d 83       	std	Y+5, r24	; 0x05
    3c8e:	7f 83       	std	Y+7, r23	; 0x07
    3c90:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3c92:	0f b6       	in	r0, 0x3f	; 63
    3c94:	f8 94       	cli
    3c96:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3c98:	e0 91 3d 06 	lds	r30, 0x063D
    3c9c:	f0 91 3e 06 	lds	r31, 0x063E
    3ca0:	83 a5       	ldd	r24, Z+43	; 0x2b
    3ca2:	94 a5       	ldd	r25, Z+44	; 0x2c
    3ca4:	a5 a5       	ldd	r26, Z+45	; 0x2d
    3ca6:	b6 a5       	ldd	r27, Z+46	; 0x2e
    3ca8:	00 97       	sbiw	r24, 0x00	; 0
    3caa:	a1 05       	cpc	r26, r1
    3cac:	b1 05       	cpc	r27, r1
    3cae:	89 f4       	brne	.+34     	; 0x3cd2 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3cb0:	e0 91 3d 06 	lds	r30, 0x063D
    3cb4:	f0 91 3e 06 	lds	r31, 0x063E
    3cb8:	81 e0       	ldi	r24, 0x01	; 1
    3cba:	87 a7       	std	Z+47, r24	; 0x2f

				if( xTicksToWait > ( TickType_t ) 0 )
    3cbc:	8e 81       	ldd	r24, Y+6	; 0x06
    3cbe:	9f 81       	ldd	r25, Y+7	; 0x07
    3cc0:	00 97       	sbiw	r24, 0x00	; 0
    3cc2:	39 f0       	breq	.+14     	; 0x3cd2 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3cc4:	8e 81       	ldd	r24, Y+6	; 0x06
    3cc6:	9f 81       	ldd	r25, Y+7	; 0x07
    3cc8:	61 e0       	ldi	r22, 0x01	; 1
    3cca:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3cce:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3cd2:	0f 90       	pop	r0
    3cd4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3cd6:	0f b6       	in	r0, 0x3f	; 63
    3cd8:	f8 94       	cli
    3cda:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3cdc:	e0 91 3d 06 	lds	r30, 0x063D
    3ce0:	f0 91 3e 06 	lds	r31, 0x063E
    3ce4:	83 a5       	ldd	r24, Z+43	; 0x2b
    3ce6:	94 a5       	ldd	r25, Z+44	; 0x2c
    3ce8:	a5 a5       	ldd	r26, Z+45	; 0x2d
    3cea:	b6 a5       	ldd	r27, Z+46	; 0x2e
    3cec:	89 83       	std	Y+1, r24	; 0x01
    3cee:	9a 83       	std	Y+2, r25	; 0x02
    3cf0:	ab 83       	std	Y+3, r26	; 0x03
    3cf2:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3cf4:	89 81       	ldd	r24, Y+1	; 0x01
    3cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf8:	ab 81       	ldd	r26, Y+3	; 0x03
    3cfa:	bc 81       	ldd	r27, Y+4	; 0x04
    3cfc:	00 97       	sbiw	r24, 0x00	; 0
    3cfe:	a1 05       	cpc	r26, r1
    3d00:	b1 05       	cpc	r27, r1
    3d02:	d9 f0       	breq	.+54     	; 0x3d3a <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    3d04:	8d 81       	ldd	r24, Y+5	; 0x05
    3d06:	88 23       	and	r24, r24
    3d08:	49 f0       	breq	.+18     	; 0x3d1c <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3d0a:	e0 91 3d 06 	lds	r30, 0x063D
    3d0e:	f0 91 3e 06 	lds	r31, 0x063E
    3d12:	13 a6       	std	Z+43, r1	; 0x2b
    3d14:	14 a6       	std	Z+44, r1	; 0x2c
    3d16:	15 a6       	std	Z+45, r1	; 0x2d
    3d18:	16 a6       	std	Z+46, r1	; 0x2e
    3d1a:	0f c0       	rjmp	.+30     	; 0x3d3a <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    3d1c:	e0 91 3d 06 	lds	r30, 0x063D
    3d20:	f0 91 3e 06 	lds	r31, 0x063E
    3d24:	89 81       	ldd	r24, Y+1	; 0x01
    3d26:	9a 81       	ldd	r25, Y+2	; 0x02
    3d28:	ab 81       	ldd	r26, Y+3	; 0x03
    3d2a:	bc 81       	ldd	r27, Y+4	; 0x04
    3d2c:	01 97       	sbiw	r24, 0x01	; 1
    3d2e:	a1 09       	sbc	r26, r1
    3d30:	b1 09       	sbc	r27, r1
    3d32:	83 a7       	std	Z+43, r24	; 0x2b
    3d34:	94 a7       	std	Z+44, r25	; 0x2c
    3d36:	a5 a7       	std	Z+45, r26	; 0x2d
    3d38:	b6 a7       	std	Z+46, r27	; 0x2e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3d3a:	e0 91 3d 06 	lds	r30, 0x063D
    3d3e:	f0 91 3e 06 	lds	r31, 0x063E
    3d42:	17 a6       	std	Z+47, r1	; 0x2f
		}
		taskEXIT_CRITICAL();
    3d44:	0f 90       	pop	r0
    3d46:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3d48:	89 81       	ldd	r24, Y+1	; 0x01
    3d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4c:	ab 81       	ldd	r26, Y+3	; 0x03
    3d4e:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3d50:	bc 01       	movw	r22, r24
    3d52:	cd 01       	movw	r24, r26
    3d54:	27 96       	adiw	r28, 0x07	; 7
    3d56:	0f b6       	in	r0, 0x3f	; 63
    3d58:	f8 94       	cli
    3d5a:	de bf       	out	0x3e, r29	; 62
    3d5c:	0f be       	out	0x3f, r0	; 63
    3d5e:	cd bf       	out	0x3d, r28	; 61
    3d60:	cf 91       	pop	r28
    3d62:	df 91       	pop	r29
    3d64:	08 95       	ret

00003d66 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3d66:	ef 92       	push	r14
    3d68:	ff 92       	push	r15
    3d6a:	0f 93       	push	r16
    3d6c:	1f 93       	push	r17
    3d6e:	df 93       	push	r29
    3d70:	cf 93       	push	r28
    3d72:	cd b7       	in	r28, 0x3d	; 61
    3d74:	de b7       	in	r29, 0x3e	; 62
    3d76:	2d 97       	sbiw	r28, 0x0d	; 13
    3d78:	0f b6       	in	r0, 0x3f	; 63
    3d7a:	f8 94       	cli
    3d7c:	de bf       	out	0x3e, r29	; 62
    3d7e:	0f be       	out	0x3f, r0	; 63
    3d80:	cd bf       	out	0x3d, r28	; 61
    3d82:	6a 83       	std	Y+2, r22	; 0x02
    3d84:	7b 83       	std	Y+3, r23	; 0x03
    3d86:	8c 83       	std	Y+4, r24	; 0x04
    3d88:	9d 83       	std	Y+5, r25	; 0x05
    3d8a:	2e 83       	std	Y+6, r18	; 0x06
    3d8c:	3f 83       	std	Y+7, r19	; 0x07
    3d8e:	48 87       	std	Y+8, r20	; 0x08
    3d90:	59 87       	std	Y+9, r21	; 0x09
    3d92:	1b 87       	std	Y+11, r17	; 0x0b
    3d94:	0a 87       	std	Y+10, r16	; 0x0a
    3d96:	fd 86       	std	Y+13, r15	; 0x0d
    3d98:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3d9a:	0f b6       	in	r0, 0x3f	; 63
    3d9c:	f8 94       	cli
    3d9e:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3da0:	e0 91 3d 06 	lds	r30, 0x063D
    3da4:	f0 91 3e 06 	lds	r31, 0x063E
    3da8:	87 a5       	ldd	r24, Z+47	; 0x2f
    3daa:	82 30       	cpi	r24, 0x02	; 2
    3dac:	49 f1       	breq	.+82     	; 0x3e00 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3dae:	e0 91 3d 06 	lds	r30, 0x063D
    3db2:	f0 91 3e 06 	lds	r31, 0x063E
    3db6:	23 a5       	ldd	r18, Z+43	; 0x2b
    3db8:	34 a5       	ldd	r19, Z+44	; 0x2c
    3dba:	45 a5       	ldd	r20, Z+45	; 0x2d
    3dbc:	56 a5       	ldd	r21, Z+46	; 0x2e
    3dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc0:	9b 81       	ldd	r25, Y+3	; 0x03
    3dc2:	ac 81       	ldd	r26, Y+4	; 0x04
    3dc4:	bd 81       	ldd	r27, Y+5	; 0x05
    3dc6:	80 95       	com	r24
    3dc8:	90 95       	com	r25
    3dca:	a0 95       	com	r26
    3dcc:	b0 95       	com	r27
    3dce:	82 23       	and	r24, r18
    3dd0:	93 23       	and	r25, r19
    3dd2:	a4 23       	and	r26, r20
    3dd4:	b5 23       	and	r27, r21
    3dd6:	83 a7       	std	Z+43, r24	; 0x2b
    3dd8:	94 a7       	std	Z+44, r25	; 0x2c
    3dda:	a5 a7       	std	Z+45, r26	; 0x2d
    3ddc:	b6 a7       	std	Z+46, r27	; 0x2e

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3dde:	e0 91 3d 06 	lds	r30, 0x063D
    3de2:	f0 91 3e 06 	lds	r31, 0x063E
    3de6:	81 e0       	ldi	r24, 0x01	; 1
    3de8:	87 a7       	std	Z+47, r24	; 0x2f

				if( xTicksToWait > ( TickType_t ) 0 )
    3dea:	8c 85       	ldd	r24, Y+12	; 0x0c
    3dec:	9d 85       	ldd	r25, Y+13	; 0x0d
    3dee:	00 97       	sbiw	r24, 0x00	; 0
    3df0:	39 f0       	breq	.+14     	; 0x3e00 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3df2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3df4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3df6:	61 e0       	ldi	r22, 0x01	; 1
    3df8:	0e 94 e6 21 	call	0x43cc	; 0x43cc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3dfc:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3e00:	0f 90       	pop	r0
    3e02:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3e04:	0f b6       	in	r0, 0x3f	; 63
    3e06:	f8 94       	cli
    3e08:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3e0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e0e:	00 97       	sbiw	r24, 0x00	; 0
    3e10:	71 f0       	breq	.+28     	; 0x3e2e <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3e12:	e0 91 3d 06 	lds	r30, 0x063D
    3e16:	f0 91 3e 06 	lds	r31, 0x063E
    3e1a:	83 a5       	ldd	r24, Z+43	; 0x2b
    3e1c:	94 a5       	ldd	r25, Z+44	; 0x2c
    3e1e:	a5 a5       	ldd	r26, Z+45	; 0x2d
    3e20:	b6 a5       	ldd	r27, Z+46	; 0x2e
    3e22:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e24:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e26:	80 83       	st	Z, r24
    3e28:	91 83       	std	Z+1, r25	; 0x01
    3e2a:	a2 83       	std	Z+2, r26	; 0x02
    3e2c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3e2e:	e0 91 3d 06 	lds	r30, 0x063D
    3e32:	f0 91 3e 06 	lds	r31, 0x063E
    3e36:	87 a5       	ldd	r24, Z+47	; 0x2f
    3e38:	81 30       	cpi	r24, 0x01	; 1
    3e3a:	11 f4       	brne	.+4      	; 0x3e40 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3e3c:	19 82       	std	Y+1, r1	; 0x01
    3e3e:	1a c0       	rjmp	.+52     	; 0x3e74 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3e40:	e0 91 3d 06 	lds	r30, 0x063D
    3e44:	f0 91 3e 06 	lds	r31, 0x063E
    3e48:	23 a5       	ldd	r18, Z+43	; 0x2b
    3e4a:	34 a5       	ldd	r19, Z+44	; 0x2c
    3e4c:	45 a5       	ldd	r20, Z+45	; 0x2d
    3e4e:	56 a5       	ldd	r21, Z+46	; 0x2e
    3e50:	8e 81       	ldd	r24, Y+6	; 0x06
    3e52:	9f 81       	ldd	r25, Y+7	; 0x07
    3e54:	a8 85       	ldd	r26, Y+8	; 0x08
    3e56:	b9 85       	ldd	r27, Y+9	; 0x09
    3e58:	80 95       	com	r24
    3e5a:	90 95       	com	r25
    3e5c:	a0 95       	com	r26
    3e5e:	b0 95       	com	r27
    3e60:	82 23       	and	r24, r18
    3e62:	93 23       	and	r25, r19
    3e64:	a4 23       	and	r26, r20
    3e66:	b5 23       	and	r27, r21
    3e68:	83 a7       	std	Z+43, r24	; 0x2b
    3e6a:	94 a7       	std	Z+44, r25	; 0x2c
    3e6c:	a5 a7       	std	Z+45, r26	; 0x2d
    3e6e:	b6 a7       	std	Z+46, r27	; 0x2e
				xReturn = pdTRUE;
    3e70:	81 e0       	ldi	r24, 0x01	; 1
    3e72:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3e74:	e0 91 3d 06 	lds	r30, 0x063D
    3e78:	f0 91 3e 06 	lds	r31, 0x063E
    3e7c:	17 a6       	std	Z+47, r1	; 0x2f
		}
		taskEXIT_CRITICAL();
    3e7e:	0f 90       	pop	r0
    3e80:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3e82:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3e84:	2d 96       	adiw	r28, 0x0d	; 13
    3e86:	0f b6       	in	r0, 0x3f	; 63
    3e88:	f8 94       	cli
    3e8a:	de bf       	out	0x3e, r29	; 62
    3e8c:	0f be       	out	0x3f, r0	; 63
    3e8e:	cd bf       	out	0x3d, r28	; 61
    3e90:	cf 91       	pop	r28
    3e92:	df 91       	pop	r29
    3e94:	1f 91       	pop	r17
    3e96:	0f 91       	pop	r16
    3e98:	ff 90       	pop	r15
    3e9a:	ef 90       	pop	r14
    3e9c:	08 95       	ret

00003e9e <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3e9e:	0f 93       	push	r16
    3ea0:	1f 93       	push	r17
    3ea2:	df 93       	push	r29
    3ea4:	cf 93       	push	r28
    3ea6:	cd b7       	in	r28, 0x3d	; 61
    3ea8:	de b7       	in	r29, 0x3e	; 62
    3eaa:	2f 97       	sbiw	r28, 0x0f	; 15
    3eac:	0f b6       	in	r0, 0x3f	; 63
    3eae:	f8 94       	cli
    3eb0:	de bf       	out	0x3e, r29	; 62
    3eb2:	0f be       	out	0x3f, r0	; 63
    3eb4:	cd bf       	out	0x3d, r28	; 61
    3eb6:	9e 83       	std	Y+6, r25	; 0x06
    3eb8:	8d 83       	std	Y+5, r24	; 0x05
    3eba:	4f 83       	std	Y+7, r20	; 0x07
    3ebc:	58 87       	std	Y+8, r21	; 0x08
    3ebe:	69 87       	std	Y+9, r22	; 0x09
    3ec0:	7a 87       	std	Y+10, r23	; 0x0a
    3ec2:	2b 87       	std	Y+11, r18	; 0x0b
    3ec4:	1d 87       	std	Y+13, r17	; 0x0d
    3ec6:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    3ec8:	81 e0       	ldi	r24, 0x01	; 1
    3eca:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    3ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    3ece:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed0:	9c 83       	std	Y+4, r25	; 0x04
    3ed2:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    3ed4:	0f b6       	in	r0, 0x3f	; 63
    3ed6:	f8 94       	cli
    3ed8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    3eda:	8c 85       	ldd	r24, Y+12	; 0x0c
    3edc:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ede:	00 97       	sbiw	r24, 0x00	; 0
    3ee0:	61 f0       	breq	.+24     	; 0x3efa <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee6:	83 a5       	ldd	r24, Z+43	; 0x2b
    3ee8:	94 a5       	ldd	r25, Z+44	; 0x2c
    3eea:	a5 a5       	ldd	r26, Z+45	; 0x2d
    3eec:	b6 a5       	ldd	r27, Z+46	; 0x2e
    3eee:	ec 85       	ldd	r30, Y+12	; 0x0c
    3ef0:	fd 85       	ldd	r31, Y+13	; 0x0d
    3ef2:	80 83       	st	Z, r24
    3ef4:	91 83       	std	Z+1, r25	; 0x01
    3ef6:	a2 83       	std	Z+2, r26	; 0x02
    3ef8:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3efa:	eb 81       	ldd	r30, Y+3	; 0x03
    3efc:	fc 81       	ldd	r31, Y+4	; 0x04
    3efe:	87 a5       	ldd	r24, Z+47	; 0x2f
    3f00:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3f02:	eb 81       	ldd	r30, Y+3	; 0x03
    3f04:	fc 81       	ldd	r31, Y+4	; 0x04
    3f06:	82 e0       	ldi	r24, 0x02	; 2
    3f08:	87 a7       	std	Z+47, r24	; 0x2f

			switch( eAction )
    3f0a:	8b 85       	ldd	r24, Y+11	; 0x0b
    3f0c:	28 2f       	mov	r18, r24
    3f0e:	30 e0       	ldi	r19, 0x00	; 0
    3f10:	3f 87       	std	Y+15, r19	; 0x0f
    3f12:	2e 87       	std	Y+14, r18	; 0x0e
    3f14:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f16:	9f 85       	ldd	r25, Y+15	; 0x0f
    3f18:	82 30       	cpi	r24, 0x02	; 2
    3f1a:	91 05       	cpc	r25, r1
    3f1c:	59 f1       	breq	.+86     	; 0x3f74 <xTaskGenericNotify+0xd6>
    3f1e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3f20:	3f 85       	ldd	r19, Y+15	; 0x0f
    3f22:	23 30       	cpi	r18, 0x03	; 3
    3f24:	31 05       	cpc	r19, r1
    3f26:	34 f4       	brge	.+12     	; 0x3f34 <xTaskGenericNotify+0x96>
    3f28:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f2a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3f2c:	81 30       	cpi	r24, 0x01	; 1
    3f2e:	91 05       	cpc	r25, r1
    3f30:	61 f0       	breq	.+24     	; 0x3f4a <xTaskGenericNotify+0xac>
    3f32:	4a c0       	rjmp	.+148    	; 0x3fc8 <xTaskGenericNotify+0x12a>
    3f34:	2e 85       	ldd	r18, Y+14	; 0x0e
    3f36:	3f 85       	ldd	r19, Y+15	; 0x0f
    3f38:	23 30       	cpi	r18, 0x03	; 3
    3f3a:	31 05       	cpc	r19, r1
    3f3c:	59 f1       	breq	.+86     	; 0x3f94 <xTaskGenericNotify+0xf6>
    3f3e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f40:	9f 85       	ldd	r25, Y+15	; 0x0f
    3f42:	84 30       	cpi	r24, 0x04	; 4
    3f44:	91 05       	cpc	r25, r1
    3f46:	89 f1       	breq	.+98     	; 0x3faa <xTaskGenericNotify+0x10c>
    3f48:	3f c0       	rjmp	.+126    	; 0x3fc8 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f4e:	23 a5       	ldd	r18, Z+43	; 0x2b
    3f50:	34 a5       	ldd	r19, Z+44	; 0x2c
    3f52:	45 a5       	ldd	r20, Z+45	; 0x2d
    3f54:	56 a5       	ldd	r21, Z+46	; 0x2e
    3f56:	8f 81       	ldd	r24, Y+7	; 0x07
    3f58:	98 85       	ldd	r25, Y+8	; 0x08
    3f5a:	a9 85       	ldd	r26, Y+9	; 0x09
    3f5c:	ba 85       	ldd	r27, Y+10	; 0x0a
    3f5e:	82 2b       	or	r24, r18
    3f60:	93 2b       	or	r25, r19
    3f62:	a4 2b       	or	r26, r20
    3f64:	b5 2b       	or	r27, r21
    3f66:	eb 81       	ldd	r30, Y+3	; 0x03
    3f68:	fc 81       	ldd	r31, Y+4	; 0x04
    3f6a:	83 a7       	std	Z+43, r24	; 0x2b
    3f6c:	94 a7       	std	Z+44, r25	; 0x2c
    3f6e:	a5 a7       	std	Z+45, r26	; 0x2d
    3f70:	b6 a7       	std	Z+46, r27	; 0x2e
    3f72:	2a c0       	rjmp	.+84     	; 0x3fc8 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3f74:	eb 81       	ldd	r30, Y+3	; 0x03
    3f76:	fc 81       	ldd	r31, Y+4	; 0x04
    3f78:	83 a5       	ldd	r24, Z+43	; 0x2b
    3f7a:	94 a5       	ldd	r25, Z+44	; 0x2c
    3f7c:	a5 a5       	ldd	r26, Z+45	; 0x2d
    3f7e:	b6 a5       	ldd	r27, Z+46	; 0x2e
    3f80:	01 96       	adiw	r24, 0x01	; 1
    3f82:	a1 1d       	adc	r26, r1
    3f84:	b1 1d       	adc	r27, r1
    3f86:	eb 81       	ldd	r30, Y+3	; 0x03
    3f88:	fc 81       	ldd	r31, Y+4	; 0x04
    3f8a:	83 a7       	std	Z+43, r24	; 0x2b
    3f8c:	94 a7       	std	Z+44, r25	; 0x2c
    3f8e:	a5 a7       	std	Z+45, r26	; 0x2d
    3f90:	b6 a7       	std	Z+46, r27	; 0x2e
    3f92:	1a c0       	rjmp	.+52     	; 0x3fc8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3f94:	eb 81       	ldd	r30, Y+3	; 0x03
    3f96:	fc 81       	ldd	r31, Y+4	; 0x04
    3f98:	8f 81       	ldd	r24, Y+7	; 0x07
    3f9a:	98 85       	ldd	r25, Y+8	; 0x08
    3f9c:	a9 85       	ldd	r26, Y+9	; 0x09
    3f9e:	ba 85       	ldd	r27, Y+10	; 0x0a
    3fa0:	83 a7       	std	Z+43, r24	; 0x2b
    3fa2:	94 a7       	std	Z+44, r25	; 0x2c
    3fa4:	a5 a7       	std	Z+45, r26	; 0x2d
    3fa6:	b6 a7       	std	Z+46, r27	; 0x2e
    3fa8:	0f c0       	rjmp	.+30     	; 0x3fc8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3faa:	89 81       	ldd	r24, Y+1	; 0x01
    3fac:	82 30       	cpi	r24, 0x02	; 2
    3fae:	59 f0       	breq	.+22     	; 0x3fc6 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb4:	8f 81       	ldd	r24, Y+7	; 0x07
    3fb6:	98 85       	ldd	r25, Y+8	; 0x08
    3fb8:	a9 85       	ldd	r26, Y+9	; 0x09
    3fba:	ba 85       	ldd	r27, Y+10	; 0x0a
    3fbc:	83 a7       	std	Z+43, r24	; 0x2b
    3fbe:	94 a7       	std	Z+44, r25	; 0x2c
    3fc0:	a5 a7       	std	Z+45, r26	; 0x2d
    3fc2:	b6 a7       	std	Z+46, r27	; 0x2e
    3fc4:	01 c0       	rjmp	.+2      	; 0x3fc8 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3fc6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3fc8:	89 81       	ldd	r24, Y+1	; 0x01
    3fca:	81 30       	cpi	r24, 0x01	; 1
    3fcc:	b9 f5       	brne	.+110    	; 0x403c <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3fce:	8b 81       	ldd	r24, Y+3	; 0x03
    3fd0:	9c 81       	ldd	r25, Y+4	; 0x04
    3fd2:	02 96       	adiw	r24, 0x02	; 2
    3fd4:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    3fd8:	eb 81       	ldd	r30, Y+3	; 0x03
    3fda:	fc 81       	ldd	r31, Y+4	; 0x04
    3fdc:	96 89       	ldd	r25, Z+22	; 0x16
    3fde:	80 91 43 06 	lds	r24, 0x0643
    3fe2:	89 17       	cp	r24, r25
    3fe4:	28 f4       	brcc	.+10     	; 0x3ff0 <xTaskGenericNotify+0x152>
    3fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    3fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    3fea:	86 89       	ldd	r24, Z+22	; 0x16
    3fec:	80 93 43 06 	sts	0x0643, r24
    3ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ff4:	86 89       	ldd	r24, Z+22	; 0x16
    3ff6:	28 2f       	mov	r18, r24
    3ff8:	30 e0       	ldi	r19, 0x00	; 0
    3ffa:	c9 01       	movw	r24, r18
    3ffc:	88 0f       	add	r24, r24
    3ffe:	99 1f       	adc	r25, r25
    4000:	88 0f       	add	r24, r24
    4002:	99 1f       	adc	r25, r25
    4004:	88 0f       	add	r24, r24
    4006:	99 1f       	adc	r25, r25
    4008:	82 0f       	add	r24, r18
    400a:	93 1f       	adc	r25, r19
    400c:	ac 01       	movw	r20, r24
    400e:	42 5b       	subi	r20, 0xB2	; 178
    4010:	59 4f       	sbci	r21, 0xF9	; 249
    4012:	8b 81       	ldd	r24, Y+3	; 0x03
    4014:	9c 81       	ldd	r25, Y+4	; 0x04
    4016:	9c 01       	movw	r18, r24
    4018:	2e 5f       	subi	r18, 0xFE	; 254
    401a:	3f 4f       	sbci	r19, 0xFF	; 255
    401c:	ca 01       	movw	r24, r20
    401e:	b9 01       	movw	r22, r18
    4020:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4024:	eb 81       	ldd	r30, Y+3	; 0x03
    4026:	fc 81       	ldd	r31, Y+4	; 0x04
    4028:	96 89       	ldd	r25, Z+22	; 0x16
    402a:	e0 91 3d 06 	lds	r30, 0x063D
    402e:	f0 91 3e 06 	lds	r31, 0x063E
    4032:	86 89       	ldd	r24, Z+22	; 0x16
    4034:	89 17       	cp	r24, r25
    4036:	10 f4       	brcc	.+4      	; 0x403c <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4038:	0e 94 a8 0b 	call	0x1750	; 0x1750 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    403c:	0f 90       	pop	r0
    403e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4040:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4042:	2f 96       	adiw	r28, 0x0f	; 15
    4044:	0f b6       	in	r0, 0x3f	; 63
    4046:	f8 94       	cli
    4048:	de bf       	out	0x3e, r29	; 62
    404a:	0f be       	out	0x3f, r0	; 63
    404c:	cd bf       	out	0x3d, r28	; 61
    404e:	cf 91       	pop	r28
    4050:	df 91       	pop	r29
    4052:	1f 91       	pop	r17
    4054:	0f 91       	pop	r16
    4056:	08 95       	ret

00004058 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4058:	ef 92       	push	r14
    405a:	ff 92       	push	r15
    405c:	0f 93       	push	r16
    405e:	1f 93       	push	r17
    4060:	df 93       	push	r29
    4062:	cf 93       	push	r28
    4064:	cd b7       	in	r28, 0x3d	; 61
    4066:	de b7       	in	r29, 0x3e	; 62
    4068:	62 97       	sbiw	r28, 0x12	; 18
    406a:	0f b6       	in	r0, 0x3f	; 63
    406c:	f8 94       	cli
    406e:	de bf       	out	0x3e, r29	; 62
    4070:	0f be       	out	0x3f, r0	; 63
    4072:	cd bf       	out	0x3d, r28	; 61
    4074:	9f 83       	std	Y+7, r25	; 0x07
    4076:	8e 83       	std	Y+6, r24	; 0x06
    4078:	48 87       	std	Y+8, r20	; 0x08
    407a:	59 87       	std	Y+9, r21	; 0x09
    407c:	6a 87       	std	Y+10, r22	; 0x0a
    407e:	7b 87       	std	Y+11, r23	; 0x0b
    4080:	2c 87       	std	Y+12, r18	; 0x0c
    4082:	1e 87       	std	Y+14, r17	; 0x0e
    4084:	0d 87       	std	Y+13, r16	; 0x0d
    4086:	f8 8a       	std	Y+16, r15	; 0x10
    4088:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    408a:	81 e0       	ldi	r24, 0x01	; 1
    408c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    408e:	8e 81       	ldd	r24, Y+6	; 0x06
    4090:	9f 81       	ldd	r25, Y+7	; 0x07
    4092:	9d 83       	std	Y+5, r25	; 0x05
    4094:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4096:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    4098:	8d 85       	ldd	r24, Y+13	; 0x0d
    409a:	9e 85       	ldd	r25, Y+14	; 0x0e
    409c:	00 97       	sbiw	r24, 0x00	; 0
    409e:	61 f0       	breq	.+24     	; 0x40b8 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    40a0:	ec 81       	ldd	r30, Y+4	; 0x04
    40a2:	fd 81       	ldd	r31, Y+5	; 0x05
    40a4:	83 a5       	ldd	r24, Z+43	; 0x2b
    40a6:	94 a5       	ldd	r25, Z+44	; 0x2c
    40a8:	a5 a5       	ldd	r26, Z+45	; 0x2d
    40aa:	b6 a5       	ldd	r27, Z+46	; 0x2e
    40ac:	ed 85       	ldd	r30, Y+13	; 0x0d
    40ae:	fe 85       	ldd	r31, Y+14	; 0x0e
    40b0:	80 83       	st	Z, r24
    40b2:	91 83       	std	Z+1, r25	; 0x01
    40b4:	a2 83       	std	Z+2, r26	; 0x02
    40b6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    40b8:	ec 81       	ldd	r30, Y+4	; 0x04
    40ba:	fd 81       	ldd	r31, Y+5	; 0x05
    40bc:	87 a5       	ldd	r24, Z+47	; 0x2f
    40be:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    40c0:	ec 81       	ldd	r30, Y+4	; 0x04
    40c2:	fd 81       	ldd	r31, Y+5	; 0x05
    40c4:	82 e0       	ldi	r24, 0x02	; 2
    40c6:	87 a7       	std	Z+47, r24	; 0x2f

			switch( eAction )
    40c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    40ca:	28 2f       	mov	r18, r24
    40cc:	30 e0       	ldi	r19, 0x00	; 0
    40ce:	3a 8b       	std	Y+18, r19	; 0x12
    40d0:	29 8b       	std	Y+17, r18	; 0x11
    40d2:	89 89       	ldd	r24, Y+17	; 0x11
    40d4:	9a 89       	ldd	r25, Y+18	; 0x12
    40d6:	82 30       	cpi	r24, 0x02	; 2
    40d8:	91 05       	cpc	r25, r1
    40da:	59 f1       	breq	.+86     	; 0x4132 <xTaskGenericNotifyFromISR+0xda>
    40dc:	29 89       	ldd	r18, Y+17	; 0x11
    40de:	3a 89       	ldd	r19, Y+18	; 0x12
    40e0:	23 30       	cpi	r18, 0x03	; 3
    40e2:	31 05       	cpc	r19, r1
    40e4:	34 f4       	brge	.+12     	; 0x40f2 <xTaskGenericNotifyFromISR+0x9a>
    40e6:	89 89       	ldd	r24, Y+17	; 0x11
    40e8:	9a 89       	ldd	r25, Y+18	; 0x12
    40ea:	81 30       	cpi	r24, 0x01	; 1
    40ec:	91 05       	cpc	r25, r1
    40ee:	61 f0       	breq	.+24     	; 0x4108 <xTaskGenericNotifyFromISR+0xb0>
    40f0:	4a c0       	rjmp	.+148    	; 0x4186 <xTaskGenericNotifyFromISR+0x12e>
    40f2:	29 89       	ldd	r18, Y+17	; 0x11
    40f4:	3a 89       	ldd	r19, Y+18	; 0x12
    40f6:	23 30       	cpi	r18, 0x03	; 3
    40f8:	31 05       	cpc	r19, r1
    40fa:	59 f1       	breq	.+86     	; 0x4152 <xTaskGenericNotifyFromISR+0xfa>
    40fc:	89 89       	ldd	r24, Y+17	; 0x11
    40fe:	9a 89       	ldd	r25, Y+18	; 0x12
    4100:	84 30       	cpi	r24, 0x04	; 4
    4102:	91 05       	cpc	r25, r1
    4104:	89 f1       	breq	.+98     	; 0x4168 <xTaskGenericNotifyFromISR+0x110>
    4106:	3f c0       	rjmp	.+126    	; 0x4186 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4108:	ec 81       	ldd	r30, Y+4	; 0x04
    410a:	fd 81       	ldd	r31, Y+5	; 0x05
    410c:	23 a5       	ldd	r18, Z+43	; 0x2b
    410e:	34 a5       	ldd	r19, Z+44	; 0x2c
    4110:	45 a5       	ldd	r20, Z+45	; 0x2d
    4112:	56 a5       	ldd	r21, Z+46	; 0x2e
    4114:	88 85       	ldd	r24, Y+8	; 0x08
    4116:	99 85       	ldd	r25, Y+9	; 0x09
    4118:	aa 85       	ldd	r26, Y+10	; 0x0a
    411a:	bb 85       	ldd	r27, Y+11	; 0x0b
    411c:	82 2b       	or	r24, r18
    411e:	93 2b       	or	r25, r19
    4120:	a4 2b       	or	r26, r20
    4122:	b5 2b       	or	r27, r21
    4124:	ec 81       	ldd	r30, Y+4	; 0x04
    4126:	fd 81       	ldd	r31, Y+5	; 0x05
    4128:	83 a7       	std	Z+43, r24	; 0x2b
    412a:	94 a7       	std	Z+44, r25	; 0x2c
    412c:	a5 a7       	std	Z+45, r26	; 0x2d
    412e:	b6 a7       	std	Z+46, r27	; 0x2e
    4130:	2a c0       	rjmp	.+84     	; 0x4186 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4132:	ec 81       	ldd	r30, Y+4	; 0x04
    4134:	fd 81       	ldd	r31, Y+5	; 0x05
    4136:	83 a5       	ldd	r24, Z+43	; 0x2b
    4138:	94 a5       	ldd	r25, Z+44	; 0x2c
    413a:	a5 a5       	ldd	r26, Z+45	; 0x2d
    413c:	b6 a5       	ldd	r27, Z+46	; 0x2e
    413e:	01 96       	adiw	r24, 0x01	; 1
    4140:	a1 1d       	adc	r26, r1
    4142:	b1 1d       	adc	r27, r1
    4144:	ec 81       	ldd	r30, Y+4	; 0x04
    4146:	fd 81       	ldd	r31, Y+5	; 0x05
    4148:	83 a7       	std	Z+43, r24	; 0x2b
    414a:	94 a7       	std	Z+44, r25	; 0x2c
    414c:	a5 a7       	std	Z+45, r26	; 0x2d
    414e:	b6 a7       	std	Z+46, r27	; 0x2e
    4150:	1a c0       	rjmp	.+52     	; 0x4186 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4152:	ec 81       	ldd	r30, Y+4	; 0x04
    4154:	fd 81       	ldd	r31, Y+5	; 0x05
    4156:	88 85       	ldd	r24, Y+8	; 0x08
    4158:	99 85       	ldd	r25, Y+9	; 0x09
    415a:	aa 85       	ldd	r26, Y+10	; 0x0a
    415c:	bb 85       	ldd	r27, Y+11	; 0x0b
    415e:	83 a7       	std	Z+43, r24	; 0x2b
    4160:	94 a7       	std	Z+44, r25	; 0x2c
    4162:	a5 a7       	std	Z+45, r26	; 0x2d
    4164:	b6 a7       	std	Z+46, r27	; 0x2e
    4166:	0f c0       	rjmp	.+30     	; 0x4186 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4168:	8b 81       	ldd	r24, Y+3	; 0x03
    416a:	82 30       	cpi	r24, 0x02	; 2
    416c:	59 f0       	breq	.+22     	; 0x4184 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    416e:	ec 81       	ldd	r30, Y+4	; 0x04
    4170:	fd 81       	ldd	r31, Y+5	; 0x05
    4172:	88 85       	ldd	r24, Y+8	; 0x08
    4174:	99 85       	ldd	r25, Y+9	; 0x09
    4176:	aa 85       	ldd	r26, Y+10	; 0x0a
    4178:	bb 85       	ldd	r27, Y+11	; 0x0b
    417a:	83 a7       	std	Z+43, r24	; 0x2b
    417c:	94 a7       	std	Z+44, r25	; 0x2c
    417e:	a5 a7       	std	Z+45, r26	; 0x2d
    4180:	b6 a7       	std	Z+46, r27	; 0x2e
    4182:	01 c0       	rjmp	.+2      	; 0x4186 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4184:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4186:	8b 81       	ldd	r24, Y+3	; 0x03
    4188:	81 30       	cpi	r24, 0x01	; 1
    418a:	09 f0       	breq	.+2      	; 0x418e <xTaskGenericNotifyFromISR+0x136>
    418c:	50 c0       	rjmp	.+160    	; 0x422e <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    418e:	80 91 4d 06 	lds	r24, 0x064D
    4192:	88 23       	and	r24, r24
    4194:	61 f5       	brne	.+88     	; 0x41ee <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4196:	8c 81       	ldd	r24, Y+4	; 0x04
    4198:	9d 81       	ldd	r25, Y+5	; 0x05
    419a:	02 96       	adiw	r24, 0x02	; 2
    419c:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    41a0:	ec 81       	ldd	r30, Y+4	; 0x04
    41a2:	fd 81       	ldd	r31, Y+5	; 0x05
    41a4:	96 89       	ldd	r25, Z+22	; 0x16
    41a6:	80 91 43 06 	lds	r24, 0x0643
    41aa:	89 17       	cp	r24, r25
    41ac:	28 f4       	brcc	.+10     	; 0x41b8 <xTaskGenericNotifyFromISR+0x160>
    41ae:	ec 81       	ldd	r30, Y+4	; 0x04
    41b0:	fd 81       	ldd	r31, Y+5	; 0x05
    41b2:	86 89       	ldd	r24, Z+22	; 0x16
    41b4:	80 93 43 06 	sts	0x0643, r24
    41b8:	ec 81       	ldd	r30, Y+4	; 0x04
    41ba:	fd 81       	ldd	r31, Y+5	; 0x05
    41bc:	86 89       	ldd	r24, Z+22	; 0x16
    41be:	28 2f       	mov	r18, r24
    41c0:	30 e0       	ldi	r19, 0x00	; 0
    41c2:	c9 01       	movw	r24, r18
    41c4:	88 0f       	add	r24, r24
    41c6:	99 1f       	adc	r25, r25
    41c8:	88 0f       	add	r24, r24
    41ca:	99 1f       	adc	r25, r25
    41cc:	88 0f       	add	r24, r24
    41ce:	99 1f       	adc	r25, r25
    41d0:	82 0f       	add	r24, r18
    41d2:	93 1f       	adc	r25, r19
    41d4:	ac 01       	movw	r20, r24
    41d6:	42 5b       	subi	r20, 0xB2	; 178
    41d8:	59 4f       	sbci	r21, 0xF9	; 249
    41da:	8c 81       	ldd	r24, Y+4	; 0x04
    41dc:	9d 81       	ldd	r25, Y+5	; 0x05
    41de:	9c 01       	movw	r18, r24
    41e0:	2e 5f       	subi	r18, 0xFE	; 254
    41e2:	3f 4f       	sbci	r19, 0xFF	; 255
    41e4:	ca 01       	movw	r24, r20
    41e6:	b9 01       	movw	r22, r18
    41e8:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    41ec:	0a c0       	rjmp	.+20     	; 0x4202 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    41ee:	8c 81       	ldd	r24, Y+4	; 0x04
    41f0:	9d 81       	ldd	r25, Y+5	; 0x05
    41f2:	9c 01       	movw	r18, r24
    41f4:	24 5f       	subi	r18, 0xF4	; 244
    41f6:	3f 4f       	sbci	r19, 0xFF	; 255
    41f8:	8f e7       	ldi	r24, 0x7F	; 127
    41fa:	96 e0       	ldi	r25, 0x06	; 6
    41fc:	b9 01       	movw	r22, r18
    41fe:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4202:	ec 81       	ldd	r30, Y+4	; 0x04
    4204:	fd 81       	ldd	r31, Y+5	; 0x05
    4206:	96 89       	ldd	r25, Z+22	; 0x16
    4208:	e0 91 3d 06 	lds	r30, 0x063D
    420c:	f0 91 3e 06 	lds	r31, 0x063E
    4210:	86 89       	ldd	r24, Z+22	; 0x16
    4212:	89 17       	cp	r24, r25
    4214:	60 f4       	brcc	.+24     	; 0x422e <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4216:	8f 85       	ldd	r24, Y+15	; 0x0f
    4218:	98 89       	ldd	r25, Y+16	; 0x10
    421a:	00 97       	sbiw	r24, 0x00	; 0
    421c:	29 f0       	breq	.+10     	; 0x4228 <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    421e:	ef 85       	ldd	r30, Y+15	; 0x0f
    4220:	f8 89       	ldd	r31, Y+16	; 0x10
    4222:	81 e0       	ldi	r24, 0x01	; 1
    4224:	80 83       	st	Z, r24
    4226:	03 c0       	rjmp	.+6      	; 0x422e <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    4228:	81 e0       	ldi	r24, 0x01	; 1
    422a:	80 93 46 06 	sts	0x0646, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    422e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4230:	62 96       	adiw	r28, 0x12	; 18
    4232:	0f b6       	in	r0, 0x3f	; 63
    4234:	f8 94       	cli
    4236:	de bf       	out	0x3e, r29	; 62
    4238:	0f be       	out	0x3f, r0	; 63
    423a:	cd bf       	out	0x3d, r28	; 61
    423c:	cf 91       	pop	r28
    423e:	df 91       	pop	r29
    4240:	1f 91       	pop	r17
    4242:	0f 91       	pop	r16
    4244:	ff 90       	pop	r15
    4246:	ef 90       	pop	r14
    4248:	08 95       	ret

0000424a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    424a:	df 93       	push	r29
    424c:	cf 93       	push	r28
    424e:	cd b7       	in	r28, 0x3d	; 61
    4250:	de b7       	in	r29, 0x3e	; 62
    4252:	28 97       	sbiw	r28, 0x08	; 8
    4254:	0f b6       	in	r0, 0x3f	; 63
    4256:	f8 94       	cli
    4258:	de bf       	out	0x3e, r29	; 62
    425a:	0f be       	out	0x3f, r0	; 63
    425c:	cd bf       	out	0x3d, r28	; 61
    425e:	9e 83       	std	Y+6, r25	; 0x06
    4260:	8d 83       	std	Y+5, r24	; 0x05
    4262:	78 87       	std	Y+8, r23	; 0x08
    4264:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4266:	8d 81       	ldd	r24, Y+5	; 0x05
    4268:	9e 81       	ldd	r25, Y+6	; 0x06
    426a:	9c 83       	std	Y+4, r25	; 0x04
    426c:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    426e:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4270:	eb 81       	ldd	r30, Y+3	; 0x03
    4272:	fc 81       	ldd	r31, Y+4	; 0x04
    4274:	87 a5       	ldd	r24, Z+47	; 0x2f
    4276:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4278:	eb 81       	ldd	r30, Y+3	; 0x03
    427a:	fc 81       	ldd	r31, Y+4	; 0x04
    427c:	82 e0       	ldi	r24, 0x02	; 2
    427e:	87 a7       	std	Z+47, r24	; 0x2f

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4280:	eb 81       	ldd	r30, Y+3	; 0x03
    4282:	fc 81       	ldd	r31, Y+4	; 0x04
    4284:	83 a5       	ldd	r24, Z+43	; 0x2b
    4286:	94 a5       	ldd	r25, Z+44	; 0x2c
    4288:	a5 a5       	ldd	r26, Z+45	; 0x2d
    428a:	b6 a5       	ldd	r27, Z+46	; 0x2e
    428c:	01 96       	adiw	r24, 0x01	; 1
    428e:	a1 1d       	adc	r26, r1
    4290:	b1 1d       	adc	r27, r1
    4292:	eb 81       	ldd	r30, Y+3	; 0x03
    4294:	fc 81       	ldd	r31, Y+4	; 0x04
    4296:	83 a7       	std	Z+43, r24	; 0x2b
    4298:	94 a7       	std	Z+44, r25	; 0x2c
    429a:	a5 a7       	std	Z+45, r26	; 0x2d
    429c:	b6 a7       	std	Z+46, r27	; 0x2e

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    429e:	8a 81       	ldd	r24, Y+2	; 0x02
    42a0:	81 30       	cpi	r24, 0x01	; 1
    42a2:	09 f0       	breq	.+2      	; 0x42a6 <vTaskNotifyGiveFromISR+0x5c>
    42a4:	50 c0       	rjmp	.+160    	; 0x4346 <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    42a6:	80 91 4d 06 	lds	r24, 0x064D
    42aa:	88 23       	and	r24, r24
    42ac:	61 f5       	brne	.+88     	; 0x4306 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    42ae:	8b 81       	ldd	r24, Y+3	; 0x03
    42b0:	9c 81       	ldd	r25, Y+4	; 0x04
    42b2:	02 96       	adiw	r24, 0x02	; 2
    42b4:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    42b8:	eb 81       	ldd	r30, Y+3	; 0x03
    42ba:	fc 81       	ldd	r31, Y+4	; 0x04
    42bc:	96 89       	ldd	r25, Z+22	; 0x16
    42be:	80 91 43 06 	lds	r24, 0x0643
    42c2:	89 17       	cp	r24, r25
    42c4:	28 f4       	brcc	.+10     	; 0x42d0 <vTaskNotifyGiveFromISR+0x86>
    42c6:	eb 81       	ldd	r30, Y+3	; 0x03
    42c8:	fc 81       	ldd	r31, Y+4	; 0x04
    42ca:	86 89       	ldd	r24, Z+22	; 0x16
    42cc:	80 93 43 06 	sts	0x0643, r24
    42d0:	eb 81       	ldd	r30, Y+3	; 0x03
    42d2:	fc 81       	ldd	r31, Y+4	; 0x04
    42d4:	86 89       	ldd	r24, Z+22	; 0x16
    42d6:	28 2f       	mov	r18, r24
    42d8:	30 e0       	ldi	r19, 0x00	; 0
    42da:	c9 01       	movw	r24, r18
    42dc:	88 0f       	add	r24, r24
    42de:	99 1f       	adc	r25, r25
    42e0:	88 0f       	add	r24, r24
    42e2:	99 1f       	adc	r25, r25
    42e4:	88 0f       	add	r24, r24
    42e6:	99 1f       	adc	r25, r25
    42e8:	82 0f       	add	r24, r18
    42ea:	93 1f       	adc	r25, r19
    42ec:	ac 01       	movw	r20, r24
    42ee:	42 5b       	subi	r20, 0xB2	; 178
    42f0:	59 4f       	sbci	r21, 0xF9	; 249
    42f2:	8b 81       	ldd	r24, Y+3	; 0x03
    42f4:	9c 81       	ldd	r25, Y+4	; 0x04
    42f6:	9c 01       	movw	r18, r24
    42f8:	2e 5f       	subi	r18, 0xFE	; 254
    42fa:	3f 4f       	sbci	r19, 0xFF	; 255
    42fc:	ca 01       	movw	r24, r20
    42fe:	b9 01       	movw	r22, r18
    4300:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    4304:	0a c0       	rjmp	.+20     	; 0x431a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4306:	8b 81       	ldd	r24, Y+3	; 0x03
    4308:	9c 81       	ldd	r25, Y+4	; 0x04
    430a:	9c 01       	movw	r18, r24
    430c:	24 5f       	subi	r18, 0xF4	; 244
    430e:	3f 4f       	sbci	r19, 0xFF	; 255
    4310:	8f e7       	ldi	r24, 0x7F	; 127
    4312:	96 e0       	ldi	r25, 0x06	; 6
    4314:	b9 01       	movw	r22, r18
    4316:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    431a:	eb 81       	ldd	r30, Y+3	; 0x03
    431c:	fc 81       	ldd	r31, Y+4	; 0x04
    431e:	96 89       	ldd	r25, Z+22	; 0x16
    4320:	e0 91 3d 06 	lds	r30, 0x063D
    4324:	f0 91 3e 06 	lds	r31, 0x063E
    4328:	86 89       	ldd	r24, Z+22	; 0x16
    432a:	89 17       	cp	r24, r25
    432c:	60 f4       	brcc	.+24     	; 0x4346 <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    432e:	8f 81       	ldd	r24, Y+7	; 0x07
    4330:	98 85       	ldd	r25, Y+8	; 0x08
    4332:	00 97       	sbiw	r24, 0x00	; 0
    4334:	29 f0       	breq	.+10     	; 0x4340 <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4336:	ef 81       	ldd	r30, Y+7	; 0x07
    4338:	f8 85       	ldd	r31, Y+8	; 0x08
    433a:	81 e0       	ldi	r24, 0x01	; 1
    433c:	80 83       	st	Z, r24
    433e:	03 c0       	rjmp	.+6      	; 0x4346 <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    4340:	81 e0       	ldi	r24, 0x01	; 1
    4342:	80 93 46 06 	sts	0x0646, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4346:	28 96       	adiw	r28, 0x08	; 8
    4348:	0f b6       	in	r0, 0x3f	; 63
    434a:	f8 94       	cli
    434c:	de bf       	out	0x3e, r29	; 62
    434e:	0f be       	out	0x3f, r0	; 63
    4350:	cd bf       	out	0x3d, r28	; 61
    4352:	cf 91       	pop	r28
    4354:	df 91       	pop	r29
    4356:	08 95       	ret

00004358 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4358:	df 93       	push	r29
    435a:	cf 93       	push	r28
    435c:	cd b7       	in	r28, 0x3d	; 61
    435e:	de b7       	in	r29, 0x3e	; 62
    4360:	27 97       	sbiw	r28, 0x07	; 7
    4362:	0f b6       	in	r0, 0x3f	; 63
    4364:	f8 94       	cli
    4366:	de bf       	out	0x3e, r29	; 62
    4368:	0f be       	out	0x3f, r0	; 63
    436a:	cd bf       	out	0x3d, r28	; 61
    436c:	9d 83       	std	Y+5, r25	; 0x05
    436e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4370:	8c 81       	ldd	r24, Y+4	; 0x04
    4372:	9d 81       	ldd	r25, Y+5	; 0x05
    4374:	00 97       	sbiw	r24, 0x00	; 0
    4376:	39 f4       	brne	.+14     	; 0x4386 <xTaskNotifyStateClear+0x2e>
    4378:	80 91 3d 06 	lds	r24, 0x063D
    437c:	90 91 3e 06 	lds	r25, 0x063E
    4380:	9f 83       	std	Y+7, r25	; 0x07
    4382:	8e 83       	std	Y+6, r24	; 0x06
    4384:	04 c0       	rjmp	.+8      	; 0x438e <xTaskNotifyStateClear+0x36>
    4386:	8c 81       	ldd	r24, Y+4	; 0x04
    4388:	9d 81       	ldd	r25, Y+5	; 0x05
    438a:	9f 83       	std	Y+7, r25	; 0x07
    438c:	8e 83       	std	Y+6, r24	; 0x06
    438e:	8e 81       	ldd	r24, Y+6	; 0x06
    4390:	9f 81       	ldd	r25, Y+7	; 0x07
    4392:	9b 83       	std	Y+3, r25	; 0x03
    4394:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4396:	0f b6       	in	r0, 0x3f	; 63
    4398:	f8 94       	cli
    439a:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    439c:	ea 81       	ldd	r30, Y+2	; 0x02
    439e:	fb 81       	ldd	r31, Y+3	; 0x03
    43a0:	87 a5       	ldd	r24, Z+47	; 0x2f
    43a2:	82 30       	cpi	r24, 0x02	; 2
    43a4:	31 f4       	brne	.+12     	; 0x43b2 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    43a6:	ea 81       	ldd	r30, Y+2	; 0x02
    43a8:	fb 81       	ldd	r31, Y+3	; 0x03
    43aa:	17 a6       	std	Z+47, r1	; 0x2f
				xReturn = pdPASS;
    43ac:	81 e0       	ldi	r24, 0x01	; 1
    43ae:	89 83       	std	Y+1, r24	; 0x01
    43b0:	01 c0       	rjmp	.+2      	; 0x43b4 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    43b2:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    43b4:	0f 90       	pop	r0
    43b6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    43b8:	89 81       	ldd	r24, Y+1	; 0x01
	}
    43ba:	27 96       	adiw	r28, 0x07	; 7
    43bc:	0f b6       	in	r0, 0x3f	; 63
    43be:	f8 94       	cli
    43c0:	de bf       	out	0x3e, r29	; 62
    43c2:	0f be       	out	0x3f, r0	; 63
    43c4:	cd bf       	out	0x3d, r28	; 61
    43c6:	cf 91       	pop	r28
    43c8:	df 91       	pop	r29
    43ca:	08 95       	ret

000043cc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    43cc:	df 93       	push	r29
    43ce:	cf 93       	push	r28
    43d0:	cd b7       	in	r28, 0x3d	; 61
    43d2:	de b7       	in	r29, 0x3e	; 62
    43d4:	27 97       	sbiw	r28, 0x07	; 7
    43d6:	0f b6       	in	r0, 0x3f	; 63
    43d8:	f8 94       	cli
    43da:	de bf       	out	0x3e, r29	; 62
    43dc:	0f be       	out	0x3f, r0	; 63
    43de:	cd bf       	out	0x3d, r28	; 61
    43e0:	9e 83       	std	Y+6, r25	; 0x06
    43e2:	8d 83       	std	Y+5, r24	; 0x05
    43e4:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    43e6:	80 91 41 06 	lds	r24, 0x0641
    43ea:	90 91 42 06 	lds	r25, 0x0642
    43ee:	9a 83       	std	Y+2, r25	; 0x02
    43f0:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    43f2:	80 91 3d 06 	lds	r24, 0x063D
    43f6:	90 91 3e 06 	lds	r25, 0x063E
    43fa:	02 96       	adiw	r24, 0x02	; 2
    43fc:	0e 94 9d 09 	call	0x133a	; 0x133a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4400:	8d 81       	ldd	r24, Y+5	; 0x05
    4402:	9e 81       	ldd	r25, Y+6	; 0x06
    4404:	2f ef       	ldi	r18, 0xFF	; 255
    4406:	8f 3f       	cpi	r24, 0xFF	; 255
    4408:	92 07       	cpc	r25, r18
    440a:	81 f4       	brne	.+32     	; 0x442c <prvAddCurrentTaskToDelayedList+0x60>
    440c:	8f 81       	ldd	r24, Y+7	; 0x07
    440e:	88 23       	and	r24, r24
    4410:	69 f0       	breq	.+26     	; 0x442c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4412:	80 91 3d 06 	lds	r24, 0x063D
    4416:	90 91 3e 06 	lds	r25, 0x063E
    441a:	9c 01       	movw	r18, r24
    441c:	2e 5f       	subi	r18, 0xFE	; 254
    441e:	3f 4f       	sbci	r19, 0xFF	; 255
    4420:	81 e9       	ldi	r24, 0x91	; 145
    4422:	96 e0       	ldi	r25, 0x06	; 6
    4424:	b9 01       	movw	r22, r18
    4426:	0e 94 ed 08 	call	0x11da	; 0x11da <vListInsertEnd>
    442a:	43 c0       	rjmp	.+134    	; 0x44b2 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    442c:	29 81       	ldd	r18, Y+1	; 0x01
    442e:	3a 81       	ldd	r19, Y+2	; 0x02
    4430:	8d 81       	ldd	r24, Y+5	; 0x05
    4432:	9e 81       	ldd	r25, Y+6	; 0x06
    4434:	82 0f       	add	r24, r18
    4436:	93 1f       	adc	r25, r19
    4438:	9c 83       	std	Y+4, r25	; 0x04
    443a:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    443c:	e0 91 3d 06 	lds	r30, 0x063D
    4440:	f0 91 3e 06 	lds	r31, 0x063E
    4444:	8b 81       	ldd	r24, Y+3	; 0x03
    4446:	9c 81       	ldd	r25, Y+4	; 0x04
    4448:	93 83       	std	Z+3, r25	; 0x03
    444a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    444c:	2b 81       	ldd	r18, Y+3	; 0x03
    444e:	3c 81       	ldd	r19, Y+4	; 0x04
    4450:	89 81       	ldd	r24, Y+1	; 0x01
    4452:	9a 81       	ldd	r25, Y+2	; 0x02
    4454:	28 17       	cp	r18, r24
    4456:	39 07       	cpc	r19, r25
    4458:	70 f4       	brcc	.+28     	; 0x4476 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    445a:	80 91 7d 06 	lds	r24, 0x067D
    445e:	90 91 7e 06 	lds	r25, 0x067E
    4462:	20 91 3d 06 	lds	r18, 0x063D
    4466:	30 91 3e 06 	lds	r19, 0x063E
    446a:	2e 5f       	subi	r18, 0xFE	; 254
    446c:	3f 4f       	sbci	r19, 0xFF	; 255
    446e:	b9 01       	movw	r22, r18
    4470:	0e 94 31 09 	call	0x1262	; 0x1262 <vListInsert>
    4474:	1e c0       	rjmp	.+60     	; 0x44b2 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4476:	40 91 7b 06 	lds	r20, 0x067B
    447a:	50 91 7c 06 	lds	r21, 0x067C
    447e:	80 91 3d 06 	lds	r24, 0x063D
    4482:	90 91 3e 06 	lds	r25, 0x063E
    4486:	9c 01       	movw	r18, r24
    4488:	2e 5f       	subi	r18, 0xFE	; 254
    448a:	3f 4f       	sbci	r19, 0xFF	; 255
    448c:	ca 01       	movw	r24, r20
    448e:	b9 01       	movw	r22, r18
    4490:	0e 94 31 09 	call	0x1262	; 0x1262 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4494:	20 91 49 06 	lds	r18, 0x0649
    4498:	30 91 4a 06 	lds	r19, 0x064A
    449c:	8b 81       	ldd	r24, Y+3	; 0x03
    449e:	9c 81       	ldd	r25, Y+4	; 0x04
    44a0:	82 17       	cp	r24, r18
    44a2:	93 07       	cpc	r25, r19
    44a4:	30 f4       	brcc	.+12     	; 0x44b2 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    44a6:	8b 81       	ldd	r24, Y+3	; 0x03
    44a8:	9c 81       	ldd	r25, Y+4	; 0x04
    44aa:	90 93 4a 06 	sts	0x064A, r25
    44ae:	80 93 49 06 	sts	0x0649, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    44b2:	27 96       	adiw	r28, 0x07	; 7
    44b4:	0f b6       	in	r0, 0x3f	; 63
    44b6:	f8 94       	cli
    44b8:	de bf       	out	0x3e, r29	; 62
    44ba:	0f be       	out	0x3f, r0	; 63
    44bc:	cd bf       	out	0x3d, r28	; 61
    44be:	cf 91       	pop	r28
    44c0:	df 91       	pop	r29
    44c2:	08 95       	ret

000044c4 <UART_voidInit>:
#include "USART_private.h"
#include "USART_config.h"
#include "USART_interface.h"

void UART_voidInit(void)
{
    44c4:	df 93       	push	r29
    44c6:	cf 93       	push	r28
    44c8:	00 d0       	rcall	.+0      	; 0x44ca <UART_voidInit+0x6>
    44ca:	cd b7       	in	r28, 0x3d	; 61
    44cc:	de b7       	in	r29, 0x3e	; 62

	uint8 u8TempBLoc = 0b00011000;
    44ce:	88 e1       	ldi	r24, 0x18	; 24
    44d0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 u8TempCLoc = 0b10000000; //selsct UCSRC by set bit 7
    44d2:	80 e8       	ldi	r24, 0x80	; 128
    44d4:	89 83       	std	Y+1, r24	; 0x01
CLR_BIT(u8TempCLoc,1);
SET_BIT(u8TempCLoc,2);
CLR_BIT(u8TempBLoc,2);

#elif UART_DATA_SIZE == UART_8BITS_DATA
SET_BIT(u8TempCLoc,1);
    44d6:	89 81       	ldd	r24, Y+1	; 0x01
    44d8:	82 60       	ori	r24, 0x02	; 2
    44da:	89 83       	std	Y+1, r24	; 0x01
SET_BIT(u8TempCLoc,2);
    44dc:	89 81       	ldd	r24, Y+1	; 0x01
    44de:	84 60       	ori	r24, 0x04	; 4
    44e0:	89 83       	std	Y+1, r24	; 0x01
CLR_BIT(u8TempBLoc,2);
    44e2:	8a 81       	ldd	r24, Y+2	; 0x02
    44e4:	8b 7f       	andi	r24, 0xFB	; 251
    44e6:	8a 83       	std	Y+2, r24	; 0x02


#if UART_MODE == UART_SYNCH_OP
SET_BIT(u8TempCLoc,6);
#else
CLR_BIT(u8TempCLoc,6);
    44e8:	89 81       	ldd	r24, Y+1	; 0x01
    44ea:	8f 7b       	andi	r24, 0xBF	; 191
    44ec:	89 83       	std	Y+1, r24	; 0x01
#endif

#if UART_STOP_BIT ==  UART_1BIT_STOP
CLR_BIT(u8TempCLoc,3);
    44ee:	89 81       	ldd	r24, Y+1	; 0x01
    44f0:	87 7f       	andi	r24, 0xF7	; 247
    44f2:	89 83       	std	Y+1, r24	; 0x01
#elif UART_PARITY == UART_PARITY_ODD
SET_BIT(u8TempCLoc,4);
SET_BIT(u8TempCLoc,5);
#else
/* no parity*/
CLR_BIT(u8TempCLoc,4);
    44f4:	89 81       	ldd	r24, Y+1	; 0x01
    44f6:	8f 7e       	andi	r24, 0xEF	; 239
    44f8:	89 83       	std	Y+1, r24	; 0x01
CLR_BIT(u8TempCLoc,5);
    44fa:	89 81       	ldd	r24, Y+1	; 0x01
    44fc:	8f 7d       	andi	r24, 0xDF	; 223
    44fe:	89 83       	std	Y+1, r24	; 0x01
#endif
/* setup  --->send at syncronous mode */
#if  UART_CLOCK_POLARITY == UART_SETUP_RISING
CLR_BIT(u8TempCLoc,0);
    4500:	89 81       	ldd	r24, Y+1	; 0x01
    4502:	8e 7f       	andi	r24, 0xFE	; 254
    4504:	89 83       	std	Y+1, r24	; 0x01
#else
SET_BIT(u8TempCLoc,0);
#endif

UBRRH =(UART_BUAD_RATE>>8)& 0x0f ; // >8 bit
    4506:	e0 e4       	ldi	r30, 0x40	; 64
    4508:	f0 e0       	ldi	r31, 0x00	; 0
    450a:	10 82       	st	Z, r1
UBRRL =(uint8) UART_BUAD_RATE;
    450c:	e9 e2       	ldi	r30, 0x29	; 41
    450e:	f0 e0       	ldi	r31, 0x00	; 0
    4510:	88 e0       	ldi	r24, 0x08	; 8
    4512:	80 83       	st	Z, r24

UCSRB=u8TempBLoc;
    4514:	ea e2       	ldi	r30, 0x2A	; 42
    4516:	f0 e0       	ldi	r31, 0x00	; 0
    4518:	8a 81       	ldd	r24, Y+2	; 0x02
    451a:	80 83       	st	Z, r24
UCSRC=u8TempCLoc;
    451c:	e0 e4       	ldi	r30, 0x40	; 64
    451e:	f0 e0       	ldi	r31, 0x00	; 0
    4520:	89 81       	ldd	r24, Y+1	; 0x01
    4522:	80 83       	st	Z, r24
}
    4524:	0f 90       	pop	r0
    4526:	0f 90       	pop	r0
    4528:	cf 91       	pop	r28
    452a:	df 91       	pop	r29
    452c:	08 95       	ret

0000452e <UART_voidSend>:

/*polling*/
void UART_voidSend(uint16 u16Data)
{
    452e:	df 93       	push	r29
    4530:	cf 93       	push	r28
    4532:	00 d0       	rcall	.+0      	; 0x4534 <UART_voidSend+0x6>
    4534:	cd b7       	in	r28, 0x3d	; 61
    4536:	de b7       	in	r29, 0x3e	; 62
    4538:	9a 83       	std	Y+2, r25	; 0x02
    453a:	89 83       	std	Y+1, r24	; 0x01
	while(GET_BIT(UCSRA,5) ==0);
    453c:	eb e2       	ldi	r30, 0x2B	; 43
    453e:	f0 e0       	ldi	r31, 0x00	; 0
    4540:	80 81       	ld	r24, Z
    4542:	82 95       	swap	r24
    4544:	86 95       	lsr	r24
    4546:	87 70       	andi	r24, 0x07	; 7
    4548:	88 2f       	mov	r24, r24
    454a:	90 e0       	ldi	r25, 0x00	; 0
    454c:	81 70       	andi	r24, 0x01	; 1
    454e:	90 70       	andi	r25, 0x00	; 0
    4550:	00 97       	sbiw	r24, 0x00	; 0
    4552:	a1 f3       	breq	.-24     	; 0x453c <UART_voidSend+0xe>
	else
	{
		SET_BIT(UCSRB,0);
	}
#endif
	UDR=u16Data;
    4554:	ec e2       	ldi	r30, 0x2C	; 44
    4556:	f0 e0       	ldi	r31, 0x00	; 0
    4558:	89 81       	ldd	r24, Y+1	; 0x01
    455a:	80 83       	st	Z, r24
}
    455c:	0f 90       	pop	r0
    455e:	0f 90       	pop	r0
    4560:	cf 91       	pop	r28
    4562:	df 91       	pop	r29
    4564:	08 95       	ret

00004566 <UART_enuRecieve>:

tenuErrorStatus UART_enuRecieve(uint16* pu16Data)
{
    4566:	df 93       	push	r29
    4568:	cf 93       	push	r28
    456a:	00 d0       	rcall	.+0      	; 0x456c <UART_enuRecieve+0x6>
    456c:	00 d0       	rcall	.+0      	; 0x456e <UART_enuRecieve+0x8>
    456e:	0f 92       	push	r0
    4570:	cd b7       	in	r28, 0x3d	; 61
    4572:	de b7       	in	r29, 0x3e	; 62
    4574:	9d 83       	std	Y+5, r25	; 0x05
    4576:	8c 83       	std	Y+4, r24	; 0x04
	tenuErrorStatus ErrorState=EOK;
    4578:	1b 82       	std	Y+3, r1	; 0x03

	uint8 u8checkError=0;
    457a:	1a 82       	std	Y+2, r1	; 0x02
	uint8 u8ninebit;

	while(GET_BIT(UCSRA,7) ==0);
    457c:	eb e2       	ldi	r30, 0x2B	; 43
    457e:	f0 e0       	ldi	r31, 0x00	; 0
    4580:	80 81       	ld	r24, Z
    4582:	88 23       	and	r24, r24
    4584:	dc f7       	brge	.-10     	; 0x457c <UART_enuRecieve+0x16>
	u8checkError= UCSRA &0b00011100 ;
    4586:	eb e2       	ldi	r30, 0x2B	; 43
    4588:	f0 e0       	ldi	r31, 0x00	; 0
    458a:	80 81       	ld	r24, Z
    458c:	8c 71       	andi	r24, 0x1C	; 28
    458e:	8a 83       	std	Y+2, r24	; 0x02
	if (u8checkError!=0)
    4590:	8a 81       	ldd	r24, Y+2	; 0x02
    4592:	88 23       	and	r24, r24
    4594:	19 f0       	breq	.+6      	; 0x459c <UART_enuRecieve+0x36>
	{
		ErrorState=ENOK;
    4596:	81 e0       	ldi	r24, 0x01	; 1
    4598:	8b 83       	std	Y+3, r24	; 0x03
    459a:	09 c0       	rjmp	.+18     	; 0x45ae <UART_enuRecieve+0x48>
			u8ninebit=GET_BIT(UCSRB,1);

			*pu16Data = u8ninebit<<8  | UDR ;
		#else
			{
				*pu16Data =UDR;
    459c:	ec e2       	ldi	r30, 0x2C	; 44
    459e:	f0 e0       	ldi	r31, 0x00	; 0
    45a0:	80 81       	ld	r24, Z
    45a2:	88 2f       	mov	r24, r24
    45a4:	90 e0       	ldi	r25, 0x00	; 0
    45a6:	ec 81       	ldd	r30, Y+4	; 0x04
    45a8:	fd 81       	ldd	r31, Y+5	; 0x05
    45aa:	91 83       	std	Z+1, r25	; 0x01
    45ac:	80 83       	st	Z, r24
			}

		#endif
	}
	return  ErrorState;
    45ae:	8b 81       	ldd	r24, Y+3	; 0x03
}
    45b0:	0f 90       	pop	r0
    45b2:	0f 90       	pop	r0
    45b4:	0f 90       	pop	r0
    45b6:	0f 90       	pop	r0
    45b8:	0f 90       	pop	r0
    45ba:	cf 91       	pop	r28
    45bc:	df 91       	pop	r29
    45be:	08 95       	ret

000045c0 <UART_voidSendString>:

void UART_voidSendString(uint16 *_pu16Data,uint8 _u8bufferSize){
    45c0:	df 93       	push	r29
    45c2:	cf 93       	push	r28
    45c4:	00 d0       	rcall	.+0      	; 0x45c6 <UART_voidSendString+0x6>
    45c6:	00 d0       	rcall	.+0      	; 0x45c8 <UART_voidSendString+0x8>
    45c8:	cd b7       	in	r28, 0x3d	; 61
    45ca:	de b7       	in	r29, 0x3e	; 62
    45cc:	9b 83       	std	Y+3, r25	; 0x03
    45ce:	8a 83       	std	Y+2, r24	; 0x02
    45d0:	6c 83       	std	Y+4, r22	; 0x04
	uint8 loc_itr=0;
    45d2:	19 82       	std	Y+1, r1	; 0x01
	for(loc_itr = 0 ; loc_itr < _u8bufferSize ; loc_itr++)
    45d4:	19 82       	std	Y+1, r1	; 0x01
    45d6:	12 c0       	rjmp	.+36     	; 0x45fc <UART_voidSendString+0x3c>
	{
		UART_voidSend(_pu16Data[loc_itr]);
    45d8:	89 81       	ldd	r24, Y+1	; 0x01
    45da:	88 2f       	mov	r24, r24
    45dc:	90 e0       	ldi	r25, 0x00	; 0
    45de:	9c 01       	movw	r18, r24
    45e0:	22 0f       	add	r18, r18
    45e2:	33 1f       	adc	r19, r19
    45e4:	8a 81       	ldd	r24, Y+2	; 0x02
    45e6:	9b 81       	ldd	r25, Y+3	; 0x03
    45e8:	fc 01       	movw	r30, r24
    45ea:	e2 0f       	add	r30, r18
    45ec:	f3 1f       	adc	r31, r19
    45ee:	80 81       	ld	r24, Z
    45f0:	91 81       	ldd	r25, Z+1	; 0x01
    45f2:	0e 94 97 22 	call	0x452e	; 0x452e <UART_voidSend>
	return  ErrorState;
}

void UART_voidSendString(uint16 *_pu16Data,uint8 _u8bufferSize){
	uint8 loc_itr=0;
	for(loc_itr = 0 ; loc_itr < _u8bufferSize ; loc_itr++)
    45f6:	89 81       	ldd	r24, Y+1	; 0x01
    45f8:	8f 5f       	subi	r24, 0xFF	; 255
    45fa:	89 83       	std	Y+1, r24	; 0x01
    45fc:	99 81       	ldd	r25, Y+1	; 0x01
    45fe:	8c 81       	ldd	r24, Y+4	; 0x04
    4600:	98 17       	cp	r25, r24
    4602:	50 f3       	brcs	.-44     	; 0x45d8 <UART_voidSendString+0x18>
	{
		UART_voidSend(_pu16Data[loc_itr]);
	}
}
    4604:	0f 90       	pop	r0
    4606:	0f 90       	pop	r0
    4608:	0f 90       	pop	r0
    460a:	0f 90       	pop	r0
    460c:	cf 91       	pop	r28
    460e:	df 91       	pop	r29
    4610:	08 95       	ret

00004612 <UART_voidEnableIntRXComp>:
//RX complete
void UART_voidEnableIntRXComp(void)
{
    4612:	df 93       	push	r29
    4614:	cf 93       	push	r28
    4616:	cd b7       	in	r28, 0x3d	; 61
    4618:	de b7       	in	r29, 0x3e	; 62

}
    461a:	cf 91       	pop	r28
    461c:	df 91       	pop	r29
    461e:	08 95       	ret

00004620 <UART_voidDisableIntRXComp>:
void UART_voidDisableIntRXComp(void)
{
    4620:	df 93       	push	r29
    4622:	cf 93       	push	r28
    4624:	cd b7       	in	r28, 0x3d	; 61
    4626:	de b7       	in	r29, 0x3e	; 62

}
    4628:	cf 91       	pop	r28
    462a:	df 91       	pop	r29
    462c:	08 95       	ret

0000462e <UART_voidEnableIntTXComp>:

//TX complete
void UART_voidEnableIntTXComp(void){
    462e:	df 93       	push	r29
    4630:	cf 93       	push	r28
    4632:	cd b7       	in	r28, 0x3d	; 61
    4634:	de b7       	in	r29, 0x3e	; 62

}
    4636:	cf 91       	pop	r28
    4638:	df 91       	pop	r29
    463a:	08 95       	ret

0000463c <UART_voidDisableIntTXComp>:

void UART_voidDisableIntTXComp(void)
{
    463c:	df 93       	push	r29
    463e:	cf 93       	push	r28
    4640:	cd b7       	in	r28, 0x3d	; 61
    4642:	de b7       	in	r29, 0x3e	; 62

}
    4644:	cf 91       	pop	r28
    4646:	df 91       	pop	r29
    4648:	08 95       	ret

0000464a <UART_voidEnableIntTXEmpty>:

void UART_voidEnableIntTXEmpty(void)
{
    464a:	df 93       	push	r29
    464c:	cf 93       	push	r28
    464e:	cd b7       	in	r28, 0x3d	; 61
    4650:	de b7       	in	r29, 0x3e	; 62
	//TX Data Reg. empty
}
    4652:	cf 91       	pop	r28
    4654:	df 91       	pop	r29
    4656:	08 95       	ret

00004658 <UART_voidDisableIntTXEmpty>:
void UART_voidDisableIntTXEmpty(void)
{
    4658:	df 93       	push	r29
    465a:	cf 93       	push	r28
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62

}
    4660:	cf 91       	pop	r28
    4662:	df 91       	pop	r29
    4664:	08 95       	ret

00004666 <TIM2_voidinit>:

pf TIM2_pfOVFCallBack;
pf TIM2_pfCmpCallBack;

void TIM2_voidinit(void)
{
    4666:	df 93       	push	r29
    4668:	cf 93       	push	r28
    466a:	cd b7       	in	r28, 0x3d	; 61
    466c:	de b7       	in	r29, 0x3e	; 62

#elif TIM2_MODE == TIM2_FAST_PWM
	SET_BIT(TCCR2,6);
	SET_BIT(TCCR2,3);
#elif TIM2_MODE == TIM2_PHASE_CORRECT_PWM
	SET_BIT(TCCR2,6);
    466e:	a5 e4       	ldi	r26, 0x45	; 69
    4670:	b0 e0       	ldi	r27, 0x00	; 0
    4672:	e5 e4       	ldi	r30, 0x45	; 69
    4674:	f0 e0       	ldi	r31, 0x00	; 0
    4676:	80 81       	ld	r24, Z
    4678:	80 64       	ori	r24, 0x40	; 64
    467a:	8c 93       	st	X, r24
	CLR_BIT(TCCR2,3);
    467c:	a5 e4       	ldi	r26, 0x45	; 69
    467e:	b0 e0       	ldi	r27, 0x00	; 0
    4680:	e5 e4       	ldi	r30, 0x45	; 69
    4682:	f0 e0       	ldi	r31, 0x00	; 0
    4684:	80 81       	ld	r24, Z
    4686:	87 7f       	andi	r24, 0xF7	; 247
    4688:	8c 93       	st	X, r24
#elif TIM2_WAVE == TIM2_SET_OC2
	SET_BIT(TCCR2,4);
	SET_BIT(TCCR2,5);

#elif TIM2_WAVE == TIM2_CLR_OC2
	CLR_BIT(TCCR2,4);
    468a:	a5 e4       	ldi	r26, 0x45	; 69
    468c:	b0 e0       	ldi	r27, 0x00	; 0
    468e:	e5 e4       	ldi	r30, 0x45	; 69
    4690:	f0 e0       	ldi	r31, 0x00	; 0
    4692:	80 81       	ld	r24, Z
    4694:	8f 7e       	andi	r24, 0xEF	; 239
    4696:	8c 93       	st	X, r24
	SET_BIT(TCCR2,5);
    4698:	a5 e4       	ldi	r26, 0x45	; 69
    469a:	b0 e0       	ldi	r27, 0x00	; 0
    469c:	e5 e4       	ldi	r30, 0x45	; 69
    469e:	f0 e0       	ldi	r31, 0x00	; 0
    46a0:	80 81       	ld	r24, Z
    46a2:	80 62       	ori	r24, 0x20	; 32
    46a4:	8c 93       	st	X, r24
#else
	CLR_BIT(TCCR2,4);
	CLR_BIT(TCCR2,5);
#endif

}
    46a6:	cf 91       	pop	r28
    46a8:	df 91       	pop	r29
    46aa:	08 95       	ret

000046ac <TIM2_ExtClkEnable>:
void TIM2_ExtClkEnable()
{
    46ac:	df 93       	push	r29
    46ae:	cf 93       	push	r28
    46b0:	cd b7       	in	r28, 0x3d	; 61
    46b2:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ASSR,3);
    46b4:	a2 e4       	ldi	r26, 0x42	; 66
    46b6:	b0 e0       	ldi	r27, 0x00	; 0
    46b8:	e2 e4       	ldi	r30, 0x42	; 66
    46ba:	f0 e0       	ldi	r31, 0x00	; 0
    46bc:	80 81       	ld	r24, Z
    46be:	88 60       	ori	r24, 0x08	; 8
    46c0:	8c 93       	st	X, r24
}
    46c2:	cf 91       	pop	r28
    46c4:	df 91       	pop	r29
    46c6:	08 95       	ret

000046c8 <TIM2_ExtClkDisable>:
void TIM2_ExtClkDisable()
{
    46c8:	df 93       	push	r29
    46ca:	cf 93       	push	r28
    46cc:	cd b7       	in	r28, 0x3d	; 61
    46ce:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(ASSR,3);
    46d0:	a2 e4       	ldi	r26, 0x42	; 66
    46d2:	b0 e0       	ldi	r27, 0x00	; 0
    46d4:	e2 e4       	ldi	r30, 0x42	; 66
    46d6:	f0 e0       	ldi	r31, 0x00	; 0
    46d8:	80 81       	ld	r24, Z
    46da:	87 7f       	andi	r24, 0xF7	; 247
    46dc:	8c 93       	st	X, r24
}
    46de:	cf 91       	pop	r28
    46e0:	df 91       	pop	r29
    46e2:	08 95       	ret

000046e4 <TIM2_voidEnable>:


void TIM2_voidEnable(uint8 u8PreScaler)
{
    46e4:	df 93       	push	r29
    46e6:	cf 93       	push	r28
    46e8:	0f 92       	push	r0
    46ea:	cd b7       	in	r28, 0x3d	; 61
    46ec:	de b7       	in	r29, 0x3e	; 62
    46ee:	89 83       	std	Y+1, r24	; 0x01

	TCCR2&=0b11111000;
    46f0:	a5 e4       	ldi	r26, 0x45	; 69
    46f2:	b0 e0       	ldi	r27, 0x00	; 0
    46f4:	e5 e4       	ldi	r30, 0x45	; 69
    46f6:	f0 e0       	ldi	r31, 0x00	; 0
    46f8:	80 81       	ld	r24, Z
    46fa:	88 7f       	andi	r24, 0xF8	; 248
    46fc:	8c 93       	st	X, r24
	//& 0b00000111 --> to prevent the user  to entermore than 111 in bits 0,1,2

	TCCR2|= (u8PreScaler & 0b00000111);
    46fe:	a5 e4       	ldi	r26, 0x45	; 69
    4700:	b0 e0       	ldi	r27, 0x00	; 0
    4702:	e5 e4       	ldi	r30, 0x45	; 69
    4704:	f0 e0       	ldi	r31, 0x00	; 0
    4706:	80 81       	ld	r24, Z
    4708:	98 2f       	mov	r25, r24
    470a:	89 81       	ldd	r24, Y+1	; 0x01
    470c:	87 70       	andi	r24, 0x07	; 7
    470e:	89 2b       	or	r24, r25
    4710:	8c 93       	st	X, r24

}
    4712:	0f 90       	pop	r0
    4714:	cf 91       	pop	r28
    4716:	df 91       	pop	r29
    4718:	08 95       	ret

0000471a <TIM2_voidDisable>:
void TIM2_voidDisable(void)
{
    471a:	df 93       	push	r29
    471c:	cf 93       	push	r28
    471e:	cd b7       	in	r28, 0x3d	; 61
    4720:	de b7       	in	r29, 0x3e	; 62
	TCCR2&=0b11111000;
    4722:	a5 e4       	ldi	r26, 0x45	; 69
    4724:	b0 e0       	ldi	r27, 0x00	; 0
    4726:	e5 e4       	ldi	r30, 0x45	; 69
    4728:	f0 e0       	ldi	r31, 0x00	; 0
    472a:	80 81       	ld	r24, Z
    472c:	88 7f       	andi	r24, 0xF8	; 248
    472e:	8c 93       	st	X, r24
}
    4730:	cf 91       	pop	r28
    4732:	df 91       	pop	r29
    4734:	08 95       	ret

00004736 <TIM2_voidEnableOvfINt>:
void TIM2_voidEnableOvfINt(void)
{
    4736:	df 93       	push	r29
    4738:	cf 93       	push	r28
    473a:	cd b7       	in	r28, 0x3d	; 61
    473c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK,6);
    473e:	a9 e5       	ldi	r26, 0x59	; 89
    4740:	b0 e0       	ldi	r27, 0x00	; 0
    4742:	e9 e5       	ldi	r30, 0x59	; 89
    4744:	f0 e0       	ldi	r31, 0x00	; 0
    4746:	80 81       	ld	r24, Z
    4748:	80 64       	ori	r24, 0x40	; 64
    474a:	8c 93       	st	X, r24
}
    474c:	cf 91       	pop	r28
    474e:	df 91       	pop	r29
    4750:	08 95       	ret

00004752 <TIM2_voidDisableOvfINt>:
void TIM2_voidDisableOvfINt(void)
{
    4752:	df 93       	push	r29
    4754:	cf 93       	push	r28
    4756:	cd b7       	in	r28, 0x3d	; 61
    4758:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,6);
    475a:	a9 e5       	ldi	r26, 0x59	; 89
    475c:	b0 e0       	ldi	r27, 0x00	; 0
    475e:	e9 e5       	ldi	r30, 0x59	; 89
    4760:	f0 e0       	ldi	r31, 0x00	; 0
    4762:	80 81       	ld	r24, Z
    4764:	8f 7b       	andi	r24, 0xBF	; 191
    4766:	8c 93       	st	X, r24

}
    4768:	cf 91       	pop	r28
    476a:	df 91       	pop	r29
    476c:	08 95       	ret

0000476e <TIM2_voidEnableComparINt>:
void TIM2_voidEnableComparINt(void)
{
    476e:	df 93       	push	r29
    4770:	cf 93       	push	r28
    4772:	cd b7       	in	r28, 0x3d	; 61
    4774:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TIMSK,7);
    4776:	a9 e5       	ldi	r26, 0x59	; 89
    4778:	b0 e0       	ldi	r27, 0x00	; 0
    477a:	e9 e5       	ldi	r30, 0x59	; 89
    477c:	f0 e0       	ldi	r31, 0x00	; 0
    477e:	80 81       	ld	r24, Z
    4780:	80 68       	ori	r24, 0x80	; 128
    4782:	8c 93       	st	X, r24

}
    4784:	cf 91       	pop	r28
    4786:	df 91       	pop	r29
    4788:	08 95       	ret

0000478a <TIM2_voidDisableCompareINt>:
void TIM2_voidDisableCompareINt(void)
{
    478a:	df 93       	push	r29
    478c:	cf 93       	push	r28
    478e:	cd b7       	in	r28, 0x3d	; 61
    4790:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,7);
    4792:	a9 e5       	ldi	r26, 0x59	; 89
    4794:	b0 e0       	ldi	r27, 0x00	; 0
    4796:	e9 e5       	ldi	r30, 0x59	; 89
    4798:	f0 e0       	ldi	r31, 0x00	; 0
    479a:	80 81       	ld	r24, Z
    479c:	8f 77       	andi	r24, 0x7F	; 127
    479e:	8c 93       	st	X, r24
}
    47a0:	cf 91       	pop	r28
    47a2:	df 91       	pop	r29
    47a4:	08 95       	ret

000047a6 <TIM2_voidSetCallBackOvfInt>:

void TIM2_voidSetCallBackOvfInt(pf pfOvfcallBack)
{
    47a6:	df 93       	push	r29
    47a8:	cf 93       	push	r28
    47aa:	00 d0       	rcall	.+0      	; 0x47ac <TIM2_voidSetCallBackOvfInt+0x6>
    47ac:	cd b7       	in	r28, 0x3d	; 61
    47ae:	de b7       	in	r29, 0x3e	; 62
    47b0:	9a 83       	std	Y+2, r25	; 0x02
    47b2:	89 83       	std	Y+1, r24	; 0x01
	TIM2_pfOVFCallBack=pfOvfcallBack;
    47b4:	89 81       	ldd	r24, Y+1	; 0x01
    47b6:	9a 81       	ldd	r25, Y+2	; 0x02
    47b8:	90 93 a7 06 	sts	0x06A7, r25
    47bc:	80 93 a6 06 	sts	0x06A6, r24
}
    47c0:	0f 90       	pop	r0
    47c2:	0f 90       	pop	r0
    47c4:	cf 91       	pop	r28
    47c6:	df 91       	pop	r29
    47c8:	08 95       	ret

000047ca <TIM2_voidSetCallBackCompareInt>:
void TIM2_voidSetCallBackCompareInt(pf pfComcallBack)
{
    47ca:	df 93       	push	r29
    47cc:	cf 93       	push	r28
    47ce:	00 d0       	rcall	.+0      	; 0x47d0 <TIM2_voidSetCallBackCompareInt+0x6>
    47d0:	cd b7       	in	r28, 0x3d	; 61
    47d2:	de b7       	in	r29, 0x3e	; 62
    47d4:	9a 83       	std	Y+2, r25	; 0x02
    47d6:	89 83       	std	Y+1, r24	; 0x01
	TIM2_pfCmpCallBack=pfComcallBack;
    47d8:	89 81       	ldd	r24, Y+1	; 0x01
    47da:	9a 81       	ldd	r25, Y+2	; 0x02
    47dc:	90 93 a5 06 	sts	0x06A5, r25
    47e0:	80 93 a4 06 	sts	0x06A4, r24
}
    47e4:	0f 90       	pop	r0
    47e6:	0f 90       	pop	r0
    47e8:	cf 91       	pop	r28
    47ea:	df 91       	pop	r29
    47ec:	08 95       	ret

000047ee <TIM2_voidSetTCNTValue>:

void TIM2_voidSetTCNTValue(uint8 u8TcntReg)
{
    47ee:	df 93       	push	r29
    47f0:	cf 93       	push	r28
    47f2:	0f 92       	push	r0
    47f4:	cd b7       	in	r28, 0x3d	; 61
    47f6:	de b7       	in	r29, 0x3e	; 62
    47f8:	89 83       	std	Y+1, r24	; 0x01
	TCNT2 = u8TcntReg;
    47fa:	e4 e4       	ldi	r30, 0x44	; 68
    47fc:	f0 e0       	ldi	r31, 0x00	; 0
    47fe:	89 81       	ldd	r24, Y+1	; 0x01
    4800:	80 83       	st	Z, r24
}
    4802:	0f 90       	pop	r0
    4804:	cf 91       	pop	r28
    4806:	df 91       	pop	r29
    4808:	08 95       	ret

0000480a <TIM2_voidSetOCRValue>:
void TIM2_voidSetOCRValue(uint8 u8OcrReg)
{
    480a:	df 93       	push	r29
    480c:	cf 93       	push	r28
    480e:	0f 92       	push	r0
    4810:	cd b7       	in	r28, 0x3d	; 61
    4812:	de b7       	in	r29, 0x3e	; 62
    4814:	89 83       	std	Y+1, r24	; 0x01
	OCR2 = u8OcrReg;
    4816:	e3 e4       	ldi	r30, 0x43	; 67
    4818:	f0 e0       	ldi	r31, 0x00	; 0
    481a:	89 81       	ldd	r24, Y+1	; 0x01
    481c:	80 83       	st	Z, r24
}
    481e:	0f 90       	pop	r0
    4820:	cf 91       	pop	r28
    4822:	df 91       	pop	r29
    4824:	08 95       	ret

00004826 <TIM2_u8ReadTcntReg>:
uint8 TIM2_u8ReadTcntReg(void)
{
    4826:	df 93       	push	r29
    4828:	cf 93       	push	r28
    482a:	cd b7       	in	r28, 0x3d	; 61
    482c:	de b7       	in	r29, 0x3e	; 62
	return TCNT2 ;
    482e:	e4 e4       	ldi	r30, 0x44	; 68
    4830:	f0 e0       	ldi	r31, 0x00	; 0
    4832:	80 81       	ld	r24, Z
}
    4834:	cf 91       	pop	r28
    4836:	df 91       	pop	r29
    4838:	08 95       	ret

0000483a <TIM2_voidChangMode>:

void TIM2_voidChangMode(uint8 u8Mode)
{}
    483a:	df 93       	push	r29
    483c:	cf 93       	push	r28
    483e:	0f 92       	push	r0
    4840:	cd b7       	in	r28, 0x3d	; 61
    4842:	de b7       	in	r29, 0x3e	; 62
    4844:	89 83       	std	Y+1, r24	; 0x01
    4846:	0f 90       	pop	r0
    4848:	cf 91       	pop	r28
    484a:	df 91       	pop	r29
    484c:	08 95       	ret

0000484e <__vector_5>:


void __vector_5  (void)  __attribute__ ((signal,used));

void __vector_5  (void)
{
    484e:	1f 92       	push	r1
    4850:	0f 92       	push	r0
    4852:	0f b6       	in	r0, 0x3f	; 63
    4854:	0f 92       	push	r0
    4856:	11 24       	eor	r1, r1
    4858:	2f 93       	push	r18
    485a:	3f 93       	push	r19
    485c:	4f 93       	push	r20
    485e:	5f 93       	push	r21
    4860:	6f 93       	push	r22
    4862:	7f 93       	push	r23
    4864:	8f 93       	push	r24
    4866:	9f 93       	push	r25
    4868:	af 93       	push	r26
    486a:	bf 93       	push	r27
    486c:	ef 93       	push	r30
    486e:	ff 93       	push	r31
    4870:	df 93       	push	r29
    4872:	cf 93       	push	r28
    4874:	cd b7       	in	r28, 0x3d	; 61
    4876:	de b7       	in	r29, 0x3e	; 62
	TIM2_pfOVFCallBack();
    4878:	e0 91 a6 06 	lds	r30, 0x06A6
    487c:	f0 91 a7 06 	lds	r31, 0x06A7
    4880:	09 95       	icall
}
    4882:	cf 91       	pop	r28
    4884:	df 91       	pop	r29
    4886:	ff 91       	pop	r31
    4888:	ef 91       	pop	r30
    488a:	bf 91       	pop	r27
    488c:	af 91       	pop	r26
    488e:	9f 91       	pop	r25
    4890:	8f 91       	pop	r24
    4892:	7f 91       	pop	r23
    4894:	6f 91       	pop	r22
    4896:	5f 91       	pop	r21
    4898:	4f 91       	pop	r20
    489a:	3f 91       	pop	r19
    489c:	2f 91       	pop	r18
    489e:	0f 90       	pop	r0
    48a0:	0f be       	out	0x3f, r0	; 63
    48a2:	0f 90       	pop	r0
    48a4:	1f 90       	pop	r1
    48a6:	18 95       	reti

000048a8 <__vector_4>:

/* COM ISR */
void __vector_4  (void)  __attribute__ ((signal,used));

void __vector_4  (void)
{
    48a8:	1f 92       	push	r1
    48aa:	0f 92       	push	r0
    48ac:	0f b6       	in	r0, 0x3f	; 63
    48ae:	0f 92       	push	r0
    48b0:	11 24       	eor	r1, r1
    48b2:	2f 93       	push	r18
    48b4:	3f 93       	push	r19
    48b6:	4f 93       	push	r20
    48b8:	5f 93       	push	r21
    48ba:	6f 93       	push	r22
    48bc:	7f 93       	push	r23
    48be:	8f 93       	push	r24
    48c0:	9f 93       	push	r25
    48c2:	af 93       	push	r26
    48c4:	bf 93       	push	r27
    48c6:	ef 93       	push	r30
    48c8:	ff 93       	push	r31
    48ca:	df 93       	push	r29
    48cc:	cf 93       	push	r28
    48ce:	cd b7       	in	r28, 0x3d	; 61
    48d0:	de b7       	in	r29, 0x3e	; 62
	TIM2_pfCmpCallBack();
    48d2:	e0 91 a4 06 	lds	r30, 0x06A4
    48d6:	f0 91 a5 06 	lds	r31, 0x06A5
    48da:	09 95       	icall
}
    48dc:	cf 91       	pop	r28
    48de:	df 91       	pop	r29
    48e0:	ff 91       	pop	r31
    48e2:	ef 91       	pop	r30
    48e4:	bf 91       	pop	r27
    48e6:	af 91       	pop	r26
    48e8:	9f 91       	pop	r25
    48ea:	8f 91       	pop	r24
    48ec:	7f 91       	pop	r23
    48ee:	6f 91       	pop	r22
    48f0:	5f 91       	pop	r21
    48f2:	4f 91       	pop	r20
    48f4:	3f 91       	pop	r19
    48f6:	2f 91       	pop	r18
    48f8:	0f 90       	pop	r0
    48fa:	0f be       	out	0x3f, r0	; 63
    48fc:	0f 90       	pop	r0
    48fe:	1f 90       	pop	r1
    4900:	18 95       	reti

00004902 <I2C_voidInit>:

#include "I2C.h"
#include "I2C_cfg.h"
#include "I2C_priv.h"
void  I2C_voidInit(void)
{
    4902:	df 93       	push	r29
    4904:	cf 93       	push	r28
    4906:	0f 92       	push	r0
    4908:	cd b7       	in	r28, 0x3d	; 61
    490a:	de b7       	in	r29, 0x3e	; 62
	 /* init address to mc if any master try to connect ,it will be through this address*/
	uint8 u8MyAddLoc = 0 ;
    490c:	19 82       	std	Y+1, r1	; 0x01
	u8MyAddLoc = I2C_MY_ADDRESS <<1 ;
    490e:	84 e6       	ldi	r24, 0x64	; 100
    4910:	89 83       	std	Y+1, r24	; 0x01
	#if I2C_GENERAL_CALL == ENABLED
	SET_BIT(u8MyAddLoc , 0 ) ;
    4912:	89 81       	ldd	r24, Y+1	; 0x01
    4914:	81 60       	ori	r24, 0x01	; 1
    4916:	89 83       	std	Y+1, r24	; 0x01
	#else 
	CLR_BIT(u8MyAddLoc , 0 ) ;
	#endif 
    TWAR  = u8MyAddLoc ;    /*TWAR is address register*/    
    4918:	e2 e2       	ldi	r30, 0x22	; 34
    491a:	f0 e0       	ldi	r31, 0x00	; 0
    491c:	89 81       	ldd	r24, Y+1	; 0x01
    491e:	80 83       	st	Z, r24
	/* congigure clock by bits 0 , 1 in a TWSR reg */   
	#if   I2C_PRESCALLER == I2C_PRESCALLER_1
	TWSR = 0b00000000;
	#elif I2C_PRESCALLER == I2C_PRESCALLER_4
	TWSR = 0b00000001;
    4920:	e1 e2       	ldi	r30, 0x21	; 33
    4922:	f0 e0       	ldi	r31, 0x00	; 0
    4924:	81 e0       	ldi	r24, 0x01	; 1
    4926:	80 83       	st	Z, r24
	#elif I2C_PRESCALLER == I2C_PRESCALLER_16
	TWSR = 0b00000010;
	#else
	TWSR = 0b00000011;
	#endif
	TWBR = I2C_TWBR_VALUE ;  /* configure the frequency of the clock by the macros I2C_TWBR_VALUE in  TWBR REG*/
    4928:	e0 e2       	ldi	r30, 0x20	; 32
    492a:	f0 e0       	ldi	r31, 0x00	; 0
    492c:	80 e1       	ldi	r24, 0x10	; 16
    492e:	80 83       	st	Z, r24

	TWCR = 0b00000100;  /* enable I2C prepheral by set bit 2 by 1 in  TWCR REG */ 
    4930:	e6 e5       	ldi	r30, 0x56	; 86
    4932:	f0 e0       	ldi	r31, 0x00	; 0
    4934:	84 e0       	ldi	r24, 0x04	; 4
    4936:	80 83       	st	Z, r24
}
    4938:	0f 90       	pop	r0
    493a:	cf 91       	pop	r28
    493c:	df 91       	pop	r29
    493e:	08 95       	ret

00004940 <I2C_voidStart>:
void  I2C_voidStart(void)  /* master try to send start condition*/
{
    4940:	df 93       	push	r29
    4942:	cf 93       	push	r28
    4944:	cd b7       	in	r28, 0x3d	; 61
    4946:	de b7       	in	r29, 0x3e	; 62
	TWCR = 0b10100100;  /* clear flag bit number 7 by writ  1 , disable ACK bit number 6 by write 0 */
    4948:	e6 e5       	ldi	r30, 0x56	; 86
    494a:	f0 e0       	ldi	r31, 0x00	; 0
    494c:	84 ea       	ldi	r24, 0xA4	; 164
    494e:	80 83       	st	Z, r24
	                    /* enable I2C by bit 2 ,set bit 5 by 1 to make start condition */
	
	while(GET_BIT(TWCR,7)==0);  /* wait for INTerrupt  flag is heigh when start condition is done , bit 7 in TWCR REG is heigh */
    4950:	e6 e5       	ldi	r30, 0x56	; 86
    4952:	f0 e0       	ldi	r31, 0x00	; 0
    4954:	80 81       	ld	r24, Z
    4956:	88 23       	and	r24, r24
    4958:	dc f7       	brge	.-10     	; 0x4950 <I2C_voidStart+0x10>
}
    495a:	cf 91       	pop	r28
    495c:	df 91       	pop	r29
    495e:	08 95       	ret

00004960 <I2C_u8GetStatus>:
uint8 I2C_u8GetStatus(void)
{
    4960:	df 93       	push	r29
    4962:	cf 93       	push	r28
    4964:	cd b7       	in	r28, 0x3d	; 61
    4966:	de b7       	in	r29, 0x3e	; 62
	/* check on status code that returned after any peration in frame  */
	return (TWSR &0xF8) ;  /* status code is stored in last 5 bits in TWSR REG , so ANDing it with 0xF8 or 0b11111000 */
    4968:	e1 e2       	ldi	r30, 0x21	; 33
    496a:	f0 e0       	ldi	r31, 0x00	; 0
    496c:	80 81       	ld	r24, Z
    496e:	88 7f       	andi	r24, 0xF8	; 248
}
    4970:	cf 91       	pop	r28
    4972:	df 91       	pop	r29
    4974:	08 95       	ret

00004976 <I2C_voidWrite>:
void  I2C_voidWrite(uint8 u8ByteCpy)
{
    4976:	df 93       	push	r29
    4978:	cf 93       	push	r28
    497a:	0f 92       	push	r0
    497c:	cd b7       	in	r28, 0x3d	; 61
    497e:	de b7       	in	r29, 0x3e	; 62
    4980:	89 83       	std	Y+1, r24	; 0x01
	/* store value of u8ByteCpy in TWDR data REG  */
	TWDR = u8ByteCpy ;
    4982:	e3 e2       	ldi	r30, 0x23	; 35
    4984:	f0 e0       	ldi	r31, 0x00	; 0
    4986:	89 81       	ldd	r24, Y+1	; 0x01
    4988:	80 83       	st	Z, r24
	TWCR = 0b10000100;  /* clear flag bit number 7 by writ  1 , disable ACK bit number 6 by write 0 ,enable I2C by bit 2*/
    498a:	e6 e5       	ldi	r30, 0x56	; 86
    498c:	f0 e0       	ldi	r31, 0x00	; 0
    498e:	84 e8       	ldi	r24, 0x84	; 132
    4990:	80 83       	st	Z, r24
	while(GET_BIT(TWCR,7)==0); /* wait for INTerrupt  flag is heigh when data stored in TWDR REG  , bit 7 in TWCR REG is heigh */
    4992:	e6 e5       	ldi	r30, 0x56	; 86
    4994:	f0 e0       	ldi	r31, 0x00	; 0
    4996:	80 81       	ld	r24, Z
    4998:	88 23       	and	r24, r24
    499a:	dc f7       	brge	.-10     	; 0x4992 <I2C_voidWrite+0x1c>
}
    499c:	0f 90       	pop	r0
    499e:	cf 91       	pop	r28
    49a0:	df 91       	pop	r29
    49a2:	08 95       	ret

000049a4 <I2C_voidStop>:
void  I2C_voidStop(void)
{
    49a4:	df 93       	push	r29
    49a6:	cf 93       	push	r28
    49a8:	cd b7       	in	r28, 0x3d	; 61
    49aa:	de b7       	in	r29, 0x3e	; 62
	TWCR = 0b10010100; /* set bit number 4 by 1 to mak stop condition */
    49ac:	e6 e5       	ldi	r30, 0x56	; 86
    49ae:	f0 e0       	ldi	r31, 0x00	; 0
    49b0:	84 e9       	ldi	r24, 0x94	; 148
    49b2:	80 83       	st	Z, r24
}
    49b4:	cf 91       	pop	r28
    49b6:	df 91       	pop	r29
    49b8:	08 95       	ret

000049ba <I2C_u8ReadWithoutAck>:
uint8 I2C_u8ReadWithoutAck(void)
{
    49ba:	df 93       	push	r29
    49bc:	cf 93       	push	r28
    49be:	cd b7       	in	r28, 0x3d	; 61
    49c0:	de b7       	in	r29, 0x3e	; 62
	TWCR = 0b10000100;  /* clear flag bit number 7 by writ  1 , disable ACK bit number 6 by write 0 ,enable I2C by bit 2*/
    49c2:	e6 e5       	ldi	r30, 0x56	; 86
    49c4:	f0 e0       	ldi	r31, 0x00	; 0
    49c6:	84 e8       	ldi	r24, 0x84	; 132
    49c8:	80 83       	st	Z, r24
	while(GET_BIT(TWCR,7)==0); /* wait until TWDR REG store the recieved data , after receiving flag is heigh  */
    49ca:	e6 e5       	ldi	r30, 0x56	; 86
    49cc:	f0 e0       	ldi	r31, 0x00	; 0
    49ce:	80 81       	ld	r24, Z
    49d0:	88 23       	and	r24, r24
    49d2:	dc f7       	brge	.-10     	; 0x49ca <I2C_u8ReadWithoutAck+0x10>
	return TWDR ; 
    49d4:	e3 e2       	ldi	r30, 0x23	; 35
    49d6:	f0 e0       	ldi	r31, 0x00	; 0
    49d8:	80 81       	ld	r24, Z
}
    49da:	cf 91       	pop	r28
    49dc:	df 91       	pop	r29
    49de:	08 95       	ret

000049e0 <I2C_u8ReadWithAck>:

uint8 I2C_u8ReadWithAck(void)
{
    49e0:	df 93       	push	r29
    49e2:	cf 93       	push	r28
    49e4:	cd b7       	in	r28, 0x3d	; 61
    49e6:	de b7       	in	r29, 0x3e	; 62
	TWCR = 0b11000100; /* set ACK  by bit number 6 */ 
    49e8:	e6 e5       	ldi	r30, 0x56	; 86
    49ea:	f0 e0       	ldi	r31, 0x00	; 0
    49ec:	84 ec       	ldi	r24, 0xC4	; 196
    49ee:	80 83       	st	Z, r24
	while(GET_BIT(TWCR,7)==0);
    49f0:	e6 e5       	ldi	r30, 0x56	; 86
    49f2:	f0 e0       	ldi	r31, 0x00	; 0
    49f4:	80 81       	ld	r24, Z
    49f6:	88 23       	and	r24, r24
    49f8:	dc f7       	brge	.-10     	; 0x49f0 <I2C_u8ReadWithAck+0x10>
	return TWDR ;
    49fa:	e3 e2       	ldi	r30, 0x23	; 35
    49fc:	f0 e0       	ldi	r31, 0x00	; 0
    49fe:	80 81       	ld	r24, Z
}
    4a00:	cf 91       	pop	r28
    4a02:	df 91       	pop	r29
    4a04:	08 95       	ret

00004a06 <GIE_voidEnable>:
#include"GIE_priv.h"



void GIE_voidEnable(void)
{
    4a06:	df 93       	push	r29
    4a08:	cf 93       	push	r28
    4a0a:	cd b7       	in	r28, 0x3d	; 61
    4a0c:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,INTEURRPT_PIN);
    4a0e:	af e5       	ldi	r26, 0x5F	; 95
    4a10:	b0 e0       	ldi	r27, 0x00	; 0
    4a12:	ef e5       	ldi	r30, 0x5F	; 95
    4a14:	f0 e0       	ldi	r31, 0x00	; 0
    4a16:	80 81       	ld	r24, Z
    4a18:	80 68       	ori	r24, 0x80	; 128
    4a1a:	8c 93       	st	X, r24
}
    4a1c:	cf 91       	pop	r28
    4a1e:	df 91       	pop	r29
    4a20:	08 95       	ret

00004a22 <GIE_voidDisable>:


void GIE_voidDisable(void)
{
    4a22:	df 93       	push	r29
    4a24:	cf 93       	push	r28
    4a26:	cd b7       	in	r28, 0x3d	; 61
    4a28:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,INTEURRPT_PIN);
    4a2a:	af e5       	ldi	r26, 0x5F	; 95
    4a2c:	b0 e0       	ldi	r27, 0x00	; 0
    4a2e:	ef e5       	ldi	r30, 0x5F	; 95
    4a30:	f0 e0       	ldi	r31, 0x00	; 0
    4a32:	80 81       	ld	r24, Z
    4a34:	8f 77       	andi	r24, 0x7F	; 127
    4a36:	8c 93       	st	X, r24
}
    4a38:	cf 91       	pop	r28
    4a3a:	df 91       	pop	r29
    4a3c:	08 95       	ret

00004a3e <DIO_Init>:
#include "DIO_Register.h"
#include "DIO_interface.h"


void DIO_Init(void)
{
    4a3e:	df 93       	push	r29
    4a40:	cf 93       	push	r28
    4a42:	cd b7       	in	r28, 0x3d	; 61
    4a44:	de b7       	in	r29, 0x3e	; 62
	DDRA = CONC(DIO_PIN_NUM_A7_DIR ,DIO_PIN_NUM_A6_DIR ,DIO_PIN_NUM_A5_DIR ,DIO_PIN_NUM_A4_DIR ,DIO_PIN_NUM_A3_DIR ,DIO_PIN_NUM_A2_DIR,DIO_PIN_NUM_A1_DIR ,DIO_PIN_NUM_A0_DIR  );
    4a46:	ea e3       	ldi	r30, 0x3A	; 58
    4a48:	f0 e0       	ldi	r31, 0x00	; 0
    4a4a:	8e ef       	ldi	r24, 0xFE	; 254
    4a4c:	80 83       	st	Z, r24
	DDRB = CONC(DIO_PIN_NUM_B7_DIR ,DIO_PIN_NUM_B6_DIR ,DIO_PIN_NUM_B5_DIR ,DIO_PIN_NUM_B4_DIR ,DIO_PIN_NUM_B3_DIR ,DIO_PIN_NUM_B2_DIR,DIO_PIN_NUM_B1_DIR ,DIO_PIN_NUM_B0_DIR  );
    4a4e:	e7 e3       	ldi	r30, 0x37	; 55
    4a50:	f0 e0       	ldi	r31, 0x00	; 0
    4a52:	8f ef       	ldi	r24, 0xFF	; 255
    4a54:	80 83       	st	Z, r24
	DDRC = CONC(DIO_PIN_NUM_C7_DIR ,DIO_PIN_NUM_C6_DIR ,DIO_PIN_NUM_C5_DIR ,DIO_PIN_NUM_C4_DIR ,DIO_PIN_NUM_C3_DIR ,DIO_PIN_NUM_C2_DIR,DIO_PIN_NUM_C1_DIR ,DIO_PIN_NUM_C0_DIR  );
    4a56:	e4 e3       	ldi	r30, 0x34	; 52
    4a58:	f0 e0       	ldi	r31, 0x00	; 0
    4a5a:	8f ef       	ldi	r24, 0xFF	; 255
    4a5c:	80 83       	st	Z, r24
	DDRD = CONC(DIO_PIN_NUM_D7_DIR ,DIO_PIN_NUM_D6_DIR ,DIO_PIN_NUM_D5_DIR ,DIO_PIN_NUM_D4_DIR ,DIO_PIN_NUM_D3_DIR ,DIO_PIN_NUM_D2_DIR,DIO_PIN_NUM_D1_DIR ,DIO_PIN_NUM_D0_DIR  );
    4a5e:	e1 e3       	ldi	r30, 0x31	; 49
    4a60:	f0 e0       	ldi	r31, 0x00	; 0
    4a62:	8e ef       	ldi	r24, 0xFE	; 254
    4a64:	80 83       	st	Z, r24
}
    4a66:	cf 91       	pop	r28
    4a68:	df 91       	pop	r29
    4a6a:	08 95       	ret

00004a6c <DIO_enuTogglePin>:

//write pins value

tenuErrorStatus DIO_enuTogglePin(uint8 u8PinNumCpy ){
    4a6c:	df 93       	push	r29
    4a6e:	cf 93       	push	r28
    4a70:	00 d0       	rcall	.+0      	; 0x4a72 <DIO_enuTogglePin+0x6>
    4a72:	cd b7       	in	r28, 0x3d	; 61
    4a74:	de b7       	in	r29, 0x3e	; 62
    4a76:	8a 83       	std	Y+2, r24	; 0x02
	tenuErrorStatus retunState=EOK;
    4a78:	19 82       	std	Y+1, r1	; 0x01
	if(u8PinNumCpy >= 0  && u8PinNumCpy <= 7)
    4a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a7c:	88 30       	cpi	r24, 0x08	; 8
    4a7e:	a0 f4       	brcc	.+40     	; 0x4aa8 <DIO_enuTogglePin+0x3c>
			{
				Toggle_BIT(PORTA, u8PinNumCpy);
    4a80:	ab e3       	ldi	r26, 0x3B	; 59
    4a82:	b0 e0       	ldi	r27, 0x00	; 0
    4a84:	eb e3       	ldi	r30, 0x3B	; 59
    4a86:	f0 e0       	ldi	r31, 0x00	; 0
    4a88:	80 81       	ld	r24, Z
    4a8a:	48 2f       	mov	r20, r24
    4a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a8e:	28 2f       	mov	r18, r24
    4a90:	30 e0       	ldi	r19, 0x00	; 0
    4a92:	81 e0       	ldi	r24, 0x01	; 1
    4a94:	90 e0       	ldi	r25, 0x00	; 0
    4a96:	02 2e       	mov	r0, r18
    4a98:	02 c0       	rjmp	.+4      	; 0x4a9e <DIO_enuTogglePin+0x32>
    4a9a:	88 0f       	add	r24, r24
    4a9c:	99 1f       	adc	r25, r25
    4a9e:	0a 94       	dec	r0
    4aa0:	e2 f7       	brpl	.-8      	; 0x4a9a <DIO_enuTogglePin+0x2e>
    4aa2:	84 27       	eor	r24, r20
    4aa4:	8c 93       	st	X, r24
    4aa6:	59 c0       	rjmp	.+178    	; 0x4b5a <DIO_enuTogglePin+0xee>
			}
			else if( u8PinNumCpy >= 8  && u8PinNumCpy <= 15 )
    4aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    4aaa:	88 30       	cpi	r24, 0x08	; 8
    4aac:	d0 f0       	brcs	.+52     	; 0x4ae2 <DIO_enuTogglePin+0x76>
    4aae:	8a 81       	ldd	r24, Y+2	; 0x02
    4ab0:	80 31       	cpi	r24, 0x10	; 16
    4ab2:	b8 f4       	brcc	.+46     	; 0x4ae2 <DIO_enuTogglePin+0x76>
			{
				Toggle_BIT(PORTB, (u8PinNumCpy%8));
    4ab4:	a8 e3       	ldi	r26, 0x38	; 56
    4ab6:	b0 e0       	ldi	r27, 0x00	; 0
    4ab8:	e8 e3       	ldi	r30, 0x38	; 56
    4aba:	f0 e0       	ldi	r31, 0x00	; 0
    4abc:	80 81       	ld	r24, Z
    4abe:	48 2f       	mov	r20, r24
    4ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ac2:	88 2f       	mov	r24, r24
    4ac4:	90 e0       	ldi	r25, 0x00	; 0
    4ac6:	9c 01       	movw	r18, r24
    4ac8:	27 70       	andi	r18, 0x07	; 7
    4aca:	30 70       	andi	r19, 0x00	; 0
    4acc:	81 e0       	ldi	r24, 0x01	; 1
    4ace:	90 e0       	ldi	r25, 0x00	; 0
    4ad0:	02 2e       	mov	r0, r18
    4ad2:	02 c0       	rjmp	.+4      	; 0x4ad8 <DIO_enuTogglePin+0x6c>
    4ad4:	88 0f       	add	r24, r24
    4ad6:	99 1f       	adc	r25, r25
    4ad8:	0a 94       	dec	r0
    4ada:	e2 f7       	brpl	.-8      	; 0x4ad4 <DIO_enuTogglePin+0x68>
    4adc:	84 27       	eor	r24, r20
    4ade:	8c 93       	st	X, r24
    4ae0:	3c c0       	rjmp	.+120    	; 0x4b5a <DIO_enuTogglePin+0xee>
			}
			else if( u8PinNumCpy >= 16  && u8PinNumCpy <= 23 )
    4ae2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae4:	80 31       	cpi	r24, 0x10	; 16
    4ae6:	d0 f0       	brcs	.+52     	; 0x4b1c <DIO_enuTogglePin+0xb0>
    4ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    4aea:	88 31       	cpi	r24, 0x18	; 24
    4aec:	b8 f4       	brcc	.+46     	; 0x4b1c <DIO_enuTogglePin+0xb0>
			{
				Toggle_BIT(PORTC, (u8PinNumCpy%8));
    4aee:	a5 e3       	ldi	r26, 0x35	; 53
    4af0:	b0 e0       	ldi	r27, 0x00	; 0
    4af2:	e5 e3       	ldi	r30, 0x35	; 53
    4af4:	f0 e0       	ldi	r31, 0x00	; 0
    4af6:	80 81       	ld	r24, Z
    4af8:	48 2f       	mov	r20, r24
    4afa:	8a 81       	ldd	r24, Y+2	; 0x02
    4afc:	88 2f       	mov	r24, r24
    4afe:	90 e0       	ldi	r25, 0x00	; 0
    4b00:	9c 01       	movw	r18, r24
    4b02:	27 70       	andi	r18, 0x07	; 7
    4b04:	30 70       	andi	r19, 0x00	; 0
    4b06:	81 e0       	ldi	r24, 0x01	; 1
    4b08:	90 e0       	ldi	r25, 0x00	; 0
    4b0a:	02 2e       	mov	r0, r18
    4b0c:	02 c0       	rjmp	.+4      	; 0x4b12 <DIO_enuTogglePin+0xa6>
    4b0e:	88 0f       	add	r24, r24
    4b10:	99 1f       	adc	r25, r25
    4b12:	0a 94       	dec	r0
    4b14:	e2 f7       	brpl	.-8      	; 0x4b0e <DIO_enuTogglePin+0xa2>
    4b16:	84 27       	eor	r24, r20
    4b18:	8c 93       	st	X, r24
    4b1a:	1f c0       	rjmp	.+62     	; 0x4b5a <DIO_enuTogglePin+0xee>
			}
			else if( u8PinNumCpy >= 24  && u8PinNumCpy <= 31 )
    4b1c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b1e:	88 31       	cpi	r24, 0x18	; 24
    4b20:	d0 f0       	brcs	.+52     	; 0x4b56 <DIO_enuTogglePin+0xea>
    4b22:	8a 81       	ldd	r24, Y+2	; 0x02
    4b24:	80 32       	cpi	r24, 0x20	; 32
    4b26:	b8 f4       	brcc	.+46     	; 0x4b56 <DIO_enuTogglePin+0xea>
			{
				Toggle_BIT(PORTD, (u8PinNumCpy%8));
    4b28:	a2 e3       	ldi	r26, 0x32	; 50
    4b2a:	b0 e0       	ldi	r27, 0x00	; 0
    4b2c:	e2 e3       	ldi	r30, 0x32	; 50
    4b2e:	f0 e0       	ldi	r31, 0x00	; 0
    4b30:	80 81       	ld	r24, Z
    4b32:	48 2f       	mov	r20, r24
    4b34:	8a 81       	ldd	r24, Y+2	; 0x02
    4b36:	88 2f       	mov	r24, r24
    4b38:	90 e0       	ldi	r25, 0x00	; 0
    4b3a:	9c 01       	movw	r18, r24
    4b3c:	27 70       	andi	r18, 0x07	; 7
    4b3e:	30 70       	andi	r19, 0x00	; 0
    4b40:	81 e0       	ldi	r24, 0x01	; 1
    4b42:	90 e0       	ldi	r25, 0x00	; 0
    4b44:	02 2e       	mov	r0, r18
    4b46:	02 c0       	rjmp	.+4      	; 0x4b4c <DIO_enuTogglePin+0xe0>
    4b48:	88 0f       	add	r24, r24
    4b4a:	99 1f       	adc	r25, r25
    4b4c:	0a 94       	dec	r0
    4b4e:	e2 f7       	brpl	.-8      	; 0x4b48 <DIO_enuTogglePin+0xdc>
    4b50:	84 27       	eor	r24, r20
    4b52:	8c 93       	st	X, r24
    4b54:	02 c0       	rjmp	.+4      	; 0x4b5a <DIO_enuTogglePin+0xee>
			}
			else
			{
				retunState = PARAMRETER_OUT_RANGE;
    4b56:	82 e0       	ldi	r24, 0x02	; 2
    4b58:	89 83       	std	Y+1, r24	; 0x01
			}
	return retunState;
    4b5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b5c:	0f 90       	pop	r0
    4b5e:	0f 90       	pop	r0
    4b60:	cf 91       	pop	r28
    4b62:	df 91       	pop	r29
    4b64:	08 95       	ret

00004b66 <DIO_enuWritePin>:
tenuErrorStatus DIO_enuWritePin(uint8 u8PinNumCpy , uint8 u8PinValueCpy)
{
    4b66:	df 93       	push	r29
    4b68:	cf 93       	push	r28
    4b6a:	00 d0       	rcall	.+0      	; 0x4b6c <DIO_enuWritePin+0x6>
    4b6c:	00 d0       	rcall	.+0      	; 0x4b6e <DIO_enuWritePin+0x8>
    4b6e:	0f 92       	push	r0
    4b70:	cd b7       	in	r28, 0x3d	; 61
    4b72:	de b7       	in	r29, 0x3e	; 62
    4b74:	8a 83       	std	Y+2, r24	; 0x02
    4b76:	6b 83       	std	Y+3, r22	; 0x03
	tenuErrorStatus retunState=EOK;
    4b78:	19 82       	std	Y+1, r1	; 0x01
	switch(u8PinValueCpy)
    4b7a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b7c:	28 2f       	mov	r18, r24
    4b7e:	30 e0       	ldi	r19, 0x00	; 0
    4b80:	3d 83       	std	Y+5, r19	; 0x05
    4b82:	2c 83       	std	Y+4, r18	; 0x04
    4b84:	8c 81       	ldd	r24, Y+4	; 0x04
    4b86:	9d 81       	ldd	r25, Y+5	; 0x05
    4b88:	00 97       	sbiw	r24, 0x00	; 0
    4b8a:	39 f0       	breq	.+14     	; 0x4b9a <DIO_enuWritePin+0x34>
    4b8c:	2c 81       	ldd	r18, Y+4	; 0x04
    4b8e:	3d 81       	ldd	r19, Y+5	; 0x05
    4b90:	21 30       	cpi	r18, 0x01	; 1
    4b92:	31 05       	cpc	r19, r1
    4b94:	09 f4       	brne	.+2      	; 0x4b98 <DIO_enuWritePin+0x32>
    4b96:	76 c0       	rjmp	.+236    	; 0x4c84 <DIO_enuWritePin+0x11e>
    4b98:	e5 c0       	rjmp	.+458    	; 0x4d64 <DIO_enuWritePin+0x1fe>
	{
	case DIO_LOW:
		if(u8PinNumCpy >= 0  && u8PinNumCpy <= 7)
    4b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b9c:	88 30       	cpi	r24, 0x08	; 8
    4b9e:	a8 f4       	brcc	.+42     	; 0x4bca <DIO_enuWritePin+0x64>
		{
			CLR_BIT(PORTA, u8PinNumCpy);
    4ba0:	ab e3       	ldi	r26, 0x3B	; 59
    4ba2:	b0 e0       	ldi	r27, 0x00	; 0
    4ba4:	eb e3       	ldi	r30, 0x3B	; 59
    4ba6:	f0 e0       	ldi	r31, 0x00	; 0
    4ba8:	80 81       	ld	r24, Z
    4baa:	48 2f       	mov	r20, r24
    4bac:	8a 81       	ldd	r24, Y+2	; 0x02
    4bae:	28 2f       	mov	r18, r24
    4bb0:	30 e0       	ldi	r19, 0x00	; 0
    4bb2:	81 e0       	ldi	r24, 0x01	; 1
    4bb4:	90 e0       	ldi	r25, 0x00	; 0
    4bb6:	02 2e       	mov	r0, r18
    4bb8:	02 c0       	rjmp	.+4      	; 0x4bbe <DIO_enuWritePin+0x58>
    4bba:	88 0f       	add	r24, r24
    4bbc:	99 1f       	adc	r25, r25
    4bbe:	0a 94       	dec	r0
    4bc0:	e2 f7       	brpl	.-8      	; 0x4bba <DIO_enuWritePin+0x54>
    4bc2:	80 95       	com	r24
    4bc4:	84 23       	and	r24, r20
    4bc6:	8c 93       	st	X, r24
    4bc8:	cd c0       	rjmp	.+410    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else if( u8PinNumCpy >= 8  && u8PinNumCpy <= 15 )
    4bca:	8a 81       	ldd	r24, Y+2	; 0x02
    4bcc:	88 30       	cpi	r24, 0x08	; 8
    4bce:	d8 f0       	brcs	.+54     	; 0x4c06 <DIO_enuWritePin+0xa0>
    4bd0:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd2:	80 31       	cpi	r24, 0x10	; 16
    4bd4:	c0 f4       	brcc	.+48     	; 0x4c06 <DIO_enuWritePin+0xa0>
		{
			CLR_BIT(PORTB, (u8PinNumCpy%8));
    4bd6:	a8 e3       	ldi	r26, 0x38	; 56
    4bd8:	b0 e0       	ldi	r27, 0x00	; 0
    4bda:	e8 e3       	ldi	r30, 0x38	; 56
    4bdc:	f0 e0       	ldi	r31, 0x00	; 0
    4bde:	80 81       	ld	r24, Z
    4be0:	48 2f       	mov	r20, r24
    4be2:	8a 81       	ldd	r24, Y+2	; 0x02
    4be4:	88 2f       	mov	r24, r24
    4be6:	90 e0       	ldi	r25, 0x00	; 0
    4be8:	9c 01       	movw	r18, r24
    4bea:	27 70       	andi	r18, 0x07	; 7
    4bec:	30 70       	andi	r19, 0x00	; 0
    4bee:	81 e0       	ldi	r24, 0x01	; 1
    4bf0:	90 e0       	ldi	r25, 0x00	; 0
    4bf2:	02 2e       	mov	r0, r18
    4bf4:	02 c0       	rjmp	.+4      	; 0x4bfa <DIO_enuWritePin+0x94>
    4bf6:	88 0f       	add	r24, r24
    4bf8:	99 1f       	adc	r25, r25
    4bfa:	0a 94       	dec	r0
    4bfc:	e2 f7       	brpl	.-8      	; 0x4bf6 <DIO_enuWritePin+0x90>
    4bfe:	80 95       	com	r24
    4c00:	84 23       	and	r24, r20
    4c02:	8c 93       	st	X, r24
    4c04:	af c0       	rjmp	.+350    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else if( u8PinNumCpy >= 16  && u8PinNumCpy <= 23 )
    4c06:	8a 81       	ldd	r24, Y+2	; 0x02
    4c08:	80 31       	cpi	r24, 0x10	; 16
    4c0a:	d8 f0       	brcs	.+54     	; 0x4c42 <DIO_enuWritePin+0xdc>
    4c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c0e:	88 31       	cpi	r24, 0x18	; 24
    4c10:	c0 f4       	brcc	.+48     	; 0x4c42 <DIO_enuWritePin+0xdc>
		{
			CLR_BIT(PORTC, (u8PinNumCpy%8));
    4c12:	a5 e3       	ldi	r26, 0x35	; 53
    4c14:	b0 e0       	ldi	r27, 0x00	; 0
    4c16:	e5 e3       	ldi	r30, 0x35	; 53
    4c18:	f0 e0       	ldi	r31, 0x00	; 0
    4c1a:	80 81       	ld	r24, Z
    4c1c:	48 2f       	mov	r20, r24
    4c1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c20:	88 2f       	mov	r24, r24
    4c22:	90 e0       	ldi	r25, 0x00	; 0
    4c24:	9c 01       	movw	r18, r24
    4c26:	27 70       	andi	r18, 0x07	; 7
    4c28:	30 70       	andi	r19, 0x00	; 0
    4c2a:	81 e0       	ldi	r24, 0x01	; 1
    4c2c:	90 e0       	ldi	r25, 0x00	; 0
    4c2e:	02 2e       	mov	r0, r18
    4c30:	02 c0       	rjmp	.+4      	; 0x4c36 <DIO_enuWritePin+0xd0>
    4c32:	88 0f       	add	r24, r24
    4c34:	99 1f       	adc	r25, r25
    4c36:	0a 94       	dec	r0
    4c38:	e2 f7       	brpl	.-8      	; 0x4c32 <DIO_enuWritePin+0xcc>
    4c3a:	80 95       	com	r24
    4c3c:	84 23       	and	r24, r20
    4c3e:	8c 93       	st	X, r24
    4c40:	91 c0       	rjmp	.+290    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else if( u8PinNumCpy >= 24  && u8PinNumCpy <= 31 )
    4c42:	8a 81       	ldd	r24, Y+2	; 0x02
    4c44:	88 31       	cpi	r24, 0x18	; 24
    4c46:	d8 f0       	brcs	.+54     	; 0x4c7e <DIO_enuWritePin+0x118>
    4c48:	8a 81       	ldd	r24, Y+2	; 0x02
    4c4a:	80 32       	cpi	r24, 0x20	; 32
    4c4c:	c0 f4       	brcc	.+48     	; 0x4c7e <DIO_enuWritePin+0x118>
		{
			CLR_BIT(PORTD, (u8PinNumCpy%8));
    4c4e:	a2 e3       	ldi	r26, 0x32	; 50
    4c50:	b0 e0       	ldi	r27, 0x00	; 0
    4c52:	e2 e3       	ldi	r30, 0x32	; 50
    4c54:	f0 e0       	ldi	r31, 0x00	; 0
    4c56:	80 81       	ld	r24, Z
    4c58:	48 2f       	mov	r20, r24
    4c5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c5c:	88 2f       	mov	r24, r24
    4c5e:	90 e0       	ldi	r25, 0x00	; 0
    4c60:	9c 01       	movw	r18, r24
    4c62:	27 70       	andi	r18, 0x07	; 7
    4c64:	30 70       	andi	r19, 0x00	; 0
    4c66:	81 e0       	ldi	r24, 0x01	; 1
    4c68:	90 e0       	ldi	r25, 0x00	; 0
    4c6a:	02 2e       	mov	r0, r18
    4c6c:	02 c0       	rjmp	.+4      	; 0x4c72 <DIO_enuWritePin+0x10c>
    4c6e:	88 0f       	add	r24, r24
    4c70:	99 1f       	adc	r25, r25
    4c72:	0a 94       	dec	r0
    4c74:	e2 f7       	brpl	.-8      	; 0x4c6e <DIO_enuWritePin+0x108>
    4c76:	80 95       	com	r24
    4c78:	84 23       	and	r24, r20
    4c7a:	8c 93       	st	X, r24
    4c7c:	73 c0       	rjmp	.+230    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else
		{
			retunState = PARAMRETER_OUT_RANGE;
    4c7e:	82 e0       	ldi	r24, 0x02	; 2
    4c80:	89 83       	std	Y+1, r24	; 0x01
    4c82:	70 c0       	rjmp	.+224    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		break;

	case DIO_HIGH:
		if(u8PinNumCpy >= 0  && u8PinNumCpy <= 7)
    4c84:	8a 81       	ldd	r24, Y+2	; 0x02
    4c86:	88 30       	cpi	r24, 0x08	; 8
    4c88:	a0 f4       	brcc	.+40     	; 0x4cb2 <DIO_enuWritePin+0x14c>
		{
			SET_BIT(PORTA, u8PinNumCpy);
    4c8a:	ab e3       	ldi	r26, 0x3B	; 59
    4c8c:	b0 e0       	ldi	r27, 0x00	; 0
    4c8e:	eb e3       	ldi	r30, 0x3B	; 59
    4c90:	f0 e0       	ldi	r31, 0x00	; 0
    4c92:	80 81       	ld	r24, Z
    4c94:	48 2f       	mov	r20, r24
    4c96:	8a 81       	ldd	r24, Y+2	; 0x02
    4c98:	28 2f       	mov	r18, r24
    4c9a:	30 e0       	ldi	r19, 0x00	; 0
    4c9c:	81 e0       	ldi	r24, 0x01	; 1
    4c9e:	90 e0       	ldi	r25, 0x00	; 0
    4ca0:	02 2e       	mov	r0, r18
    4ca2:	02 c0       	rjmp	.+4      	; 0x4ca8 <DIO_enuWritePin+0x142>
    4ca4:	88 0f       	add	r24, r24
    4ca6:	99 1f       	adc	r25, r25
    4ca8:	0a 94       	dec	r0
    4caa:	e2 f7       	brpl	.-8      	; 0x4ca4 <DIO_enuWritePin+0x13e>
    4cac:	84 2b       	or	r24, r20
    4cae:	8c 93       	st	X, r24
    4cb0:	59 c0       	rjmp	.+178    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else if( u8PinNumCpy >= 8  && u8PinNumCpy <= 15 )
    4cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    4cb4:	88 30       	cpi	r24, 0x08	; 8
    4cb6:	d0 f0       	brcs	.+52     	; 0x4cec <DIO_enuWritePin+0x186>
    4cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    4cba:	80 31       	cpi	r24, 0x10	; 16
    4cbc:	b8 f4       	brcc	.+46     	; 0x4cec <DIO_enuWritePin+0x186>
		{
			SET_BIT(PORTB, (u8PinNumCpy%8));
    4cbe:	a8 e3       	ldi	r26, 0x38	; 56
    4cc0:	b0 e0       	ldi	r27, 0x00	; 0
    4cc2:	e8 e3       	ldi	r30, 0x38	; 56
    4cc4:	f0 e0       	ldi	r31, 0x00	; 0
    4cc6:	80 81       	ld	r24, Z
    4cc8:	48 2f       	mov	r20, r24
    4cca:	8a 81       	ldd	r24, Y+2	; 0x02
    4ccc:	88 2f       	mov	r24, r24
    4cce:	90 e0       	ldi	r25, 0x00	; 0
    4cd0:	9c 01       	movw	r18, r24
    4cd2:	27 70       	andi	r18, 0x07	; 7
    4cd4:	30 70       	andi	r19, 0x00	; 0
    4cd6:	81 e0       	ldi	r24, 0x01	; 1
    4cd8:	90 e0       	ldi	r25, 0x00	; 0
    4cda:	02 2e       	mov	r0, r18
    4cdc:	02 c0       	rjmp	.+4      	; 0x4ce2 <DIO_enuWritePin+0x17c>
    4cde:	88 0f       	add	r24, r24
    4ce0:	99 1f       	adc	r25, r25
    4ce2:	0a 94       	dec	r0
    4ce4:	e2 f7       	brpl	.-8      	; 0x4cde <DIO_enuWritePin+0x178>
    4ce6:	84 2b       	or	r24, r20
    4ce8:	8c 93       	st	X, r24
    4cea:	3c c0       	rjmp	.+120    	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else if( u8PinNumCpy >= 16  && u8PinNumCpy <= 23 )
    4cec:	8a 81       	ldd	r24, Y+2	; 0x02
    4cee:	80 31       	cpi	r24, 0x10	; 16
    4cf0:	d0 f0       	brcs	.+52     	; 0x4d26 <DIO_enuWritePin+0x1c0>
    4cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    4cf4:	88 31       	cpi	r24, 0x18	; 24
    4cf6:	b8 f4       	brcc	.+46     	; 0x4d26 <DIO_enuWritePin+0x1c0>
		{
			SET_BIT(PORTC, (u8PinNumCpy%8));
    4cf8:	a5 e3       	ldi	r26, 0x35	; 53
    4cfa:	b0 e0       	ldi	r27, 0x00	; 0
    4cfc:	e5 e3       	ldi	r30, 0x35	; 53
    4cfe:	f0 e0       	ldi	r31, 0x00	; 0
    4d00:	80 81       	ld	r24, Z
    4d02:	48 2f       	mov	r20, r24
    4d04:	8a 81       	ldd	r24, Y+2	; 0x02
    4d06:	88 2f       	mov	r24, r24
    4d08:	90 e0       	ldi	r25, 0x00	; 0
    4d0a:	9c 01       	movw	r18, r24
    4d0c:	27 70       	andi	r18, 0x07	; 7
    4d0e:	30 70       	andi	r19, 0x00	; 0
    4d10:	81 e0       	ldi	r24, 0x01	; 1
    4d12:	90 e0       	ldi	r25, 0x00	; 0
    4d14:	02 2e       	mov	r0, r18
    4d16:	02 c0       	rjmp	.+4      	; 0x4d1c <DIO_enuWritePin+0x1b6>
    4d18:	88 0f       	add	r24, r24
    4d1a:	99 1f       	adc	r25, r25
    4d1c:	0a 94       	dec	r0
    4d1e:	e2 f7       	brpl	.-8      	; 0x4d18 <DIO_enuWritePin+0x1b2>
    4d20:	84 2b       	or	r24, r20
    4d22:	8c 93       	st	X, r24
    4d24:	1f c0       	rjmp	.+62     	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else if( u8PinNumCpy >= 24  && u8PinNumCpy <= 31 )
    4d26:	8a 81       	ldd	r24, Y+2	; 0x02
    4d28:	88 31       	cpi	r24, 0x18	; 24
    4d2a:	d0 f0       	brcs	.+52     	; 0x4d60 <DIO_enuWritePin+0x1fa>
    4d2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d2e:	80 32       	cpi	r24, 0x20	; 32
    4d30:	b8 f4       	brcc	.+46     	; 0x4d60 <DIO_enuWritePin+0x1fa>
		{
			SET_BIT(PORTD, (u8PinNumCpy%8));
    4d32:	a2 e3       	ldi	r26, 0x32	; 50
    4d34:	b0 e0       	ldi	r27, 0x00	; 0
    4d36:	e2 e3       	ldi	r30, 0x32	; 50
    4d38:	f0 e0       	ldi	r31, 0x00	; 0
    4d3a:	80 81       	ld	r24, Z
    4d3c:	48 2f       	mov	r20, r24
    4d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4d40:	88 2f       	mov	r24, r24
    4d42:	90 e0       	ldi	r25, 0x00	; 0
    4d44:	9c 01       	movw	r18, r24
    4d46:	27 70       	andi	r18, 0x07	; 7
    4d48:	30 70       	andi	r19, 0x00	; 0
    4d4a:	81 e0       	ldi	r24, 0x01	; 1
    4d4c:	90 e0       	ldi	r25, 0x00	; 0
    4d4e:	02 2e       	mov	r0, r18
    4d50:	02 c0       	rjmp	.+4      	; 0x4d56 <DIO_enuWritePin+0x1f0>
    4d52:	88 0f       	add	r24, r24
    4d54:	99 1f       	adc	r25, r25
    4d56:	0a 94       	dec	r0
    4d58:	e2 f7       	brpl	.-8      	; 0x4d52 <DIO_enuWritePin+0x1ec>
    4d5a:	84 2b       	or	r24, r20
    4d5c:	8c 93       	st	X, r24
    4d5e:	02 c0       	rjmp	.+4      	; 0x4d64 <DIO_enuWritePin+0x1fe>
		}
		else
		{
			retunState = PARAMRETER_OUT_RANGE;
    4d60:	82 e0       	ldi	r24, 0x02	; 2
    4d62:	89 83       	std	Y+1, r24	; 0x01
		break;
	default:
		//do nothing
		break;
	}
	return retunState;
    4d64:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d66:	0f 90       	pop	r0
    4d68:	0f 90       	pop	r0
    4d6a:	0f 90       	pop	r0
    4d6c:	0f 90       	pop	r0
    4d6e:	0f 90       	pop	r0
    4d70:	cf 91       	pop	r28
    4d72:	df 91       	pop	r29
    4d74:	08 95       	ret

00004d76 <DIO_enuReadPin>:

tenuErrorStatus DIO_enuReadPin(uint8 u8PinNumCpy , uint8* pu8PinValue)
{
    4d76:	df 93       	push	r29
    4d78:	cf 93       	push	r28
    4d7a:	00 d0       	rcall	.+0      	; 0x4d7c <DIO_enuReadPin+0x6>
    4d7c:	00 d0       	rcall	.+0      	; 0x4d7e <DIO_enuReadPin+0x8>
    4d7e:	cd b7       	in	r28, 0x3d	; 61
    4d80:	de b7       	in	r29, 0x3e	; 62
    4d82:	8a 83       	std	Y+2, r24	; 0x02
    4d84:	7c 83       	std	Y+4, r23	; 0x04
    4d86:	6b 83       	std	Y+3, r22	; 0x03
	tenuErrorStatus retunState=EOK;
    4d88:	19 82       	std	Y+1, r1	; 0x01
	if(u8PinNumCpy >= 0  && u8PinNumCpy <= 7)
    4d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d8c:	88 30       	cpi	r24, 0x08	; 8
    4d8e:	a0 f4       	brcc	.+40     	; 0x4db8 <DIO_enuReadPin+0x42>
	{
		*pu8PinValue = GET_BIT(PINA,u8PinNumCpy);
    4d90:	e9 e3       	ldi	r30, 0x39	; 57
    4d92:	f0 e0       	ldi	r31, 0x00	; 0
    4d94:	80 81       	ld	r24, Z
    4d96:	28 2f       	mov	r18, r24
    4d98:	30 e0       	ldi	r19, 0x00	; 0
    4d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4d9c:	88 2f       	mov	r24, r24
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
    4da0:	a9 01       	movw	r20, r18
    4da2:	02 c0       	rjmp	.+4      	; 0x4da8 <DIO_enuReadPin+0x32>
    4da4:	55 95       	asr	r21
    4da6:	47 95       	ror	r20
    4da8:	8a 95       	dec	r24
    4daa:	e2 f7       	brpl	.-8      	; 0x4da4 <DIO_enuReadPin+0x2e>
    4dac:	ca 01       	movw	r24, r20
    4dae:	81 70       	andi	r24, 0x01	; 1
    4db0:	eb 81       	ldd	r30, Y+3	; 0x03
    4db2:	fc 81       	ldd	r31, Y+4	; 0x04
    4db4:	80 83       	st	Z, r24
    4db6:	56 c0       	rjmp	.+172    	; 0x4e64 <DIO_enuReadPin+0xee>
	}
	else if( u8PinNumCpy >= 8  && u8PinNumCpy <= 15 )
    4db8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dba:	88 30       	cpi	r24, 0x08	; 8
    4dbc:	c8 f0       	brcs	.+50     	; 0x4df0 <DIO_enuReadPin+0x7a>
    4dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    4dc0:	80 31       	cpi	r24, 0x10	; 16
    4dc2:	b0 f4       	brcc	.+44     	; 0x4df0 <DIO_enuReadPin+0x7a>
	{
		*pu8PinValue = GET_BIT(PINB,(u8PinNumCpy%8));
    4dc4:	e6 e3       	ldi	r30, 0x36	; 54
    4dc6:	f0 e0       	ldi	r31, 0x00	; 0
    4dc8:	80 81       	ld	r24, Z
    4dca:	28 2f       	mov	r18, r24
    4dcc:	30 e0       	ldi	r19, 0x00	; 0
    4dce:	8a 81       	ldd	r24, Y+2	; 0x02
    4dd0:	88 2f       	mov	r24, r24
    4dd2:	90 e0       	ldi	r25, 0x00	; 0
    4dd4:	87 70       	andi	r24, 0x07	; 7
    4dd6:	90 70       	andi	r25, 0x00	; 0
    4dd8:	a9 01       	movw	r20, r18
    4dda:	02 c0       	rjmp	.+4      	; 0x4de0 <DIO_enuReadPin+0x6a>
    4ddc:	55 95       	asr	r21
    4dde:	47 95       	ror	r20
    4de0:	8a 95       	dec	r24
    4de2:	e2 f7       	brpl	.-8      	; 0x4ddc <DIO_enuReadPin+0x66>
    4de4:	ca 01       	movw	r24, r20
    4de6:	81 70       	andi	r24, 0x01	; 1
    4de8:	eb 81       	ldd	r30, Y+3	; 0x03
    4dea:	fc 81       	ldd	r31, Y+4	; 0x04
    4dec:	80 83       	st	Z, r24
    4dee:	3a c0       	rjmp	.+116    	; 0x4e64 <DIO_enuReadPin+0xee>
	}
	else if( u8PinNumCpy >= 16  && u8PinNumCpy <= 23 )
    4df0:	8a 81       	ldd	r24, Y+2	; 0x02
    4df2:	80 31       	cpi	r24, 0x10	; 16
    4df4:	c8 f0       	brcs	.+50     	; 0x4e28 <DIO_enuReadPin+0xb2>
    4df6:	8a 81       	ldd	r24, Y+2	; 0x02
    4df8:	88 31       	cpi	r24, 0x18	; 24
    4dfa:	b0 f4       	brcc	.+44     	; 0x4e28 <DIO_enuReadPin+0xb2>
	{
		*pu8PinValue = GET_BIT(PINC,(u8PinNumCpy%8));
    4dfc:	e3 e3       	ldi	r30, 0x33	; 51
    4dfe:	f0 e0       	ldi	r31, 0x00	; 0
    4e00:	80 81       	ld	r24, Z
    4e02:	28 2f       	mov	r18, r24
    4e04:	30 e0       	ldi	r19, 0x00	; 0
    4e06:	8a 81       	ldd	r24, Y+2	; 0x02
    4e08:	88 2f       	mov	r24, r24
    4e0a:	90 e0       	ldi	r25, 0x00	; 0
    4e0c:	87 70       	andi	r24, 0x07	; 7
    4e0e:	90 70       	andi	r25, 0x00	; 0
    4e10:	a9 01       	movw	r20, r18
    4e12:	02 c0       	rjmp	.+4      	; 0x4e18 <DIO_enuReadPin+0xa2>
    4e14:	55 95       	asr	r21
    4e16:	47 95       	ror	r20
    4e18:	8a 95       	dec	r24
    4e1a:	e2 f7       	brpl	.-8      	; 0x4e14 <DIO_enuReadPin+0x9e>
    4e1c:	ca 01       	movw	r24, r20
    4e1e:	81 70       	andi	r24, 0x01	; 1
    4e20:	eb 81       	ldd	r30, Y+3	; 0x03
    4e22:	fc 81       	ldd	r31, Y+4	; 0x04
    4e24:	80 83       	st	Z, r24
    4e26:	1e c0       	rjmp	.+60     	; 0x4e64 <DIO_enuReadPin+0xee>
	}
	else if( u8PinNumCpy >= 24  && u8PinNumCpy <= 31 )
    4e28:	8a 81       	ldd	r24, Y+2	; 0x02
    4e2a:	88 31       	cpi	r24, 0x18	; 24
    4e2c:	c8 f0       	brcs	.+50     	; 0x4e60 <DIO_enuReadPin+0xea>
    4e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e30:	80 32       	cpi	r24, 0x20	; 32
    4e32:	b0 f4       	brcc	.+44     	; 0x4e60 <DIO_enuReadPin+0xea>
	{
		*pu8PinValue = GET_BIT(PIND,(u8PinNumCpy%8));
    4e34:	e0 e3       	ldi	r30, 0x30	; 48
    4e36:	f0 e0       	ldi	r31, 0x00	; 0
    4e38:	80 81       	ld	r24, Z
    4e3a:	28 2f       	mov	r18, r24
    4e3c:	30 e0       	ldi	r19, 0x00	; 0
    4e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e40:	88 2f       	mov	r24, r24
    4e42:	90 e0       	ldi	r25, 0x00	; 0
    4e44:	87 70       	andi	r24, 0x07	; 7
    4e46:	90 70       	andi	r25, 0x00	; 0
    4e48:	a9 01       	movw	r20, r18
    4e4a:	02 c0       	rjmp	.+4      	; 0x4e50 <DIO_enuReadPin+0xda>
    4e4c:	55 95       	asr	r21
    4e4e:	47 95       	ror	r20
    4e50:	8a 95       	dec	r24
    4e52:	e2 f7       	brpl	.-8      	; 0x4e4c <DIO_enuReadPin+0xd6>
    4e54:	ca 01       	movw	r24, r20
    4e56:	81 70       	andi	r24, 0x01	; 1
    4e58:	eb 81       	ldd	r30, Y+3	; 0x03
    4e5a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e5c:	80 83       	st	Z, r24
    4e5e:	02 c0       	rjmp	.+4      	; 0x4e64 <DIO_enuReadPin+0xee>
	}
	else
	{
		retunState = PARAMRETER_OUT_RANGE;
    4e60:	82 e0       	ldi	r24, 0x02	; 2
    4e62:	89 83       	std	Y+1, r24	; 0x01
	}
	return retunState;
    4e64:	89 81       	ldd	r24, Y+1	; 0x01
}
    4e66:	0f 90       	pop	r0
    4e68:	0f 90       	pop	r0
    4e6a:	0f 90       	pop	r0
    4e6c:	0f 90       	pop	r0
    4e6e:	cf 91       	pop	r28
    4e70:	df 91       	pop	r29
    4e72:	08 95       	ret

00004e74 <DIO_enuStatePullup>:


/*to activate pull up resistor you need to make input direction and make PORT register high */
tenuErrorStatus DIO_enuStatePullup(uint8 u8PinNumCpy , uint8 u8StateCpy)
{
    4e74:	df 93       	push	r29
    4e76:	cf 93       	push	r28
    4e78:	00 d0       	rcall	.+0      	; 0x4e7a <DIO_enuStatePullup+0x6>
    4e7a:	00 d0       	rcall	.+0      	; 0x4e7c <DIO_enuStatePullup+0x8>
    4e7c:	0f 92       	push	r0
    4e7e:	cd b7       	in	r28, 0x3d	; 61
    4e80:	de b7       	in	r29, 0x3e	; 62
    4e82:	8a 83       	std	Y+2, r24	; 0x02
    4e84:	6b 83       	std	Y+3, r22	; 0x03
	tenuErrorStatus retunState=EOK;
    4e86:	19 82       	std	Y+1, r1	; 0x01
		switch(u8StateCpy)
    4e88:	8b 81       	ldd	r24, Y+3	; 0x03
    4e8a:	28 2f       	mov	r18, r24
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	3d 83       	std	Y+5, r19	; 0x05
    4e90:	2c 83       	std	Y+4, r18	; 0x04
    4e92:	8c 81       	ldd	r24, Y+4	; 0x04
    4e94:	9d 81       	ldd	r25, Y+5	; 0x05
    4e96:	00 97       	sbiw	r24, 0x00	; 0
    4e98:	39 f0       	breq	.+14     	; 0x4ea8 <DIO_enuStatePullup+0x34>
    4e9a:	2c 81       	ldd	r18, Y+4	; 0x04
    4e9c:	3d 81       	ldd	r19, Y+5	; 0x05
    4e9e:	21 30       	cpi	r18, 0x01	; 1
    4ea0:	31 05       	cpc	r19, r1
    4ea2:	09 f4       	brne	.+2      	; 0x4ea6 <DIO_enuStatePullup+0x32>
    4ea4:	76 c0       	rjmp	.+236    	; 0x4f92 <DIO_enuStatePullup+0x11e>
    4ea6:	e5 c0       	rjmp	.+458    	; 0x5072 <DIO_enuStatePullup+0x1fe>
		{
		case DIO_DEACTIVATE_PULLUP:
			if(u8PinNumCpy >= 0  && u8PinNumCpy <= 7)
    4ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eaa:	88 30       	cpi	r24, 0x08	; 8
    4eac:	a8 f4       	brcc	.+42     	; 0x4ed8 <DIO_enuStatePullup+0x64>
			{
				CLR_BIT(PORTA, u8PinNumCpy);
    4eae:	ab e3       	ldi	r26, 0x3B	; 59
    4eb0:	b0 e0       	ldi	r27, 0x00	; 0
    4eb2:	eb e3       	ldi	r30, 0x3B	; 59
    4eb4:	f0 e0       	ldi	r31, 0x00	; 0
    4eb6:	80 81       	ld	r24, Z
    4eb8:	48 2f       	mov	r20, r24
    4eba:	8a 81       	ldd	r24, Y+2	; 0x02
    4ebc:	28 2f       	mov	r18, r24
    4ebe:	30 e0       	ldi	r19, 0x00	; 0
    4ec0:	81 e0       	ldi	r24, 0x01	; 1
    4ec2:	90 e0       	ldi	r25, 0x00	; 0
    4ec4:	02 2e       	mov	r0, r18
    4ec6:	02 c0       	rjmp	.+4      	; 0x4ecc <DIO_enuStatePullup+0x58>
    4ec8:	88 0f       	add	r24, r24
    4eca:	99 1f       	adc	r25, r25
    4ecc:	0a 94       	dec	r0
    4ece:	e2 f7       	brpl	.-8      	; 0x4ec8 <DIO_enuStatePullup+0x54>
    4ed0:	80 95       	com	r24
    4ed2:	84 23       	and	r24, r20
    4ed4:	8c 93       	st	X, r24
    4ed6:	cd c0       	rjmp	.+410    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else if( u8PinNumCpy >= 8  && u8PinNumCpy <= 15 )
    4ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eda:	88 30       	cpi	r24, 0x08	; 8
    4edc:	d8 f0       	brcs	.+54     	; 0x4f14 <DIO_enuStatePullup+0xa0>
    4ede:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee0:	80 31       	cpi	r24, 0x10	; 16
    4ee2:	c0 f4       	brcc	.+48     	; 0x4f14 <DIO_enuStatePullup+0xa0>
			{
				CLR_BIT(PORTB, (u8PinNumCpy%8));
    4ee4:	a8 e3       	ldi	r26, 0x38	; 56
    4ee6:	b0 e0       	ldi	r27, 0x00	; 0
    4ee8:	e8 e3       	ldi	r30, 0x38	; 56
    4eea:	f0 e0       	ldi	r31, 0x00	; 0
    4eec:	80 81       	ld	r24, Z
    4eee:	48 2f       	mov	r20, r24
    4ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ef2:	88 2f       	mov	r24, r24
    4ef4:	90 e0       	ldi	r25, 0x00	; 0
    4ef6:	9c 01       	movw	r18, r24
    4ef8:	27 70       	andi	r18, 0x07	; 7
    4efa:	30 70       	andi	r19, 0x00	; 0
    4efc:	81 e0       	ldi	r24, 0x01	; 1
    4efe:	90 e0       	ldi	r25, 0x00	; 0
    4f00:	02 2e       	mov	r0, r18
    4f02:	02 c0       	rjmp	.+4      	; 0x4f08 <DIO_enuStatePullup+0x94>
    4f04:	88 0f       	add	r24, r24
    4f06:	99 1f       	adc	r25, r25
    4f08:	0a 94       	dec	r0
    4f0a:	e2 f7       	brpl	.-8      	; 0x4f04 <DIO_enuStatePullup+0x90>
    4f0c:	80 95       	com	r24
    4f0e:	84 23       	and	r24, r20
    4f10:	8c 93       	st	X, r24
    4f12:	af c0       	rjmp	.+350    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else if( u8PinNumCpy >= 16  && u8PinNumCpy <= 23 )
    4f14:	8a 81       	ldd	r24, Y+2	; 0x02
    4f16:	80 31       	cpi	r24, 0x10	; 16
    4f18:	d8 f0       	brcs	.+54     	; 0x4f50 <DIO_enuStatePullup+0xdc>
    4f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f1c:	88 31       	cpi	r24, 0x18	; 24
    4f1e:	c0 f4       	brcc	.+48     	; 0x4f50 <DIO_enuStatePullup+0xdc>
			{
				CLR_BIT(PORTC, (u8PinNumCpy%8));
    4f20:	a5 e3       	ldi	r26, 0x35	; 53
    4f22:	b0 e0       	ldi	r27, 0x00	; 0
    4f24:	e5 e3       	ldi	r30, 0x35	; 53
    4f26:	f0 e0       	ldi	r31, 0x00	; 0
    4f28:	80 81       	ld	r24, Z
    4f2a:	48 2f       	mov	r20, r24
    4f2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f2e:	88 2f       	mov	r24, r24
    4f30:	90 e0       	ldi	r25, 0x00	; 0
    4f32:	9c 01       	movw	r18, r24
    4f34:	27 70       	andi	r18, 0x07	; 7
    4f36:	30 70       	andi	r19, 0x00	; 0
    4f38:	81 e0       	ldi	r24, 0x01	; 1
    4f3a:	90 e0       	ldi	r25, 0x00	; 0
    4f3c:	02 2e       	mov	r0, r18
    4f3e:	02 c0       	rjmp	.+4      	; 0x4f44 <DIO_enuStatePullup+0xd0>
    4f40:	88 0f       	add	r24, r24
    4f42:	99 1f       	adc	r25, r25
    4f44:	0a 94       	dec	r0
    4f46:	e2 f7       	brpl	.-8      	; 0x4f40 <DIO_enuStatePullup+0xcc>
    4f48:	80 95       	com	r24
    4f4a:	84 23       	and	r24, r20
    4f4c:	8c 93       	st	X, r24
    4f4e:	91 c0       	rjmp	.+290    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else if( u8PinNumCpy >= 24  && u8PinNumCpy <= 31 )
    4f50:	8a 81       	ldd	r24, Y+2	; 0x02
    4f52:	88 31       	cpi	r24, 0x18	; 24
    4f54:	d8 f0       	brcs	.+54     	; 0x4f8c <DIO_enuStatePullup+0x118>
    4f56:	8a 81       	ldd	r24, Y+2	; 0x02
    4f58:	80 32       	cpi	r24, 0x20	; 32
    4f5a:	c0 f4       	brcc	.+48     	; 0x4f8c <DIO_enuStatePullup+0x118>
			{
				CLR_BIT(PORTD, (u8PinNumCpy%8));
    4f5c:	a2 e3       	ldi	r26, 0x32	; 50
    4f5e:	b0 e0       	ldi	r27, 0x00	; 0
    4f60:	e2 e3       	ldi	r30, 0x32	; 50
    4f62:	f0 e0       	ldi	r31, 0x00	; 0
    4f64:	80 81       	ld	r24, Z
    4f66:	48 2f       	mov	r20, r24
    4f68:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6a:	88 2f       	mov	r24, r24
    4f6c:	90 e0       	ldi	r25, 0x00	; 0
    4f6e:	9c 01       	movw	r18, r24
    4f70:	27 70       	andi	r18, 0x07	; 7
    4f72:	30 70       	andi	r19, 0x00	; 0
    4f74:	81 e0       	ldi	r24, 0x01	; 1
    4f76:	90 e0       	ldi	r25, 0x00	; 0
    4f78:	02 2e       	mov	r0, r18
    4f7a:	02 c0       	rjmp	.+4      	; 0x4f80 <DIO_enuStatePullup+0x10c>
    4f7c:	88 0f       	add	r24, r24
    4f7e:	99 1f       	adc	r25, r25
    4f80:	0a 94       	dec	r0
    4f82:	e2 f7       	brpl	.-8      	; 0x4f7c <DIO_enuStatePullup+0x108>
    4f84:	80 95       	com	r24
    4f86:	84 23       	and	r24, r20
    4f88:	8c 93       	st	X, r24
    4f8a:	73 c0       	rjmp	.+230    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else
			{
				retunState = PARAMRETER_OUT_RANGE;
    4f8c:	82 e0       	ldi	r24, 0x02	; 2
    4f8e:	89 83       	std	Y+1, r24	; 0x01
    4f90:	70 c0       	rjmp	.+224    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			break;

		case DIO_ACTIVATE_PULLUP:
			if(u8PinNumCpy >= 0  && u8PinNumCpy <= 7)
    4f92:	8a 81       	ldd	r24, Y+2	; 0x02
    4f94:	88 30       	cpi	r24, 0x08	; 8
    4f96:	a0 f4       	brcc	.+40     	; 0x4fc0 <DIO_enuStatePullup+0x14c>
			{
				SET_BIT(PORTA, u8PinNumCpy);
    4f98:	ab e3       	ldi	r26, 0x3B	; 59
    4f9a:	b0 e0       	ldi	r27, 0x00	; 0
    4f9c:	eb e3       	ldi	r30, 0x3B	; 59
    4f9e:	f0 e0       	ldi	r31, 0x00	; 0
    4fa0:	80 81       	ld	r24, Z
    4fa2:	48 2f       	mov	r20, r24
    4fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    4fa6:	28 2f       	mov	r18, r24
    4fa8:	30 e0       	ldi	r19, 0x00	; 0
    4faa:	81 e0       	ldi	r24, 0x01	; 1
    4fac:	90 e0       	ldi	r25, 0x00	; 0
    4fae:	02 2e       	mov	r0, r18
    4fb0:	02 c0       	rjmp	.+4      	; 0x4fb6 <DIO_enuStatePullup+0x142>
    4fb2:	88 0f       	add	r24, r24
    4fb4:	99 1f       	adc	r25, r25
    4fb6:	0a 94       	dec	r0
    4fb8:	e2 f7       	brpl	.-8      	; 0x4fb2 <DIO_enuStatePullup+0x13e>
    4fba:	84 2b       	or	r24, r20
    4fbc:	8c 93       	st	X, r24
    4fbe:	59 c0       	rjmp	.+178    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else if( u8PinNumCpy >= 8  && u8PinNumCpy <= 15 )
    4fc0:	8a 81       	ldd	r24, Y+2	; 0x02
    4fc2:	88 30       	cpi	r24, 0x08	; 8
    4fc4:	d0 f0       	brcs	.+52     	; 0x4ffa <DIO_enuStatePullup+0x186>
    4fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    4fc8:	80 31       	cpi	r24, 0x10	; 16
    4fca:	b8 f4       	brcc	.+46     	; 0x4ffa <DIO_enuStatePullup+0x186>
			{
				SET_BIT(PORTB, (u8PinNumCpy%8));
    4fcc:	a8 e3       	ldi	r26, 0x38	; 56
    4fce:	b0 e0       	ldi	r27, 0x00	; 0
    4fd0:	e8 e3       	ldi	r30, 0x38	; 56
    4fd2:	f0 e0       	ldi	r31, 0x00	; 0
    4fd4:	80 81       	ld	r24, Z
    4fd6:	48 2f       	mov	r20, r24
    4fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4fda:	88 2f       	mov	r24, r24
    4fdc:	90 e0       	ldi	r25, 0x00	; 0
    4fde:	9c 01       	movw	r18, r24
    4fe0:	27 70       	andi	r18, 0x07	; 7
    4fe2:	30 70       	andi	r19, 0x00	; 0
    4fe4:	81 e0       	ldi	r24, 0x01	; 1
    4fe6:	90 e0       	ldi	r25, 0x00	; 0
    4fe8:	02 2e       	mov	r0, r18
    4fea:	02 c0       	rjmp	.+4      	; 0x4ff0 <DIO_enuStatePullup+0x17c>
    4fec:	88 0f       	add	r24, r24
    4fee:	99 1f       	adc	r25, r25
    4ff0:	0a 94       	dec	r0
    4ff2:	e2 f7       	brpl	.-8      	; 0x4fec <DIO_enuStatePullup+0x178>
    4ff4:	84 2b       	or	r24, r20
    4ff6:	8c 93       	st	X, r24
    4ff8:	3c c0       	rjmp	.+120    	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else if( u8PinNumCpy >= 16  && u8PinNumCpy <= 23 )
    4ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    4ffc:	80 31       	cpi	r24, 0x10	; 16
    4ffe:	d0 f0       	brcs	.+52     	; 0x5034 <DIO_enuStatePullup+0x1c0>
    5000:	8a 81       	ldd	r24, Y+2	; 0x02
    5002:	88 31       	cpi	r24, 0x18	; 24
    5004:	b8 f4       	brcc	.+46     	; 0x5034 <DIO_enuStatePullup+0x1c0>
			{
				SET_BIT(PORTC, (u8PinNumCpy%8));
    5006:	a5 e3       	ldi	r26, 0x35	; 53
    5008:	b0 e0       	ldi	r27, 0x00	; 0
    500a:	e5 e3       	ldi	r30, 0x35	; 53
    500c:	f0 e0       	ldi	r31, 0x00	; 0
    500e:	80 81       	ld	r24, Z
    5010:	48 2f       	mov	r20, r24
    5012:	8a 81       	ldd	r24, Y+2	; 0x02
    5014:	88 2f       	mov	r24, r24
    5016:	90 e0       	ldi	r25, 0x00	; 0
    5018:	9c 01       	movw	r18, r24
    501a:	27 70       	andi	r18, 0x07	; 7
    501c:	30 70       	andi	r19, 0x00	; 0
    501e:	81 e0       	ldi	r24, 0x01	; 1
    5020:	90 e0       	ldi	r25, 0x00	; 0
    5022:	02 2e       	mov	r0, r18
    5024:	02 c0       	rjmp	.+4      	; 0x502a <DIO_enuStatePullup+0x1b6>
    5026:	88 0f       	add	r24, r24
    5028:	99 1f       	adc	r25, r25
    502a:	0a 94       	dec	r0
    502c:	e2 f7       	brpl	.-8      	; 0x5026 <DIO_enuStatePullup+0x1b2>
    502e:	84 2b       	or	r24, r20
    5030:	8c 93       	st	X, r24
    5032:	1f c0       	rjmp	.+62     	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else if( u8PinNumCpy >= 24  && u8PinNumCpy <= 31 )
    5034:	8a 81       	ldd	r24, Y+2	; 0x02
    5036:	88 31       	cpi	r24, 0x18	; 24
    5038:	d0 f0       	brcs	.+52     	; 0x506e <DIO_enuStatePullup+0x1fa>
    503a:	8a 81       	ldd	r24, Y+2	; 0x02
    503c:	80 32       	cpi	r24, 0x20	; 32
    503e:	b8 f4       	brcc	.+46     	; 0x506e <DIO_enuStatePullup+0x1fa>
			{
				SET_BIT(PORTD, (u8PinNumCpy%8));
    5040:	a2 e3       	ldi	r26, 0x32	; 50
    5042:	b0 e0       	ldi	r27, 0x00	; 0
    5044:	e2 e3       	ldi	r30, 0x32	; 50
    5046:	f0 e0       	ldi	r31, 0x00	; 0
    5048:	80 81       	ld	r24, Z
    504a:	48 2f       	mov	r20, r24
    504c:	8a 81       	ldd	r24, Y+2	; 0x02
    504e:	88 2f       	mov	r24, r24
    5050:	90 e0       	ldi	r25, 0x00	; 0
    5052:	9c 01       	movw	r18, r24
    5054:	27 70       	andi	r18, 0x07	; 7
    5056:	30 70       	andi	r19, 0x00	; 0
    5058:	81 e0       	ldi	r24, 0x01	; 1
    505a:	90 e0       	ldi	r25, 0x00	; 0
    505c:	02 2e       	mov	r0, r18
    505e:	02 c0       	rjmp	.+4      	; 0x5064 <DIO_enuStatePullup+0x1f0>
    5060:	88 0f       	add	r24, r24
    5062:	99 1f       	adc	r25, r25
    5064:	0a 94       	dec	r0
    5066:	e2 f7       	brpl	.-8      	; 0x5060 <DIO_enuStatePullup+0x1ec>
    5068:	84 2b       	or	r24, r20
    506a:	8c 93       	st	X, r24
    506c:	02 c0       	rjmp	.+4      	; 0x5072 <DIO_enuStatePullup+0x1fe>
			}
			else
			{
				retunState = PARAMRETER_OUT_RANGE;
    506e:	82 e0       	ldi	r24, 0x02	; 2
    5070:	89 83       	std	Y+1, r24	; 0x01
			break;
		default:
			//do nothing
			break;
		}
		return retunState;
    5072:	89 81       	ldd	r24, Y+1	; 0x01
}
    5074:	0f 90       	pop	r0
    5076:	0f 90       	pop	r0
    5078:	0f 90       	pop	r0
    507a:	0f 90       	pop	r0
    507c:	0f 90       	pop	r0
    507e:	cf 91       	pop	r28
    5080:	df 91       	pop	r29
    5082:	08 95       	ret

00005084 <DIO_enuWriteGroup>:

tenuErrorStatus DIO_enuWriteGroup(uint8* pau8PinNumCpy , uint8* pau8PinValueCpy,uint8 u8Sizecpy)
{
    5084:	df 93       	push	r29
    5086:	cf 93       	push	r28
    5088:	cd b7       	in	r28, 0x3d	; 61
    508a:	de b7       	in	r29, 0x3e	; 62
    508c:	27 97       	sbiw	r28, 0x07	; 7
    508e:	0f b6       	in	r0, 0x3f	; 63
    5090:	f8 94       	cli
    5092:	de bf       	out	0x3e, r29	; 62
    5094:	0f be       	out	0x3f, r0	; 63
    5096:	cd bf       	out	0x3d, r28	; 61
    5098:	9c 83       	std	Y+4, r25	; 0x04
    509a:	8b 83       	std	Y+3, r24	; 0x03
    509c:	7e 83       	std	Y+6, r23	; 0x06
    509e:	6d 83       	std	Y+5, r22	; 0x05
    50a0:	4f 83       	std	Y+7, r20	; 0x07
	tenuErrorStatus returnState = EOK;
    50a2:	1a 82       	std	Y+2, r1	; 0x02
	for(uint8 i =0; i < u8Sizecpy ; i++)
    50a4:	19 82       	std	Y+1, r1	; 0x01
    50a6:	1a c0       	rjmp	.+52     	; 0x50dc <DIO_enuWriteGroup+0x58>
	{
		returnState = DIO_enuWritePin(pau8PinNumCpy[i],pau8PinValueCpy[i]);
    50a8:	89 81       	ldd	r24, Y+1	; 0x01
    50aa:	28 2f       	mov	r18, r24
    50ac:	30 e0       	ldi	r19, 0x00	; 0
    50ae:	8b 81       	ldd	r24, Y+3	; 0x03
    50b0:	9c 81       	ldd	r25, Y+4	; 0x04
    50b2:	fc 01       	movw	r30, r24
    50b4:	e2 0f       	add	r30, r18
    50b6:	f3 1f       	adc	r31, r19
    50b8:	40 81       	ld	r20, Z
    50ba:	89 81       	ldd	r24, Y+1	; 0x01
    50bc:	28 2f       	mov	r18, r24
    50be:	30 e0       	ldi	r19, 0x00	; 0
    50c0:	8d 81       	ldd	r24, Y+5	; 0x05
    50c2:	9e 81       	ldd	r25, Y+6	; 0x06
    50c4:	fc 01       	movw	r30, r24
    50c6:	e2 0f       	add	r30, r18
    50c8:	f3 1f       	adc	r31, r19
    50ca:	90 81       	ld	r25, Z
    50cc:	84 2f       	mov	r24, r20
    50ce:	69 2f       	mov	r22, r25
    50d0:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
    50d4:	8a 83       	std	Y+2, r24	; 0x02
}

tenuErrorStatus DIO_enuWriteGroup(uint8* pau8PinNumCpy , uint8* pau8PinValueCpy,uint8 u8Sizecpy)
{
	tenuErrorStatus returnState = EOK;
	for(uint8 i =0; i < u8Sizecpy ; i++)
    50d6:	89 81       	ldd	r24, Y+1	; 0x01
    50d8:	8f 5f       	subi	r24, 0xFF	; 255
    50da:	89 83       	std	Y+1, r24	; 0x01
    50dc:	99 81       	ldd	r25, Y+1	; 0x01
    50de:	8f 81       	ldd	r24, Y+7	; 0x07
    50e0:	98 17       	cp	r25, r24
    50e2:	10 f3       	brcs	.-60     	; 0x50a8 <DIO_enuWriteGroup+0x24>
	{
		returnState = DIO_enuWritePin(pau8PinNumCpy[i],pau8PinValueCpy[i]);
	}
	return returnState;
    50e4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    50e6:	27 96       	adiw	r28, 0x07	; 7
    50e8:	0f b6       	in	r0, 0x3f	; 63
    50ea:	f8 94       	cli
    50ec:	de bf       	out	0x3e, r29	; 62
    50ee:	0f be       	out	0x3f, r0	; 63
    50f0:	cd bf       	out	0x3d, r28	; 61
    50f2:	cf 91       	pop	r28
    50f4:	df 91       	pop	r29
    50f6:	08 95       	ret

000050f8 <DIO_enuWritePort>:

tenuErrorStatus DIO_enuWritePort(uint8 u8PortCpy , uint8 u8PortValueCpy)
{
    50f8:	df 93       	push	r29
    50fa:	cf 93       	push	r28
    50fc:	00 d0       	rcall	.+0      	; 0x50fe <DIO_enuWritePort+0x6>
    50fe:	00 d0       	rcall	.+0      	; 0x5100 <DIO_enuWritePort+0x8>
    5100:	0f 92       	push	r0
    5102:	cd b7       	in	r28, 0x3d	; 61
    5104:	de b7       	in	r29, 0x3e	; 62
    5106:	8a 83       	std	Y+2, r24	; 0x02
    5108:	6b 83       	std	Y+3, r22	; 0x03
	tenuErrorStatus retunState=EOK;
    510a:	19 82       	std	Y+1, r1	; 0x01
		switch(u8PortCpy)
    510c:	8a 81       	ldd	r24, Y+2	; 0x02
    510e:	28 2f       	mov	r18, r24
    5110:	30 e0       	ldi	r19, 0x00	; 0
    5112:	3d 83       	std	Y+5, r19	; 0x05
    5114:	2c 83       	std	Y+4, r18	; 0x04
    5116:	8c 81       	ldd	r24, Y+4	; 0x04
    5118:	9d 81       	ldd	r25, Y+5	; 0x05
    511a:	81 30       	cpi	r24, 0x01	; 1
    511c:	91 05       	cpc	r25, r1
    511e:	d1 f0       	breq	.+52     	; 0x5154 <DIO_enuWritePort+0x5c>
    5120:	2c 81       	ldd	r18, Y+4	; 0x04
    5122:	3d 81       	ldd	r19, Y+5	; 0x05
    5124:	22 30       	cpi	r18, 0x02	; 2
    5126:	31 05       	cpc	r19, r1
    5128:	2c f4       	brge	.+10     	; 0x5134 <DIO_enuWritePort+0x3c>
    512a:	8c 81       	ldd	r24, Y+4	; 0x04
    512c:	9d 81       	ldd	r25, Y+5	; 0x05
    512e:	00 97       	sbiw	r24, 0x00	; 0
    5130:	61 f0       	breq	.+24     	; 0x514a <DIO_enuWritePort+0x52>
    5132:	1f c0       	rjmp	.+62     	; 0x5172 <DIO_enuWritePort+0x7a>
    5134:	2c 81       	ldd	r18, Y+4	; 0x04
    5136:	3d 81       	ldd	r19, Y+5	; 0x05
    5138:	22 30       	cpi	r18, 0x02	; 2
    513a:	31 05       	cpc	r19, r1
    513c:	81 f0       	breq	.+32     	; 0x515e <DIO_enuWritePort+0x66>
    513e:	8c 81       	ldd	r24, Y+4	; 0x04
    5140:	9d 81       	ldd	r25, Y+5	; 0x05
    5142:	83 30       	cpi	r24, 0x03	; 3
    5144:	91 05       	cpc	r25, r1
    5146:	81 f0       	breq	.+32     	; 0x5168 <DIO_enuWritePort+0x70>
    5148:	14 c0       	rjmp	.+40     	; 0x5172 <DIO_enuWritePort+0x7a>
		{
		case GPIOA:
			PORTA = u8PortValueCpy;
    514a:	eb e3       	ldi	r30, 0x3B	; 59
    514c:	f0 e0       	ldi	r31, 0x00	; 0
    514e:	8b 81       	ldd	r24, Y+3	; 0x03
    5150:	80 83       	st	Z, r24
    5152:	11 c0       	rjmp	.+34     	; 0x5176 <DIO_enuWritePort+0x7e>
			break;

		case GPIOB:
			PORTB = u8PortValueCpy;
    5154:	e8 e3       	ldi	r30, 0x38	; 56
    5156:	f0 e0       	ldi	r31, 0x00	; 0
    5158:	8b 81       	ldd	r24, Y+3	; 0x03
    515a:	80 83       	st	Z, r24
    515c:	0c c0       	rjmp	.+24     	; 0x5176 <DIO_enuWritePort+0x7e>
			break;
		case GPIOC:
			PORTC = u8PortValueCpy;
    515e:	e5 e3       	ldi	r30, 0x35	; 53
    5160:	f0 e0       	ldi	r31, 0x00	; 0
    5162:	8b 81       	ldd	r24, Y+3	; 0x03
    5164:	80 83       	st	Z, r24
    5166:	07 c0       	rjmp	.+14     	; 0x5176 <DIO_enuWritePort+0x7e>
			break;

		case GPIOD:
			PORTD = u8PortValueCpy;
    5168:	e2 e3       	ldi	r30, 0x32	; 50
    516a:	f0 e0       	ldi	r31, 0x00	; 0
    516c:	8b 81       	ldd	r24, Y+3	; 0x03
    516e:	80 83       	st	Z, r24
    5170:	02 c0       	rjmp	.+4      	; 0x5176 <DIO_enuWritePort+0x7e>
			break;
		default:
			retunState = PARAMRETER_OUT_RANGE;
    5172:	82 e0       	ldi	r24, 0x02	; 2
    5174:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
		return retunState;
    5176:	89 81       	ldd	r24, Y+1	; 0x01
}
    5178:	0f 90       	pop	r0
    517a:	0f 90       	pop	r0
    517c:	0f 90       	pop	r0
    517e:	0f 90       	pop	r0
    5180:	0f 90       	pop	r0
    5182:	cf 91       	pop	r28
    5184:	df 91       	pop	r29
    5186:	08 95       	ret

00005188 <ADC_voidInit>:
pf ADCINT_pfCall= NULL;
uint16 ADC_uint16ReadVal;

/* inilize the mode single or free rrunning , mbit or 10 bit and prescaler and Vref */
void ADC_voidInit(void)
{
    5188:	df 93       	push	r29
    518a:	cf 93       	push	r28
    518c:	cd b7       	in	r28, 0x3d	; 61
    518e:	de b7       	in	r29, 0x3e	; 62
		SET_BIT(SFIOR,ADTS1);
		SET_BIT(SFIOR,ADTS2);
#endif
	}
#elif	Operation_MODE == Single_MODE
	CLR_BIT(ADCSRA,ADATE);
    5190:	a6 e2       	ldi	r26, 0x26	; 38
    5192:	b0 e0       	ldi	r27, 0x00	; 0
    5194:	e6 e2       	ldi	r30, 0x26	; 38
    5196:	f0 e0       	ldi	r31, 0x00	; 0
    5198:	80 81       	ld	r24, Z
    519a:	8f 7d       	andi	r24, 0xDF	; 223
    519c:	8c 93       	st	X, r24


#if	BITS_MODE == BITS_8
	SET_BIT(ADMUX,ADLAR);
#elif	BITS_MODE == BITS_10
	CLR_BIT(ADMUX,ADLAR);
    519e:	a7 e2       	ldi	r26, 0x27	; 39
    51a0:	b0 e0       	ldi	r27, 0x00	; 0
    51a2:	e7 e2       	ldi	r30, 0x27	; 39
    51a4:	f0 e0       	ldi	r31, 0x00	; 0
    51a6:	80 81       	ld	r24, Z
    51a8:	8f 7d       	andi	r24, 0xDF	; 223
    51aa:	8c 93       	st	X, r24
#endif

#if	VOLTAGE_REF == AREF
	CLR_BIT(ADMUX,REFS0);
    51ac:	a7 e2       	ldi	r26, 0x27	; 39
    51ae:	b0 e0       	ldi	r27, 0x00	; 0
    51b0:	e7 e2       	ldi	r30, 0x27	; 39
    51b2:	f0 e0       	ldi	r31, 0x00	; 0
    51b4:	80 81       	ld	r24, Z
    51b6:	8f 7b       	andi	r24, 0xBF	; 191
    51b8:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,REFS1);
    51ba:	a7 e2       	ldi	r26, 0x27	; 39
    51bc:	b0 e0       	ldi	r27, 0x00	; 0
    51be:	e7 e2       	ldi	r30, 0x27	; 39
    51c0:	f0 e0       	ldi	r31, 0x00	; 0
    51c2:	80 81       	ld	r24, Z
    51c4:	8f 77       	andi	r24, 0x7F	; 127
    51c6:	8c 93       	st	X, r24
#elif	prescaler == prescaler_8
	SET_BIT(ADCSRA,ADPS0);
	SET_BIT(ADCSRA,ADPS1);
	CLR_BIT(ADCSRA,ADPS2);
#elif	prescaler == prescaler_16
	CLR_BIT(ADCSRA,ADPS0);
    51c8:	a6 e2       	ldi	r26, 0x26	; 38
    51ca:	b0 e0       	ldi	r27, 0x00	; 0
    51cc:	e6 e2       	ldi	r30, 0x26	; 38
    51ce:	f0 e0       	ldi	r31, 0x00	; 0
    51d0:	80 81       	ld	r24, Z
    51d2:	8e 7f       	andi	r24, 0xFE	; 254
    51d4:	8c 93       	st	X, r24
	CLR_BIT(ADCSRA,ADPS1);
    51d6:	a6 e2       	ldi	r26, 0x26	; 38
    51d8:	b0 e0       	ldi	r27, 0x00	; 0
    51da:	e6 e2       	ldi	r30, 0x26	; 38
    51dc:	f0 e0       	ldi	r31, 0x00	; 0
    51de:	80 81       	ld	r24, Z
    51e0:	8d 7f       	andi	r24, 0xFD	; 253
    51e2:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADPS2);
    51e4:	a6 e2       	ldi	r26, 0x26	; 38
    51e6:	b0 e0       	ldi	r27, 0x00	; 0
    51e8:	e6 e2       	ldi	r30, 0x26	; 38
    51ea:	f0 e0       	ldi	r31, 0x00	; 0
    51ec:	80 81       	ld	r24, Z
    51ee:	84 60       	ori	r24, 0x04	; 4
    51f0:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADPS0);
	SET_BIT(ADCSRA,ADPS1);
	SET_BIT(ADCSRA,ADPS2);
#endif

}
    51f2:	cf 91       	pop	r28
    51f4:	df 91       	pop	r29
    51f6:	08 95       	ret

000051f8 <ADC_voidEnable>:

void ADC_voidEnable(void)
{
    51f8:	df 93       	push	r29
    51fa:	cf 93       	push	r28
    51fc:	cd b7       	in	r28, 0x3d	; 61
    51fe:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,ADEN);
    5200:	a6 e2       	ldi	r26, 0x26	; 38
    5202:	b0 e0       	ldi	r27, 0x00	; 0
    5204:	e6 e2       	ldi	r30, 0x26	; 38
    5206:	f0 e0       	ldi	r31, 0x00	; 0
    5208:	80 81       	ld	r24, Z
    520a:	80 68       	ori	r24, 0x80	; 128
    520c:	8c 93       	st	X, r24
}
    520e:	cf 91       	pop	r28
    5210:	df 91       	pop	r29
    5212:	08 95       	ret

00005214 <ADC_voidDisable>:

void ADC_voidDisable(void)
{
    5214:	df 93       	push	r29
    5216:	cf 93       	push	r28
    5218:	cd b7       	in	r28, 0x3d	; 61
    521a:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(ADCSRA,ADEN);
    521c:	a6 e2       	ldi	r26, 0x26	; 38
    521e:	b0 e0       	ldi	r27, 0x00	; 0
    5220:	e6 e2       	ldi	r30, 0x26	; 38
    5222:	f0 e0       	ldi	r31, 0x00	; 0
    5224:	80 81       	ld	r24, Z
    5226:	8f 77       	andi	r24, 0x7F	; 127
    5228:	8c 93       	st	X, r24
}
    522a:	cf 91       	pop	r28
    522c:	df 91       	pop	r29
    522e:	08 95       	ret

00005230 <ADC_voidEnableInterrupt>:

void ADC_voidEnableInterrupt(void)
{
    5230:	df 93       	push	r29
    5232:	cf 93       	push	r28
    5234:	cd b7       	in	r28, 0x3d	; 61
    5236:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(ADCSRA,ADIE);
    5238:	a6 e2       	ldi	r26, 0x26	; 38
    523a:	b0 e0       	ldi	r27, 0x00	; 0
    523c:	e6 e2       	ldi	r30, 0x26	; 38
    523e:	f0 e0       	ldi	r31, 0x00	; 0
    5240:	80 81       	ld	r24, Z
    5242:	88 60       	ori	r24, 0x08	; 8
    5244:	8c 93       	st	X, r24
}
    5246:	cf 91       	pop	r28
    5248:	df 91       	pop	r29
    524a:	08 95       	ret

0000524c <ADC_voidDisableInterrupt>:

void ADC_voidDisableInterrupt(void)
{
    524c:	df 93       	push	r29
    524e:	cf 93       	push	r28
    5250:	cd b7       	in	r28, 0x3d	; 61
    5252:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(ADCSRA,ADIE);
    5254:	a6 e2       	ldi	r26, 0x26	; 38
    5256:	b0 e0       	ldi	r27, 0x00	; 0
    5258:	e6 e2       	ldi	r30, 0x26	; 38
    525a:	f0 e0       	ldi	r31, 0x00	; 0
    525c:	80 81       	ld	r24, Z
    525e:	87 7f       	andi	r24, 0xF7	; 247
    5260:	8c 93       	st	X, r24
}
    5262:	cf 91       	pop	r28
    5264:	df 91       	pop	r29
    5266:	08 95       	ret

00005268 <ADC_voidSetCallback>:

void ADC_voidSetCallback(pf pfCallbackCpy)
{
    5268:	df 93       	push	r29
    526a:	cf 93       	push	r28
    526c:	00 d0       	rcall	.+0      	; 0x526e <ADC_voidSetCallback+0x6>
    526e:	cd b7       	in	r28, 0x3d	; 61
    5270:	de b7       	in	r29, 0x3e	; 62
    5272:	9a 83       	std	Y+2, r25	; 0x02
    5274:	89 83       	std	Y+1, r24	; 0x01
	ADCINT_pfCall = pfCallbackCpy;
    5276:	89 81       	ldd	r24, Y+1	; 0x01
    5278:	9a 81       	ldd	r25, Y+2	; 0x02
    527a:	90 93 9b 06 	sts	0x069B, r25
    527e:	80 93 9a 06 	sts	0x069A, r24
}
    5282:	0f 90       	pop	r0
    5284:	0f 90       	pop	r0
    5286:	cf 91       	pop	r28
    5288:	df 91       	pop	r29
    528a:	08 95       	ret

0000528c <ADC_voidStartConversion>:

void ADC_voidStartConversion(uint8 u8ChannelNbCpy)
{
    528c:	df 93       	push	r29
    528e:	cf 93       	push	r28
    5290:	00 d0       	rcall	.+0      	; 0x5292 <ADC_voidStartConversion+0x6>
    5292:	cd b7       	in	r28, 0x3d	; 61
    5294:	de b7       	in	r29, 0x3e	; 62
    5296:	8a 83       	std	Y+2, r24	; 0x02
	uint8 ADC_Channel=0x1F;
    5298:	8f e1       	ldi	r24, 0x1F	; 31
    529a:	89 83       	std	Y+1, r24	; 0x01
	ADC_Channel &= u8ChannelNbCpy;
    529c:	99 81       	ldd	r25, Y+1	; 0x01
    529e:	8a 81       	ldd	r24, Y+2	; 0x02
    52a0:	89 23       	and	r24, r25
    52a2:	89 83       	std	Y+1, r24	; 0x01
	ADMUX &=0xE0 ;
    52a4:	a7 e2       	ldi	r26, 0x27	; 39
    52a6:	b0 e0       	ldi	r27, 0x00	; 0
    52a8:	e7 e2       	ldi	r30, 0x27	; 39
    52aa:	f0 e0       	ldi	r31, 0x00	; 0
    52ac:	80 81       	ld	r24, Z
    52ae:	80 7e       	andi	r24, 0xE0	; 224
    52b0:	8c 93       	st	X, r24
	ADMUX |=u8ChannelNbCpy;
    52b2:	a7 e2       	ldi	r26, 0x27	; 39
    52b4:	b0 e0       	ldi	r27, 0x00	; 0
    52b6:	e7 e2       	ldi	r30, 0x27	; 39
    52b8:	f0 e0       	ldi	r31, 0x00	; 0
    52ba:	90 81       	ld	r25, Z
    52bc:	8a 81       	ldd	r24, Y+2	; 0x02
    52be:	89 2b       	or	r24, r25
    52c0:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADSC);
    52c2:	a6 e2       	ldi	r26, 0x26	; 38
    52c4:	b0 e0       	ldi	r27, 0x00	; 0
    52c6:	e6 e2       	ldi	r30, 0x26	; 38
    52c8:	f0 e0       	ldi	r31, 0x00	; 0
    52ca:	80 81       	ld	r24, Z
    52cc:	80 64       	ori	r24, 0x40	; 64
    52ce:	8c 93       	st	X, r24
}
    52d0:	0f 90       	pop	r0
    52d2:	0f 90       	pop	r0
    52d4:	cf 91       	pop	r28
    52d6:	df 91       	pop	r29
    52d8:	08 95       	ret

000052da <ADC_voidChangeMode>:

void ADC_voidChangeMode(uint8 u8ModeCpy)
{
    52da:	df 93       	push	r29
    52dc:	cf 93       	push	r28
    52de:	00 d0       	rcall	.+0      	; 0x52e0 <ADC_voidChangeMode+0x6>
    52e0:	0f 92       	push	r0
    52e2:	cd b7       	in	r28, 0x3d	; 61
    52e4:	de b7       	in	r29, 0x3e	; 62
    52e6:	89 83       	std	Y+1, r24	; 0x01
	switch(u8ModeCpy)
    52e8:	89 81       	ldd	r24, Y+1	; 0x01
    52ea:	28 2f       	mov	r18, r24
    52ec:	30 e0       	ldi	r19, 0x00	; 0
    52ee:	3b 83       	std	Y+3, r19	; 0x03
    52f0:	2a 83       	std	Y+2, r18	; 0x02
    52f2:	8a 81       	ldd	r24, Y+2	; 0x02
    52f4:	9b 81       	ldd	r25, Y+3	; 0x03
    52f6:	00 97       	sbiw	r24, 0x00	; 0
    52f8:	69 f0       	breq	.+26     	; 0x5314 <ADC_voidChangeMode+0x3a>
    52fa:	2a 81       	ldd	r18, Y+2	; 0x02
    52fc:	3b 81       	ldd	r19, Y+3	; 0x03
    52fe:	21 30       	cpi	r18, 0x01	; 1
    5300:	31 05       	cpc	r19, r1
    5302:	79 f4       	brne	.+30     	; 0x5322 <ADC_voidChangeMode+0x48>
	{
	case Single_MODE :
		CLR_BIT(ADCSRA,ADATE);
    5304:	a6 e2       	ldi	r26, 0x26	; 38
    5306:	b0 e0       	ldi	r27, 0x00	; 0
    5308:	e6 e2       	ldi	r30, 0x26	; 38
    530a:	f0 e0       	ldi	r31, 0x00	; 0
    530c:	80 81       	ld	r24, Z
    530e:	8f 7d       	andi	r24, 0xDF	; 223
    5310:	8c 93       	st	X, r24
    5312:	07 c0       	rjmp	.+14     	; 0x5322 <ADC_voidChangeMode+0x48>
		break;
	case AUTO_TRIGGER :
		SET_BIT(ADCSRA,ADATE);
    5314:	a6 e2       	ldi	r26, 0x26	; 38
    5316:	b0 e0       	ldi	r27, 0x00	; 0
    5318:	e6 e2       	ldi	r30, 0x26	; 38
    531a:	f0 e0       	ldi	r31, 0x00	; 0
    531c:	80 81       	ld	r24, Z
    531e:	80 62       	ori	r24, 0x20	; 32
    5320:	8c 93       	st	X, r24
		break;
	}
}
    5322:	0f 90       	pop	r0
    5324:	0f 90       	pop	r0
    5326:	0f 90       	pop	r0
    5328:	cf 91       	pop	r28
    532a:	df 91       	pop	r29
    532c:	08 95       	ret

0000532e <ADC_u16ReadSync>:

/* read the vlaue from ADC polling method*/
uint16 ADC_u16ReadSync(uint8 u8ChannelNbCpy)
{
    532e:	df 93       	push	r29
    5330:	cf 93       	push	r28
    5332:	00 d0       	rcall	.+0      	; 0x5334 <ADC_u16ReadSync+0x6>
    5334:	0f 92       	push	r0
    5336:	cd b7       	in	r28, 0x3d	; 61
    5338:	de b7       	in	r29, 0x3e	; 62
    533a:	8b 83       	std	Y+3, r24	; 0x03
	uint16 loc_ADCW;
	ADC_voidStartConversion(u8ChannelNbCpy);
    533c:	8b 81       	ldd	r24, Y+3	; 0x03
    533e:	0e 94 46 29 	call	0x528c	; 0x528c <ADC_voidStartConversion>
	while(!GET_BIT(ADCSRA,ADIF));
    5342:	e6 e2       	ldi	r30, 0x26	; 38
    5344:	f0 e0       	ldi	r31, 0x00	; 0
    5346:	80 81       	ld	r24, Z
    5348:	82 95       	swap	r24
    534a:	8f 70       	andi	r24, 0x0F	; 15
    534c:	88 2f       	mov	r24, r24
    534e:	90 e0       	ldi	r25, 0x00	; 0
    5350:	81 70       	andi	r24, 0x01	; 1
    5352:	90 70       	andi	r25, 0x00	; 0
    5354:	00 97       	sbiw	r24, 0x00	; 0
    5356:	a9 f3       	breq	.-22     	; 0x5342 <ADC_u16ReadSync+0x14>
	SET_BIT(ADCSRA,ADIF);
    5358:	a6 e2       	ldi	r26, 0x26	; 38
    535a:	b0 e0       	ldi	r27, 0x00	; 0
    535c:	e6 e2       	ldi	r30, 0x26	; 38
    535e:	f0 e0       	ldi	r31, 0x00	; 0
    5360:	80 81       	ld	r24, Z
    5362:	80 61       	ori	r24, 0x10	; 16
    5364:	8c 93       	st	X, r24
#if BITS_MODE == BITS_8
	loc_ADCW = ADCH;
#elif BITS_MODE == BITS_10
	loc_ADCW  = ADCL;
    5366:	e4 e2       	ldi	r30, 0x24	; 36
    5368:	f0 e0       	ldi	r31, 0x00	; 0
    536a:	80 81       	ld	r24, Z
    536c:	88 2f       	mov	r24, r24
    536e:	90 e0       	ldi	r25, 0x00	; 0
    5370:	9a 83       	std	Y+2, r25	; 0x02
    5372:	89 83       	std	Y+1, r24	; 0x01
	loc_ADCW |= (ADCH<<8);
    5374:	e5 e2       	ldi	r30, 0x25	; 37
    5376:	f0 e0       	ldi	r31, 0x00	; 0
    5378:	80 81       	ld	r24, Z
    537a:	88 2f       	mov	r24, r24
    537c:	90 e0       	ldi	r25, 0x00	; 0
    537e:	98 2f       	mov	r25, r24
    5380:	88 27       	eor	r24, r24
    5382:	9c 01       	movw	r18, r24
    5384:	89 81       	ldd	r24, Y+1	; 0x01
    5386:	9a 81       	ldd	r25, Y+2	; 0x02
    5388:	82 2b       	or	r24, r18
    538a:	93 2b       	or	r25, r19
    538c:	9a 83       	std	Y+2, r25	; 0x02
    538e:	89 83       	std	Y+1, r24	; 0x01
#endif
	return loc_ADCW;
    5390:	89 81       	ldd	r24, Y+1	; 0x01
    5392:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5394:	0f 90       	pop	r0
    5396:	0f 90       	pop	r0
    5398:	0f 90       	pop	r0
    539a:	cf 91       	pop	r28
    539c:	df 91       	pop	r29
    539e:	08 95       	ret

000053a0 <ADC_u16ReadAsync>:
/* read the vlaue from ADC Interrupt method*/
uint16 ADC_u16ReadAsync(void)
{
    53a0:	df 93       	push	r29
    53a2:	cf 93       	push	r28
    53a4:	cd b7       	in	r28, 0x3d	; 61
    53a6:	de b7       	in	r29, 0x3e	; 62
	return ADC_uint16ReadVal;
    53a8:	80 91 a8 06 	lds	r24, 0x06A8
    53ac:	90 91 a9 06 	lds	r25, 0x06A9
}
    53b0:	cf 91       	pop	r28
    53b2:	df 91       	pop	r29
    53b4:	08 95       	ret

000053b6 <__vector_16>:


void __vector_16(void)   __attribute__ ((signal,used)); // for optimize

void __vector_16(void)
{
    53b6:	1f 92       	push	r1
    53b8:	0f 92       	push	r0
    53ba:	0f b6       	in	r0, 0x3f	; 63
    53bc:	0f 92       	push	r0
    53be:	11 24       	eor	r1, r1
    53c0:	2f 93       	push	r18
    53c2:	3f 93       	push	r19
    53c4:	4f 93       	push	r20
    53c6:	5f 93       	push	r21
    53c8:	6f 93       	push	r22
    53ca:	7f 93       	push	r23
    53cc:	8f 93       	push	r24
    53ce:	9f 93       	push	r25
    53d0:	af 93       	push	r26
    53d2:	bf 93       	push	r27
    53d4:	ef 93       	push	r30
    53d6:	ff 93       	push	r31
    53d8:	df 93       	push	r29
    53da:	cf 93       	push	r28
    53dc:	cd b7       	in	r28, 0x3d	; 61
    53de:	de b7       	in	r29, 0x3e	; 62
	if(ADCINT_pfCall != NULL)
    53e0:	80 91 9a 06 	lds	r24, 0x069A
    53e4:	90 91 9b 06 	lds	r25, 0x069B
    53e8:	00 97       	sbiw	r24, 0x00	; 0
    53ea:	29 f0       	breq	.+10     	; 0x53f6 <__vector_16+0x40>
	{
		ADCINT_pfCall();
    53ec:	e0 91 9a 06 	lds	r30, 0x069A
    53f0:	f0 91 9b 06 	lds	r31, 0x069B
    53f4:	09 95       	icall
	}
#if BITS_MODE == BITS_8
	ADC_uint16ReadVal = ADCH;
#elif BITS_MODE == BITS_10
	ADC_uint16ReadVal  = ADCL;
    53f6:	e4 e2       	ldi	r30, 0x24	; 36
    53f8:	f0 e0       	ldi	r31, 0x00	; 0
    53fa:	80 81       	ld	r24, Z
    53fc:	88 2f       	mov	r24, r24
    53fe:	90 e0       	ldi	r25, 0x00	; 0
    5400:	90 93 a9 06 	sts	0x06A9, r25
    5404:	80 93 a8 06 	sts	0x06A8, r24
	ADC_uint16ReadVal |= (ADCH<<8);
    5408:	e5 e2       	ldi	r30, 0x25	; 37
    540a:	f0 e0       	ldi	r31, 0x00	; 0
    540c:	80 81       	ld	r24, Z
    540e:	88 2f       	mov	r24, r24
    5410:	90 e0       	ldi	r25, 0x00	; 0
    5412:	98 2f       	mov	r25, r24
    5414:	88 27       	eor	r24, r24
    5416:	9c 01       	movw	r18, r24
    5418:	80 91 a8 06 	lds	r24, 0x06A8
    541c:	90 91 a9 06 	lds	r25, 0x06A9
    5420:	82 2b       	or	r24, r18
    5422:	93 2b       	or	r25, r19
    5424:	90 93 a9 06 	sts	0x06A9, r25
    5428:	80 93 a8 06 	sts	0x06A8, r24

#endif
}
    542c:	cf 91       	pop	r28
    542e:	df 91       	pop	r29
    5430:	ff 91       	pop	r31
    5432:	ef 91       	pop	r30
    5434:	bf 91       	pop	r27
    5436:	af 91       	pop	r26
    5438:	9f 91       	pop	r25
    543a:	8f 91       	pop	r24
    543c:	7f 91       	pop	r23
    543e:	6f 91       	pop	r22
    5440:	5f 91       	pop	r21
    5442:	4f 91       	pop	r20
    5444:	3f 91       	pop	r19
    5446:	2f 91       	pop	r18
    5448:	0f 90       	pop	r0
    544a:	0f be       	out	0x3f, r0	; 63
    544c:	0f 90       	pop	r0
    544e:	1f 90       	pop	r1
    5450:	18 95       	reti

00005452 <LM35_vidinit>:
#include "LM35.h"
#include "LM35_private.h"


void LM35_vidinit()
{
    5452:	df 93       	push	r29
    5454:	cf 93       	push	r28
    5456:	cd b7       	in	r28, 0x3d	; 61
    5458:	de b7       	in	r29, 0x3e	; 62
	ADC_voidInit();
    545a:	0e 94 c4 28 	call	0x5188	; 0x5188 <ADC_voidInit>
	ADC_voidEnable();
    545e:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <ADC_voidEnable>
}
    5462:	cf 91       	pop	r28
    5464:	df 91       	pop	r29
    5466:	08 95       	ret

00005468 <LM35_f32Reading>:
f32 LM35_f32Reading(uint8 u8ChannelCpy)
{
    5468:	df 93       	push	r29
    546a:	cf 93       	push	r28
    546c:	cd b7       	in	r28, 0x3d	; 61
    546e:	de b7       	in	r29, 0x3e	; 62
    5470:	27 97       	sbiw	r28, 0x07	; 7
    5472:	0f b6       	in	r0, 0x3f	; 63
    5474:	f8 94       	cli
    5476:	de bf       	out	0x3e, r29	; 62
    5478:	0f be       	out	0x3f, r0	; 63
    547a:	cd bf       	out	0x3d, r28	; 61
    547c:	8f 83       	std	Y+7, r24	; 0x07
	f32 f32SensorReadingLoc;
	uint16 Local_uint16Val;
	Local_uint16Val = ADC_u16ReadSync(u8ChannelCpy);
    547e:	8f 81       	ldd	r24, Y+7	; 0x07
    5480:	0e 94 97 29 	call	0x532e	; 0x532e <ADC_u16ReadSync>
    5484:	9a 83       	std	Y+2, r25	; 0x02
    5486:	89 83       	std	Y+1, r24	; 0x01
	f32SensorReadingLoc = (((f32)Local_uint16Val*5)/1024)*100;
    5488:	89 81       	ldd	r24, Y+1	; 0x01
    548a:	9a 81       	ldd	r25, Y+2	; 0x02
    548c:	cc 01       	movw	r24, r24
    548e:	a0 e0       	ldi	r26, 0x00	; 0
    5490:	b0 e0       	ldi	r27, 0x00	; 0
    5492:	bc 01       	movw	r22, r24
    5494:	cd 01       	movw	r24, r26
    5496:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    549a:	dc 01       	movw	r26, r24
    549c:	cb 01       	movw	r24, r22
    549e:	bc 01       	movw	r22, r24
    54a0:	cd 01       	movw	r24, r26
    54a2:	20 e0       	ldi	r18, 0x00	; 0
    54a4:	30 e0       	ldi	r19, 0x00	; 0
    54a6:	40 ea       	ldi	r20, 0xA0	; 160
    54a8:	50 e4       	ldi	r21, 0x40	; 64
    54aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54ae:	dc 01       	movw	r26, r24
    54b0:	cb 01       	movw	r24, r22
    54b2:	bc 01       	movw	r22, r24
    54b4:	cd 01       	movw	r24, r26
    54b6:	20 e0       	ldi	r18, 0x00	; 0
    54b8:	30 e0       	ldi	r19, 0x00	; 0
    54ba:	40 e8       	ldi	r20, 0x80	; 128
    54bc:	54 e4       	ldi	r21, 0x44	; 68
    54be:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    54c2:	dc 01       	movw	r26, r24
    54c4:	cb 01       	movw	r24, r22
    54c6:	bc 01       	movw	r22, r24
    54c8:	cd 01       	movw	r24, r26
    54ca:	20 e0       	ldi	r18, 0x00	; 0
    54cc:	30 e0       	ldi	r19, 0x00	; 0
    54ce:	48 ec       	ldi	r20, 0xC8	; 200
    54d0:	52 e4       	ldi	r21, 0x42	; 66
    54d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54d6:	dc 01       	movw	r26, r24
    54d8:	cb 01       	movw	r24, r22
    54da:	8b 83       	std	Y+3, r24	; 0x03
    54dc:	9c 83       	std	Y+4, r25	; 0x04
    54de:	ad 83       	std	Y+5, r26	; 0x05
    54e0:	be 83       	std	Y+6, r27	; 0x06
	return f32SensorReadingLoc;
    54e2:	8b 81       	ldd	r24, Y+3	; 0x03
    54e4:	9c 81       	ldd	r25, Y+4	; 0x04
    54e6:	ad 81       	ldd	r26, Y+5	; 0x05
    54e8:	be 81       	ldd	r27, Y+6	; 0x06
}
    54ea:	bc 01       	movw	r22, r24
    54ec:	cd 01       	movw	r24, r26
    54ee:	27 96       	adiw	r28, 0x07	; 7
    54f0:	0f b6       	in	r0, 0x3f	; 63
    54f2:	f8 94       	cli
    54f4:	de bf       	out	0x3e, r29	; 62
    54f6:	0f be       	out	0x3f, r0	; 63
    54f8:	cd bf       	out	0x3d, r28	; 61
    54fa:	cf 91       	pop	r28
    54fc:	df 91       	pop	r29
    54fe:	08 95       	ret

00005500 <LCD_voidSHD>:

#define  F_CPU 16000000UL 
#include <util/delay.h>


void LCD_voidSHD(uint8  copy_uint8data) {
    5500:	df 93       	push	r29
    5502:	cf 93       	push	r28
    5504:	00 d0       	rcall	.+0      	; 0x5506 <LCD_voidSHD+0x6>
    5506:	00 d0       	rcall	.+0      	; 0x5508 <LCD_voidSHD+0x8>
    5508:	00 d0       	rcall	.+0      	; 0x550a <LCD_voidSHD+0xa>
    550a:	cd b7       	in	r28, 0x3d	; 61
    550c:	de b7       	in	r29, 0x3e	; 62
    550e:	8e 83       	std	Y+6, r24	; 0x06
	
	uint8 LCD_PINS[4]={LCD_D4_PIN,LCD_D5_PIN,LCD_D6_PIN,LCD_D7_PIN} ;
    5510:	84 e0       	ldi	r24, 0x04	; 4
    5512:	8a 83       	std	Y+2, r24	; 0x02
    5514:	85 e0       	ldi	r24, 0x05	; 5
    5516:	8b 83       	std	Y+3, r24	; 0x03
    5518:	86 e0       	ldi	r24, 0x06	; 6
    551a:	8c 83       	std	Y+4, r24	; 0x04
    551c:	87 e0       	ldi	r24, 0x07	; 7
    551e:	8d 83       	std	Y+5, r24	; 0x05
	uint8 LOC_uint8in=0 ;
    5520:	19 82       	std	Y+1, r1	; 0x01
		for(LOC_uint8in=0;LOC_uint8in<4;LOC_uint8in++)
    5522:	19 82       	std	Y+1, r1	; 0x01
    5524:	1f c0       	rjmp	.+62     	; 0x5564 <LCD_voidSHD+0x64>
	    {
			DIO_enuWritePin(LCD_PINS[LOC_uint8in],GET_BIT(copy_uint8data,LOC_uint8in)) ;
    5526:	89 81       	ldd	r24, Y+1	; 0x01
    5528:	28 2f       	mov	r18, r24
    552a:	30 e0       	ldi	r19, 0x00	; 0
    552c:	ce 01       	movw	r24, r28
    552e:	02 96       	adiw	r24, 0x02	; 2
    5530:	fc 01       	movw	r30, r24
    5532:	e2 0f       	add	r30, r18
    5534:	f3 1f       	adc	r31, r19
    5536:	40 81       	ld	r20, Z
    5538:	8e 81       	ldd	r24, Y+6	; 0x06
    553a:	28 2f       	mov	r18, r24
    553c:	30 e0       	ldi	r19, 0x00	; 0
    553e:	89 81       	ldd	r24, Y+1	; 0x01
    5540:	88 2f       	mov	r24, r24
    5542:	90 e0       	ldi	r25, 0x00	; 0
    5544:	b9 01       	movw	r22, r18
    5546:	02 c0       	rjmp	.+4      	; 0x554c <LCD_voidSHD+0x4c>
    5548:	75 95       	asr	r23
    554a:	67 95       	ror	r22
    554c:	8a 95       	dec	r24
    554e:	e2 f7       	brpl	.-8      	; 0x5548 <LCD_voidSHD+0x48>
    5550:	cb 01       	movw	r24, r22
    5552:	98 2f       	mov	r25, r24
    5554:	91 70       	andi	r25, 0x01	; 1
    5556:	84 2f       	mov	r24, r20
    5558:	69 2f       	mov	r22, r25
    555a:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>

void LCD_voidSHD(uint8  copy_uint8data) {
	
	uint8 LCD_PINS[4]={LCD_D4_PIN,LCD_D5_PIN,LCD_D6_PIN,LCD_D7_PIN} ;
	uint8 LOC_uint8in=0 ;
		for(LOC_uint8in=0;LOC_uint8in<4;LOC_uint8in++)
    555e:	89 81       	ldd	r24, Y+1	; 0x01
    5560:	8f 5f       	subi	r24, 0xFF	; 255
    5562:	89 83       	std	Y+1, r24	; 0x01
    5564:	89 81       	ldd	r24, Y+1	; 0x01
    5566:	84 30       	cpi	r24, 0x04	; 4
    5568:	f0 f2       	brcs	.-68     	; 0x5526 <LCD_voidSHD+0x26>
			DIO_enuWritePin(LCD_PINS[LOC_uint8in],GET_BIT(copy_uint8data,LOC_uint8in)) ;
		}
	
	
	
}
    556a:	26 96       	adiw	r28, 0x06	; 6
    556c:	0f b6       	in	r0, 0x3f	; 63
    556e:	f8 94       	cli
    5570:	de bf       	out	0x3e, r29	; 62
    5572:	0f be       	out	0x3f, r0	; 63
    5574:	cd bf       	out	0x3d, r28	; 61
    5576:	cf 91       	pop	r28
    5578:	df 91       	pop	r29
    557a:	08 95       	ret

0000557c <LCD_voidSendEnable>:

void LCD_voidSendEnable(){
    557c:	df 93       	push	r29
    557e:	cf 93       	push	r28
    5580:	cd b7       	in	r28, 0x3d	; 61
    5582:	de b7       	in	r29, 0x3e	; 62
    5584:	2e 97       	sbiw	r28, 0x0e	; 14
    5586:	0f b6       	in	r0, 0x3f	; 63
    5588:	f8 94       	cli
    558a:	de bf       	out	0x3e, r29	; 62
    558c:	0f be       	out	0x3f, r0	; 63
    558e:	cd bf       	out	0x3d, r28	; 61
	
	 /*Send enable pulse*/
	 DIO_enuWritePin(LCD_EN_PIN,DIO_HIGH) ;
    5590:	8b e0       	ldi	r24, 0x0B	; 11
    5592:	61 e0       	ldi	r22, 0x01	; 1
    5594:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
    5598:	80 e0       	ldi	r24, 0x00	; 0
    559a:	90 e0       	ldi	r25, 0x00	; 0
    559c:	a0 e0       	ldi	r26, 0x00	; 0
    559e:	b0 e4       	ldi	r27, 0x40	; 64
    55a0:	8b 87       	std	Y+11, r24	; 0x0b
    55a2:	9c 87       	std	Y+12, r25	; 0x0c
    55a4:	ad 87       	std	Y+13, r26	; 0x0d
    55a6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    55a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    55aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    55ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    55ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    55b0:	20 e0       	ldi	r18, 0x00	; 0
    55b2:	30 e0       	ldi	r19, 0x00	; 0
    55b4:	4a e7       	ldi	r20, 0x7A	; 122
    55b6:	55 e4       	ldi	r21, 0x45	; 69
    55b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    55bc:	dc 01       	movw	r26, r24
    55be:	cb 01       	movw	r24, r22
    55c0:	8f 83       	std	Y+7, r24	; 0x07
    55c2:	98 87       	std	Y+8, r25	; 0x08
    55c4:	a9 87       	std	Y+9, r26	; 0x09
    55c6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    55c8:	6f 81       	ldd	r22, Y+7	; 0x07
    55ca:	78 85       	ldd	r23, Y+8	; 0x08
    55cc:	89 85       	ldd	r24, Y+9	; 0x09
    55ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    55d0:	20 e0       	ldi	r18, 0x00	; 0
    55d2:	30 e0       	ldi	r19, 0x00	; 0
    55d4:	40 e8       	ldi	r20, 0x80	; 128
    55d6:	5f e3       	ldi	r21, 0x3F	; 63
    55d8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    55dc:	88 23       	and	r24, r24
    55de:	2c f4       	brge	.+10     	; 0x55ea <LCD_voidSendEnable+0x6e>
		__ticks = 1;
    55e0:	81 e0       	ldi	r24, 0x01	; 1
    55e2:	90 e0       	ldi	r25, 0x00	; 0
    55e4:	9e 83       	std	Y+6, r25	; 0x06
    55e6:	8d 83       	std	Y+5, r24	; 0x05
    55e8:	3f c0       	rjmp	.+126    	; 0x5668 <LCD_voidSendEnable+0xec>
	else if (__tmp > 65535)
    55ea:	6f 81       	ldd	r22, Y+7	; 0x07
    55ec:	78 85       	ldd	r23, Y+8	; 0x08
    55ee:	89 85       	ldd	r24, Y+9	; 0x09
    55f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    55f2:	20 e0       	ldi	r18, 0x00	; 0
    55f4:	3f ef       	ldi	r19, 0xFF	; 255
    55f6:	4f e7       	ldi	r20, 0x7F	; 127
    55f8:	57 e4       	ldi	r21, 0x47	; 71
    55fa:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    55fe:	18 16       	cp	r1, r24
    5600:	4c f5       	brge	.+82     	; 0x5654 <LCD_voidSendEnable+0xd8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5602:	6b 85       	ldd	r22, Y+11	; 0x0b
    5604:	7c 85       	ldd	r23, Y+12	; 0x0c
    5606:	8d 85       	ldd	r24, Y+13	; 0x0d
    5608:	9e 85       	ldd	r25, Y+14	; 0x0e
    560a:	20 e0       	ldi	r18, 0x00	; 0
    560c:	30 e0       	ldi	r19, 0x00	; 0
    560e:	40 e2       	ldi	r20, 0x20	; 32
    5610:	51 e4       	ldi	r21, 0x41	; 65
    5612:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5616:	dc 01       	movw	r26, r24
    5618:	cb 01       	movw	r24, r22
    561a:	bc 01       	movw	r22, r24
    561c:	cd 01       	movw	r24, r26
    561e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5622:	dc 01       	movw	r26, r24
    5624:	cb 01       	movw	r24, r22
    5626:	9e 83       	std	Y+6, r25	; 0x06
    5628:	8d 83       	std	Y+5, r24	; 0x05
    562a:	0f c0       	rjmp	.+30     	; 0x564a <LCD_voidSendEnable+0xce>
    562c:	80 e9       	ldi	r24, 0x90	; 144
    562e:	91 e0       	ldi	r25, 0x01	; 1
    5630:	9c 83       	std	Y+4, r25	; 0x04
    5632:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5634:	8b 81       	ldd	r24, Y+3	; 0x03
    5636:	9c 81       	ldd	r25, Y+4	; 0x04
    5638:	01 97       	sbiw	r24, 0x01	; 1
    563a:	f1 f7       	brne	.-4      	; 0x5638 <LCD_voidSendEnable+0xbc>
    563c:	9c 83       	std	Y+4, r25	; 0x04
    563e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5640:	8d 81       	ldd	r24, Y+5	; 0x05
    5642:	9e 81       	ldd	r25, Y+6	; 0x06
    5644:	01 97       	sbiw	r24, 0x01	; 1
    5646:	9e 83       	std	Y+6, r25	; 0x06
    5648:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    564a:	8d 81       	ldd	r24, Y+5	; 0x05
    564c:	9e 81       	ldd	r25, Y+6	; 0x06
    564e:	00 97       	sbiw	r24, 0x00	; 0
    5650:	69 f7       	brne	.-38     	; 0x562c <LCD_voidSendEnable+0xb0>
    5652:	14 c0       	rjmp	.+40     	; 0x567c <LCD_voidSendEnable+0x100>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5654:	6f 81       	ldd	r22, Y+7	; 0x07
    5656:	78 85       	ldd	r23, Y+8	; 0x08
    5658:	89 85       	ldd	r24, Y+9	; 0x09
    565a:	9a 85       	ldd	r25, Y+10	; 0x0a
    565c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5660:	dc 01       	movw	r26, r24
    5662:	cb 01       	movw	r24, r22
    5664:	9e 83       	std	Y+6, r25	; 0x06
    5666:	8d 83       	std	Y+5, r24	; 0x05
    5668:	8d 81       	ldd	r24, Y+5	; 0x05
    566a:	9e 81       	ldd	r25, Y+6	; 0x06
    566c:	9a 83       	std	Y+2, r25	; 0x02
    566e:	89 83       	std	Y+1, r24	; 0x01
    5670:	89 81       	ldd	r24, Y+1	; 0x01
    5672:	9a 81       	ldd	r25, Y+2	; 0x02
    5674:	01 97       	sbiw	r24, 0x01	; 1
    5676:	f1 f7       	brne	.-4      	; 0x5674 <LCD_voidSendEnable+0xf8>
    5678:	9a 83       	std	Y+2, r25	; 0x02
    567a:	89 83       	std	Y+1, r24	; 0x01
	 _delay_ms(2) ;
	 DIO_enuWritePin(LCD_EN_PIN,DIO_LOW) ;
    567c:	8b e0       	ldi	r24, 0x0B	; 11
    567e:	60 e0       	ldi	r22, 0x00	; 0
    5680:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
}
    5684:	2e 96       	adiw	r28, 0x0e	; 14
    5686:	0f b6       	in	r0, 0x3f	; 63
    5688:	f8 94       	cli
    568a:	de bf       	out	0x3e, r29	; 62
    568c:	0f be       	out	0x3f, r0	; 63
    568e:	cd bf       	out	0x3d, r28	; 61
    5690:	cf 91       	pop	r28
    5692:	df 91       	pop	r29
    5694:	08 95       	ret

00005696 <LCD_voidSendData>:

void LCD_voidSendData(uint8 copy_uint8data){
    5696:	df 93       	push	r29
    5698:	cf 93       	push	r28
    569a:	0f 92       	push	r0
    569c:	cd b7       	in	r28, 0x3d	; 61
    569e:	de b7       	in	r29, 0x3e	; 62
    56a0:	89 83       	std	Y+1, r24	; 0x01
		/*make rs as DIO_HIGH to send data  */
		DIO_enuWritePin(LCD_RS_PIN,DIO_HIGH) ;
    56a2:	89 e0       	ldi	r24, 0x09	; 9
    56a4:	61 e0       	ldi	r22, 0x01	; 1
    56a6:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
		/*make rw as DIO_LOW to write command   */
		DIO_enuWritePin(LCD_RW_PIN,DIO_LOW) ;
    56aa:	8a e0       	ldi	r24, 0x0A	; 10
    56ac:	60 e0       	ldi	r22, 0x00	; 0
    56ae:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
	#if LCD_MODE == _4_BIT_MODE
	LCD_voidSHD(copy_uint8data>>4) ;  // 1100 1100
    56b2:	89 81       	ldd	r24, Y+1	; 0x01
    56b4:	82 95       	swap	r24
    56b6:	8f 70       	andi	r24, 0x0F	; 15
    56b8:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
	LCD_voidSendEnable() ;
    56bc:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
	LCD_voidSHD(copy_uint8data) ;
    56c0:	89 81       	ldd	r24, Y+1	; 0x01
    56c2:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
	LCD_voidSendEnable() ;
    56c6:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
	

	
		
	
}
    56ca:	0f 90       	pop	r0
    56cc:	cf 91       	pop	r28
    56ce:	df 91       	pop	r29
    56d0:	08 95       	ret

000056d2 <LCD_voidSendCommand>:
void LCD_voidSendCommand(uint8 copy_uint8command){
    56d2:	df 93       	push	r29
    56d4:	cf 93       	push	r28
    56d6:	0f 92       	push	r0
    56d8:	cd b7       	in	r28, 0x3d	; 61
    56da:	de b7       	in	r29, 0x3e	; 62
    56dc:	89 83       	std	Y+1, r24	; 0x01
	
	/*make rs as DIO_LOW to send command  */
	DIO_enuWritePin(LCD_RS_PIN,DIO_LOW) ;
    56de:	89 e0       	ldi	r24, 0x09	; 9
    56e0:	60 e0       	ldi	r22, 0x00	; 0
    56e2:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
	/*make rw as DIO_LOW to write command   */
	DIO_enuWritePin(LCD_RW_PIN,DIO_LOW) ;
    56e6:	8a e0       	ldi	r24, 0x0A	; 10
    56e8:	60 e0       	ldi	r22, 0x00	; 0
    56ea:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
	
	#if LCD_MODE == _4_BIT_MODE 
	  LCD_voidSHD(copy_uint8command>>4) ;  // 1100 1100
    56ee:	89 81       	ldd	r24, Y+1	; 0x01
    56f0:	82 95       	swap	r24
    56f2:	8f 70       	andi	r24, 0x0F	; 15
    56f4:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
	   LCD_voidSendEnable() ; 
    56f8:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
	  LCD_voidSHD(copy_uint8command) ;
    56fc:	89 81       	ldd	r24, Y+1	; 0x01
    56fe:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
	   LCD_voidSendEnable() ;
    5702:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
   #endif 
	 

	 
	
}
    5706:	0f 90       	pop	r0
    5708:	cf 91       	pop	r28
    570a:	df 91       	pop	r29
    570c:	08 95       	ret

0000570e <LCD_voidInit>:
void LCD_voidInit(void){
    570e:	df 93       	push	r29
    5710:	cf 93       	push	r28
    5712:	cd b7       	in	r28, 0x3d	; 61
    5714:	de b7       	in	r29, 0x3e	; 62
    5716:	2e 97       	sbiw	r28, 0x0e	; 14
    5718:	0f b6       	in	r0, 0x3f	; 63
    571a:	f8 94       	cli
    571c:	de bf       	out	0x3e, r29	; 62
    571e:	0f be       	out	0x3f, r0	; 63
    5720:	cd bf       	out	0x3d, r28	; 61
    5722:	80 e0       	ldi	r24, 0x00	; 0
    5724:	90 e0       	ldi	r25, 0x00	; 0
    5726:	a0 e2       	ldi	r26, 0x20	; 32
    5728:	b2 e4       	ldi	r27, 0x42	; 66
    572a:	8b 87       	std	Y+11, r24	; 0x0b
    572c:	9c 87       	std	Y+12, r25	; 0x0c
    572e:	ad 87       	std	Y+13, r26	; 0x0d
    5730:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5732:	6b 85       	ldd	r22, Y+11	; 0x0b
    5734:	7c 85       	ldd	r23, Y+12	; 0x0c
    5736:	8d 85       	ldd	r24, Y+13	; 0x0d
    5738:	9e 85       	ldd	r25, Y+14	; 0x0e
    573a:	20 e0       	ldi	r18, 0x00	; 0
    573c:	30 e0       	ldi	r19, 0x00	; 0
    573e:	4a e7       	ldi	r20, 0x7A	; 122
    5740:	55 e4       	ldi	r21, 0x45	; 69
    5742:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5746:	dc 01       	movw	r26, r24
    5748:	cb 01       	movw	r24, r22
    574a:	8f 83       	std	Y+7, r24	; 0x07
    574c:	98 87       	std	Y+8, r25	; 0x08
    574e:	a9 87       	std	Y+9, r26	; 0x09
    5750:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5752:	6f 81       	ldd	r22, Y+7	; 0x07
    5754:	78 85       	ldd	r23, Y+8	; 0x08
    5756:	89 85       	ldd	r24, Y+9	; 0x09
    5758:	9a 85       	ldd	r25, Y+10	; 0x0a
    575a:	20 e0       	ldi	r18, 0x00	; 0
    575c:	30 e0       	ldi	r19, 0x00	; 0
    575e:	40 e8       	ldi	r20, 0x80	; 128
    5760:	5f e3       	ldi	r21, 0x3F	; 63
    5762:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5766:	88 23       	and	r24, r24
    5768:	2c f4       	brge	.+10     	; 0x5774 <LCD_voidInit+0x66>
		__ticks = 1;
    576a:	81 e0       	ldi	r24, 0x01	; 1
    576c:	90 e0       	ldi	r25, 0x00	; 0
    576e:	9e 83       	std	Y+6, r25	; 0x06
    5770:	8d 83       	std	Y+5, r24	; 0x05
    5772:	3f c0       	rjmp	.+126    	; 0x57f2 <LCD_voidInit+0xe4>
	else if (__tmp > 65535)
    5774:	6f 81       	ldd	r22, Y+7	; 0x07
    5776:	78 85       	ldd	r23, Y+8	; 0x08
    5778:	89 85       	ldd	r24, Y+9	; 0x09
    577a:	9a 85       	ldd	r25, Y+10	; 0x0a
    577c:	20 e0       	ldi	r18, 0x00	; 0
    577e:	3f ef       	ldi	r19, 0xFF	; 255
    5780:	4f e7       	ldi	r20, 0x7F	; 127
    5782:	57 e4       	ldi	r21, 0x47	; 71
    5784:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5788:	18 16       	cp	r1, r24
    578a:	4c f5       	brge	.+82     	; 0x57de <LCD_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    578c:	6b 85       	ldd	r22, Y+11	; 0x0b
    578e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5790:	8d 85       	ldd	r24, Y+13	; 0x0d
    5792:	9e 85       	ldd	r25, Y+14	; 0x0e
    5794:	20 e0       	ldi	r18, 0x00	; 0
    5796:	30 e0       	ldi	r19, 0x00	; 0
    5798:	40 e2       	ldi	r20, 0x20	; 32
    579a:	51 e4       	ldi	r21, 0x41	; 65
    579c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    57a0:	dc 01       	movw	r26, r24
    57a2:	cb 01       	movw	r24, r22
    57a4:	bc 01       	movw	r22, r24
    57a6:	cd 01       	movw	r24, r26
    57a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    57ac:	dc 01       	movw	r26, r24
    57ae:	cb 01       	movw	r24, r22
    57b0:	9e 83       	std	Y+6, r25	; 0x06
    57b2:	8d 83       	std	Y+5, r24	; 0x05
    57b4:	0f c0       	rjmp	.+30     	; 0x57d4 <LCD_voidInit+0xc6>
    57b6:	80 e9       	ldi	r24, 0x90	; 144
    57b8:	91 e0       	ldi	r25, 0x01	; 1
    57ba:	9c 83       	std	Y+4, r25	; 0x04
    57bc:	8b 83       	std	Y+3, r24	; 0x03
    57be:	8b 81       	ldd	r24, Y+3	; 0x03
    57c0:	9c 81       	ldd	r25, Y+4	; 0x04
    57c2:	01 97       	sbiw	r24, 0x01	; 1
    57c4:	f1 f7       	brne	.-4      	; 0x57c2 <LCD_voidInit+0xb4>
    57c6:	9c 83       	std	Y+4, r25	; 0x04
    57c8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57ca:	8d 81       	ldd	r24, Y+5	; 0x05
    57cc:	9e 81       	ldd	r25, Y+6	; 0x06
    57ce:	01 97       	sbiw	r24, 0x01	; 1
    57d0:	9e 83       	std	Y+6, r25	; 0x06
    57d2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57d4:	8d 81       	ldd	r24, Y+5	; 0x05
    57d6:	9e 81       	ldd	r25, Y+6	; 0x06
    57d8:	00 97       	sbiw	r24, 0x00	; 0
    57da:	69 f7       	brne	.-38     	; 0x57b6 <LCD_voidInit+0xa8>
    57dc:	14 c0       	rjmp	.+40     	; 0x5806 <LCD_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57de:	6f 81       	ldd	r22, Y+7	; 0x07
    57e0:	78 85       	ldd	r23, Y+8	; 0x08
    57e2:	89 85       	ldd	r24, Y+9	; 0x09
    57e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    57e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    57ea:	dc 01       	movw	r26, r24
    57ec:	cb 01       	movw	r24, r22
    57ee:	9e 83       	std	Y+6, r25	; 0x06
    57f0:	8d 83       	std	Y+5, r24	; 0x05
    57f2:	8d 81       	ldd	r24, Y+5	; 0x05
    57f4:	9e 81       	ldd	r25, Y+6	; 0x06
    57f6:	9a 83       	std	Y+2, r25	; 0x02
    57f8:	89 83       	std	Y+1, r24	; 0x01
    57fa:	89 81       	ldd	r24, Y+1	; 0x01
    57fc:	9a 81       	ldd	r25, Y+2	; 0x02
    57fe:	01 97       	sbiw	r24, 0x01	; 1
    5800:	f1 f7       	brne	.-4      	; 0x57fe <LCD_voidInit+0xf0>
    5802:	9a 83       	std	Y+2, r25	; 0x02
    5804:	89 83       	std	Y+1, r24	; 0x01
	 #if LCD_MODE== _8_BIT_MODE
	 /*send command function set */
	 LCD_voidSendCommand(0b00111000) ; 
	 #elif LCD_MODE ==_4_BIT_MODE 
	     
		  LCD_voidSHD(0b0010) ; 
    5806:	82 e0       	ldi	r24, 0x02	; 2
    5808:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
		  LCD_voidSendEnable() ; 
    580c:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
		  LCD_voidSHD(0b0010) ;
    5810:	82 e0       	ldi	r24, 0x02	; 2
    5812:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
		  LCD_voidSendEnable() ;
    5816:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
		  LCD_voidSHD(0b1000) ; 
    581a:	88 e0       	ldi	r24, 0x08	; 8
    581c:	0e 94 80 2a 	call	0x5500	; 0x5500 <LCD_voidSHD>
		  LCD_voidSendEnable() ;
    5820:	0e 94 be 2a 	call	0x557c	; 0x557c <LCD_voidSendEnable>
	#endif 	  
	 /*send command  display on/off */
	 LCD_voidSendCommand(0b00001100) ; 
    5824:	8c e0       	ldi	r24, 0x0C	; 12
    5826:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
	 /*send command   LCD CLR */
	 LCD_voidSendCommand(1) ;
    582a:	81 e0       	ldi	r24, 0x01	; 1
    582c:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
	
}
    5830:	2e 96       	adiw	r28, 0x0e	; 14
    5832:	0f b6       	in	r0, 0x3f	; 63
    5834:	f8 94       	cli
    5836:	de bf       	out	0x3e, r29	; 62
    5838:	0f be       	out	0x3f, r0	; 63
    583a:	cd bf       	out	0x3d, r28	; 61
    583c:	cf 91       	pop	r28
    583e:	df 91       	pop	r29
    5840:	08 95       	ret

00005842 <LCD_voidSendString>:


void LCD_voidSendString(uint8*str){
    5842:	df 93       	push	r29
    5844:	cf 93       	push	r28
    5846:	00 d0       	rcall	.+0      	; 0x5848 <LCD_voidSendString+0x6>
    5848:	0f 92       	push	r0
    584a:	cd b7       	in	r28, 0x3d	; 61
    584c:	de b7       	in	r29, 0x3e	; 62
    584e:	9b 83       	std	Y+3, r25	; 0x03
    5850:	8a 83       	std	Y+2, r24	; 0x02
	
	uint8 i=0 ;
    5852:	19 82       	std	Y+1, r1	; 0x01
    5854:	0e c0       	rjmp	.+28     	; 0x5872 <LCD_voidSendString+0x30>
	while(str[i] !='\0'){
		
		LCD_voidSendData(str[i]) ; 
    5856:	89 81       	ldd	r24, Y+1	; 0x01
    5858:	28 2f       	mov	r18, r24
    585a:	30 e0       	ldi	r19, 0x00	; 0
    585c:	8a 81       	ldd	r24, Y+2	; 0x02
    585e:	9b 81       	ldd	r25, Y+3	; 0x03
    5860:	fc 01       	movw	r30, r24
    5862:	e2 0f       	add	r30, r18
    5864:	f3 1f       	adc	r31, r19
    5866:	80 81       	ld	r24, Z
    5868:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
		i++ ; 
    586c:	89 81       	ldd	r24, Y+1	; 0x01
    586e:	8f 5f       	subi	r24, 0xFF	; 255
    5870:	89 83       	std	Y+1, r24	; 0x01


void LCD_voidSendString(uint8*str){
	
	uint8 i=0 ;
	while(str[i] !='\0'){
    5872:	89 81       	ldd	r24, Y+1	; 0x01
    5874:	28 2f       	mov	r18, r24
    5876:	30 e0       	ldi	r19, 0x00	; 0
    5878:	8a 81       	ldd	r24, Y+2	; 0x02
    587a:	9b 81       	ldd	r25, Y+3	; 0x03
    587c:	fc 01       	movw	r30, r24
    587e:	e2 0f       	add	r30, r18
    5880:	f3 1f       	adc	r31, r19
    5882:	80 81       	ld	r24, Z
    5884:	88 23       	and	r24, r24
    5886:	39 f7       	brne	.-50     	; 0x5856 <LCD_voidSendString+0x14>
	}
	
	
	
	
}
    5888:	0f 90       	pop	r0
    588a:	0f 90       	pop	r0
    588c:	0f 90       	pop	r0
    588e:	cf 91       	pop	r28
    5890:	df 91       	pop	r29
    5892:	08 95       	ret

00005894 <LCD_voidGotoxy>:
void LCD_voidGotoxy(uint8 copy_uint8x,uint8 copyuint8y){
    5894:	df 93       	push	r29
    5896:	cf 93       	push	r28
    5898:	00 d0       	rcall	.+0      	; 0x589a <LCD_voidGotoxy+0x6>
    589a:	0f 92       	push	r0
    589c:	cd b7       	in	r28, 0x3d	; 61
    589e:	de b7       	in	r29, 0x3e	; 62
    58a0:	8a 83       	std	Y+2, r24	; 0x02
    58a2:	6b 83       	std	Y+3, r22	; 0x03
	/* set address */
	uint8 ddram_address= copy_uint8x+copyuint8y*0x40 ;
    58a4:	8b 81       	ldd	r24, Y+3	; 0x03
    58a6:	88 2f       	mov	r24, r24
    58a8:	90 e0       	ldi	r25, 0x00	; 0
    58aa:	00 24       	eor	r0, r0
    58ac:	96 95       	lsr	r25
    58ae:	87 95       	ror	r24
    58b0:	07 94       	ror	r0
    58b2:	96 95       	lsr	r25
    58b4:	87 95       	ror	r24
    58b6:	07 94       	ror	r0
    58b8:	98 2f       	mov	r25, r24
    58ba:	80 2d       	mov	r24, r0
    58bc:	98 2f       	mov	r25, r24
    58be:	8a 81       	ldd	r24, Y+2	; 0x02
    58c0:	89 0f       	add	r24, r25
    58c2:	89 83       	std	Y+1, r24	; 0x01
	
	 /*set DDRAM */
	 SET_BIT(ddram_address,7) ;  // set bit7 in ddram 
    58c4:	89 81       	ldd	r24, Y+1	; 0x01
    58c6:	80 68       	ori	r24, 0x80	; 128
    58c8:	89 83       	std	Y+1, r24	; 0x01
	 
	 LCD_voidSendCommand(ddram_address) ; 
    58ca:	89 81       	ldd	r24, Y+1	; 0x01
    58cc:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
}
    58d0:	0f 90       	pop	r0
    58d2:	0f 90       	pop	r0
    58d4:	0f 90       	pop	r0
    58d6:	cf 91       	pop	r28
    58d8:	df 91       	pop	r29
    58da:	08 95       	ret

000058dc <LCD_voidDrawData>:
void LCD_voidDrawData(uint8 pattern , uint8*data , uint8 x , uint8 y){
    58dc:	df 93       	push	r29
    58de:	cf 93       	push	r28
    58e0:	cd b7       	in	r28, 0x3d	; 61
    58e2:	de b7       	in	r29, 0x3e	; 62
    58e4:	27 97       	sbiw	r28, 0x07	; 7
    58e6:	0f b6       	in	r0, 0x3f	; 63
    58e8:	f8 94       	cli
    58ea:	de bf       	out	0x3e, r29	; 62
    58ec:	0f be       	out	0x3f, r0	; 63
    58ee:	cd bf       	out	0x3d, r28	; 61
    58f0:	8b 83       	std	Y+3, r24	; 0x03
    58f2:	7d 83       	std	Y+5, r23	; 0x05
    58f4:	6c 83       	std	Y+4, r22	; 0x04
    58f6:	4e 83       	std	Y+6, r20	; 0x06
    58f8:	2f 83       	std	Y+7, r18	; 0x07
	  uint8 loc_i=0 ;
    58fa:	1a 82       	std	Y+2, r1	; 0x02
	  uint8 address_CGRAM=pattern*8 ;  // set address
    58fc:	8b 81       	ldd	r24, Y+3	; 0x03
    58fe:	88 2f       	mov	r24, r24
    5900:	90 e0       	ldi	r25, 0x00	; 0
    5902:	88 0f       	add	r24, r24
    5904:	99 1f       	adc	r25, r25
    5906:	88 0f       	add	r24, r24
    5908:	99 1f       	adc	r25, r25
    590a:	88 0f       	add	r24, r24
    590c:	99 1f       	adc	r25, r25
    590e:	89 83       	std	Y+1, r24	; 0x01
	  /* set CGRAM */
	  CLR_BIT(address_CGRAM,7) ; 
    5910:	89 81       	ldd	r24, Y+1	; 0x01
    5912:	8f 77       	andi	r24, 0x7F	; 127
    5914:	89 83       	std	Y+1, r24	; 0x01
	  SET_BIT(address_CGRAM,6) ; 
    5916:	89 81       	ldd	r24, Y+1	; 0x01
    5918:	80 64       	ori	r24, 0x40	; 64
    591a:	89 83       	std	Y+1, r24	; 0x01
	  LCD_voidSendCommand(address_CGRAM) ; 
    591c:	89 81       	ldd	r24, Y+1	; 0x01
    591e:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
	  
	  /* draw data in CGRAM */
	  for (loc_i=0 ; loc_i<8 ;loc_i++)
    5922:	1a 82       	std	Y+2, r1	; 0x02
    5924:	0e c0       	rjmp	.+28     	; 0x5942 <LCD_voidDrawData+0x66>
	  {
		   LCD_voidSendData(data[loc_i]) ;   
    5926:	8a 81       	ldd	r24, Y+2	; 0x02
    5928:	28 2f       	mov	r18, r24
    592a:	30 e0       	ldi	r19, 0x00	; 0
    592c:	8c 81       	ldd	r24, Y+4	; 0x04
    592e:	9d 81       	ldd	r25, Y+5	; 0x05
    5930:	fc 01       	movw	r30, r24
    5932:	e2 0f       	add	r30, r18
    5934:	f3 1f       	adc	r31, r19
    5936:	80 81       	ld	r24, Z
    5938:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
	  CLR_BIT(address_CGRAM,7) ; 
	  SET_BIT(address_CGRAM,6) ; 
	  LCD_voidSendCommand(address_CGRAM) ; 
	  
	  /* draw data in CGRAM */
	  for (loc_i=0 ; loc_i<8 ;loc_i++)
    593c:	8a 81       	ldd	r24, Y+2	; 0x02
    593e:	8f 5f       	subi	r24, 0xFF	; 255
    5940:	8a 83       	std	Y+2, r24	; 0x02
    5942:	8a 81       	ldd	r24, Y+2	; 0x02
    5944:	88 30       	cpi	r24, 0x08	; 8
    5946:	78 f3       	brcs	.-34     	; 0x5926 <LCD_voidDrawData+0x4a>
	  {
		   LCD_voidSendData(data[loc_i]) ;   
	  }
	  LCD_voidGotoxy(x,y) ; 
    5948:	8e 81       	ldd	r24, Y+6	; 0x06
    594a:	6f 81       	ldd	r22, Y+7	; 0x07
    594c:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
	  LCD_voidSendData(pattern) ; 
    5950:	8b 81       	ldd	r24, Y+3	; 0x03
    5952:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
	  
	  
	
	
}
    5956:	27 96       	adiw	r28, 0x07	; 7
    5958:	0f b6       	in	r0, 0x3f	; 63
    595a:	f8 94       	cli
    595c:	de bf       	out	0x3e, r29	; 62
    595e:	0f be       	out	0x3f, r0	; 63
    5960:	cd bf       	out	0x3d, r28	; 61
    5962:	cf 91       	pop	r28
    5964:	df 91       	pop	r29
    5966:	08 95       	ret

00005968 <LCD_voidSendNumber>:
void LCD_voidSendNumber(uint32 number){
    5968:	0f 93       	push	r16
    596a:	1f 93       	push	r17
    596c:	df 93       	push	r29
    596e:	cf 93       	push	r28
    5970:	cd b7       	in	r28, 0x3d	; 61
    5972:	de b7       	in	r29, 0x3e	; 62
    5974:	2f 97       	sbiw	r28, 0x0f	; 15
    5976:	0f b6       	in	r0, 0x3f	; 63
    5978:	f8 94       	cli
    597a:	de bf       	out	0x3e, r29	; 62
    597c:	0f be       	out	0x3f, r0	; 63
    597e:	cd bf       	out	0x3d, r28	; 61
    5980:	6c 87       	std	Y+12, r22	; 0x0c
    5982:	7d 87       	std	Y+13, r23	; 0x0d
    5984:	8e 87       	std	Y+14, r24	; 0x0e
    5986:	9f 87       	std	Y+15, r25	; 0x0f
	
	sint8 i=0;
    5988:	19 82       	std	Y+1, r1	; 0x01
	uint8 array[10] ;
	
	if(number==0){
    598a:	8c 85       	ldd	r24, Y+12	; 0x0c
    598c:	9d 85       	ldd	r25, Y+13	; 0x0d
    598e:	ae 85       	ldd	r26, Y+14	; 0x0e
    5990:	bf 85       	ldd	r27, Y+15	; 0x0f
    5992:	00 97       	sbiw	r24, 0x00	; 0
    5994:	a1 05       	cpc	r26, r1
    5996:	b1 05       	cpc	r27, r1
    5998:	21 f4       	brne	.+8      	; 0x59a2 <LCD_voidSendNumber+0x3a>
		
		LCD_voidSendData('0') ;
    599a:	80 e3       	ldi	r24, 0x30	; 48
    599c:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
    59a0:	51 c0       	rjmp	.+162    	; 0x5a44 <LCD_voidSendNumber+0xdc>
		return ;
	}
	for(i=0; number!=0 ;i++){
    59a2:	19 82       	std	Y+1, r1	; 0x01
    59a4:	30 c0       	rjmp	.+96     	; 0x5a06 <LCD_voidSendNumber+0x9e>
		
		array[i]= number % 10 + 48 ;
    59a6:	89 81       	ldd	r24, Y+1	; 0x01
    59a8:	08 2f       	mov	r16, r24
    59aa:	11 27       	eor	r17, r17
    59ac:	07 fd       	sbrc	r16, 7
    59ae:	10 95       	com	r17
    59b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    59b2:	9d 85       	ldd	r25, Y+13	; 0x0d
    59b4:	ae 85       	ldd	r26, Y+14	; 0x0e
    59b6:	bf 85       	ldd	r27, Y+15	; 0x0f
    59b8:	2a e0       	ldi	r18, 0x0A	; 10
    59ba:	30 e0       	ldi	r19, 0x00	; 0
    59bc:	40 e0       	ldi	r20, 0x00	; 0
    59be:	50 e0       	ldi	r21, 0x00	; 0
    59c0:	bc 01       	movw	r22, r24
    59c2:	cd 01       	movw	r24, r26
    59c4:	0e 94 1f 33 	call	0x663e	; 0x663e <__udivmodsi4>
    59c8:	dc 01       	movw	r26, r24
    59ca:	cb 01       	movw	r24, r22
    59cc:	28 2f       	mov	r18, r24
    59ce:	20 5d       	subi	r18, 0xD0	; 208
    59d0:	ce 01       	movw	r24, r28
    59d2:	02 96       	adiw	r24, 0x02	; 2
    59d4:	fc 01       	movw	r30, r24
    59d6:	e0 0f       	add	r30, r16
    59d8:	f1 1f       	adc	r31, r17
    59da:	20 83       	st	Z, r18
		number /= 10 ;
    59dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    59de:	9d 85       	ldd	r25, Y+13	; 0x0d
    59e0:	ae 85       	ldd	r26, Y+14	; 0x0e
    59e2:	bf 85       	ldd	r27, Y+15	; 0x0f
    59e4:	2a e0       	ldi	r18, 0x0A	; 10
    59e6:	30 e0       	ldi	r19, 0x00	; 0
    59e8:	40 e0       	ldi	r20, 0x00	; 0
    59ea:	50 e0       	ldi	r21, 0x00	; 0
    59ec:	bc 01       	movw	r22, r24
    59ee:	cd 01       	movw	r24, r26
    59f0:	0e 94 1f 33 	call	0x663e	; 0x663e <__udivmodsi4>
    59f4:	da 01       	movw	r26, r20
    59f6:	c9 01       	movw	r24, r18
    59f8:	8c 87       	std	Y+12, r24	; 0x0c
    59fa:	9d 87       	std	Y+13, r25	; 0x0d
    59fc:	ae 87       	std	Y+14, r26	; 0x0e
    59fe:	bf 87       	std	Y+15, r27	; 0x0f
	if(number==0){
		
		LCD_voidSendData('0') ;
		return ;
	}
	for(i=0; number!=0 ;i++){
    5a00:	89 81       	ldd	r24, Y+1	; 0x01
    5a02:	8f 5f       	subi	r24, 0xFF	; 255
    5a04:	89 83       	std	Y+1, r24	; 0x01
    5a06:	8c 85       	ldd	r24, Y+12	; 0x0c
    5a08:	9d 85       	ldd	r25, Y+13	; 0x0d
    5a0a:	ae 85       	ldd	r26, Y+14	; 0x0e
    5a0c:	bf 85       	ldd	r27, Y+15	; 0x0f
    5a0e:	00 97       	sbiw	r24, 0x00	; 0
    5a10:	a1 05       	cpc	r26, r1
    5a12:	b1 05       	cpc	r27, r1
    5a14:	41 f6       	brne	.-112    	; 0x59a6 <LCD_voidSendNumber+0x3e>
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
    5a16:	89 81       	ldd	r24, Y+1	; 0x01
    5a18:	81 50       	subi	r24, 0x01	; 1
    5a1a:	89 83       	std	Y+1, r24	; 0x01
    5a1c:	10 c0       	rjmp	.+32     	; 0x5a3e <LCD_voidSendNumber+0xd6>
	while(i >= 0){
		
		LCD_voidSendData(array[i]) ;
    5a1e:	89 81       	ldd	r24, Y+1	; 0x01
    5a20:	28 2f       	mov	r18, r24
    5a22:	33 27       	eor	r19, r19
    5a24:	27 fd       	sbrc	r18, 7
    5a26:	30 95       	com	r19
    5a28:	ce 01       	movw	r24, r28
    5a2a:	02 96       	adiw	r24, 0x02	; 2
    5a2c:	fc 01       	movw	r30, r24
    5a2e:	e2 0f       	add	r30, r18
    5a30:	f3 1f       	adc	r31, r19
    5a32:	80 81       	ld	r24, Z
    5a34:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
		i-- ;
    5a38:	89 81       	ldd	r24, Y+1	; 0x01
    5a3a:	81 50       	subi	r24, 0x01	; 1
    5a3c:	89 83       	std	Y+1, r24	; 0x01
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
	while(i >= 0){
    5a3e:	89 81       	ldd	r24, Y+1	; 0x01
    5a40:	88 23       	and	r24, r24
    5a42:	6c f7       	brge	.-38     	; 0x5a1e <LCD_voidSendNumber+0xb6>
		
		LCD_voidSendData(array[i]) ;
		i-- ;
	}
}
    5a44:	2f 96       	adiw	r28, 0x0f	; 15
    5a46:	0f b6       	in	r0, 0x3f	; 63
    5a48:	f8 94       	cli
    5a4a:	de bf       	out	0x3e, r29	; 62
    5a4c:	0f be       	out	0x3f, r0	; 63
    5a4e:	cd bf       	out	0x3d, r28	; 61
    5a50:	cf 91       	pop	r28
    5a52:	df 91       	pop	r29
    5a54:	1f 91       	pop	r17
    5a56:	0f 91       	pop	r16
    5a58:	08 95       	ret

00005a5a <EEPROM_enuWriteByte>:

#include "../../LIB/STD_TYPES.h"
#include "../../MCAL/I2C/I2C.h"
#include "EEPROM.h"
tenuErrorStatus EEPROM_enuWriteByte(uint8 u8ChipNbCpy , uint8 u8ByteAddCpy , uint8 u8DataCpy)
{
    5a5a:	df 93       	push	r29
    5a5c:	cf 93       	push	r28
    5a5e:	00 d0       	rcall	.+0      	; 0x5a60 <EEPROM_enuWriteByte+0x6>
    5a60:	00 d0       	rcall	.+0      	; 0x5a62 <EEPROM_enuWriteByte+0x8>
    5a62:	cd b7       	in	r28, 0x3d	; 61
    5a64:	de b7       	in	r29, 0x3e	; 62
    5a66:	89 83       	std	Y+1, r24	; 0x01
    5a68:	6a 83       	std	Y+2, r22	; 0x02
    5a6a:	4b 83       	std	Y+3, r20	; 0x03
	 
	I2C_voidStart();
    5a6c:	0e 94 a0 24 	call	0x4940	; 0x4940 <I2C_voidStart>
	if(I2C_u8GetStatus() != I2C_START )
    5a70:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5a74:	88 30       	cpi	r24, 0x08	; 8
    5a76:	19 f0       	breq	.+6      	; 0x5a7e <EEPROM_enuWriteByte+0x24>
	{
		return ENOK ;
    5a78:	81 e0       	ldi	r24, 0x01	; 1
    5a7a:	8c 83       	std	Y+4, r24	; 0x04
    5a7c:	26 c0       	rjmp	.+76     	; 0x5aca <EEPROM_enuWriteByte+0x70>
	}
	/* user send to me u8ChipAddCpy  contain A2A1A0*/
	I2C_voidWrite(0b10100000|(u8ChipNbCpy <<1));
    5a7e:	89 81       	ldd	r24, Y+1	; 0x01
    5a80:	88 2f       	mov	r24, r24
    5a82:	90 e0       	ldi	r25, 0x00	; 0
    5a84:	88 0f       	add	r24, r24
    5a86:	99 1f       	adc	r25, r25
    5a88:	80 6a       	ori	r24, 0xA0	; 160
    5a8a:	0e 94 bb 24 	call	0x4976	; 0x4976 <I2C_voidWrite>
	if(I2C_u8GetStatus() != I2C_MT_SLA_W_ACK )
    5a8e:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5a92:	88 31       	cpi	r24, 0x18	; 24
    5a94:	19 f0       	breq	.+6      	; 0x5a9c <EEPROM_enuWriteByte+0x42>
	{
		return ENOK ;
    5a96:	81 e0       	ldi	r24, 0x01	; 1
    5a98:	8c 83       	std	Y+4, r24	; 0x04
    5a9a:	17 c0       	rjmp	.+46     	; 0x5aca <EEPROM_enuWriteByte+0x70>
	}
	I2C_voidWrite(u8ByteAddCpy);
    5a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    5a9e:	0e 94 bb 24 	call	0x4976	; 0x4976 <I2C_voidWrite>
	if(I2C_u8GetStatus() != I2C_MT_DATA_ACK )
    5aa2:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5aa6:	88 32       	cpi	r24, 0x28	; 40
    5aa8:	19 f0       	breq	.+6      	; 0x5ab0 <EEPROM_enuWriteByte+0x56>
	{
		return ENOK ;
    5aaa:	81 e0       	ldi	r24, 0x01	; 1
    5aac:	8c 83       	std	Y+4, r24	; 0x04
    5aae:	0d c0       	rjmp	.+26     	; 0x5aca <EEPROM_enuWriteByte+0x70>
	}
	I2C_voidWrite(u8DataCpy);	
    5ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ab2:	0e 94 bb 24 	call	0x4976	; 0x4976 <I2C_voidWrite>
	if(I2C_u8GetStatus() != I2C_MT_DATA_ACK )
    5ab6:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5aba:	88 32       	cpi	r24, 0x28	; 40
    5abc:	19 f0       	breq	.+6      	; 0x5ac4 <EEPROM_enuWriteByte+0x6a>
	{
		return ENOK ;
    5abe:	81 e0       	ldi	r24, 0x01	; 1
    5ac0:	8c 83       	std	Y+4, r24	; 0x04
    5ac2:	03 c0       	rjmp	.+6      	; 0x5aca <EEPROM_enuWriteByte+0x70>
	}
	I2C_voidStop();
    5ac4:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <I2C_voidStop>
	return EOK ;
    5ac8:	1c 82       	std	Y+4, r1	; 0x04
    5aca:	8c 81       	ldd	r24, Y+4	; 0x04
}
    5acc:	0f 90       	pop	r0
    5ace:	0f 90       	pop	r0
    5ad0:	0f 90       	pop	r0
    5ad2:	0f 90       	pop	r0
    5ad4:	cf 91       	pop	r28
    5ad6:	df 91       	pop	r29
    5ad8:	08 95       	ret

00005ada <EEPROM_enuReadByte>:

tenuErrorStatus EEPROM_enuReadByte(uint8 u8ChipNbCpy , uint8 u8ByteAddCpy , uint8 * pu8DataCpy)
{
    5ada:	df 93       	push	r29
    5adc:	cf 93       	push	r28
    5ade:	00 d0       	rcall	.+0      	; 0x5ae0 <EEPROM_enuReadByte+0x6>
    5ae0:	00 d0       	rcall	.+0      	; 0x5ae2 <EEPROM_enuReadByte+0x8>
    5ae2:	0f 92       	push	r0
    5ae4:	cd b7       	in	r28, 0x3d	; 61
    5ae6:	de b7       	in	r29, 0x3e	; 62
    5ae8:	89 83       	std	Y+1, r24	; 0x01
    5aea:	6a 83       	std	Y+2, r22	; 0x02
    5aec:	5c 83       	std	Y+4, r21	; 0x04
    5aee:	4b 83       	std	Y+3, r20	; 0x03
	I2C_voidStart();
    5af0:	0e 94 a0 24 	call	0x4940	; 0x4940 <I2C_voidStart>
	if(I2C_u8GetStatus() != I2C_START )
    5af4:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5af8:	88 30       	cpi	r24, 0x08	; 8
    5afa:	19 f0       	breq	.+6      	; 0x5b02 <EEPROM_enuReadByte+0x28>
	{
		return 1 ;
    5afc:	81 e0       	ldi	r24, 0x01	; 1
    5afe:	8d 83       	std	Y+5, r24	; 0x05
    5b00:	31 c0       	rjmp	.+98     	; 0x5b64 <EEPROM_enuReadByte+0x8a>
	}
	I2C_voidWrite(0b10100000|(u8ChipNbCpy <<1));
    5b02:	89 81       	ldd	r24, Y+1	; 0x01
    5b04:	88 2f       	mov	r24, r24
    5b06:	90 e0       	ldi	r25, 0x00	; 0
    5b08:	88 0f       	add	r24, r24
    5b0a:	99 1f       	adc	r25, r25
    5b0c:	80 6a       	ori	r24, 0xA0	; 160
    5b0e:	0e 94 bb 24 	call	0x4976	; 0x4976 <I2C_voidWrite>
	if(I2C_u8GetStatus() != I2C_MT_SLA_W_ACK )
    5b12:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
	{
	//	return 2 ;
	}
	I2C_voidWrite(u8ByteAddCpy);
    5b16:	8a 81       	ldd	r24, Y+2	; 0x02
    5b18:	0e 94 bb 24 	call	0x4976	; 0x4976 <I2C_voidWrite>
	if(I2C_u8GetStatus() != I2C_MT_DATA_ACK )
    5b1c:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
	{
	//	return 3 ;
	}
	/*Repeat start condition*/
	I2C_voidStart();
    5b20:	0e 94 a0 24 	call	0x4940	; 0x4940 <I2C_voidStart>
	if(I2C_u8GetStatus() != I2C_REPEAT_START )
    5b24:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5b28:	80 31       	cpi	r24, 0x10	; 16
    5b2a:	19 f0       	breq	.+6      	; 0x5b32 <EEPROM_enuReadByte+0x58>
	{
		return 4 ;
    5b2c:	84 e0       	ldi	r24, 0x04	; 4
    5b2e:	8d 83       	std	Y+5, r24	; 0x05
    5b30:	19 c0       	rjmp	.+50     	; 0x5b64 <EEPROM_enuReadByte+0x8a>
	}
	/* Chip select with read*/
	I2C_voidWrite(0b10100001|(u8ChipNbCpy <<1));
    5b32:	89 81       	ldd	r24, Y+1	; 0x01
    5b34:	88 2f       	mov	r24, r24
    5b36:	90 e0       	ldi	r25, 0x00	; 0
    5b38:	88 0f       	add	r24, r24
    5b3a:	99 1f       	adc	r25, r25
    5b3c:	81 6a       	ori	r24, 0xA1	; 161
    5b3e:	0e 94 bb 24 	call	0x4976	; 0x4976 <I2C_voidWrite>
	if(I2C_u8GetStatus() != I2C_MT_SLA_R_ACK )
    5b42:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
	{
		//return 5 ;
	}
	*pu8DataCpy = I2C_u8ReadWithoutAck();
    5b46:	0e 94 dd 24 	call	0x49ba	; 0x49ba <I2C_u8ReadWithoutAck>
    5b4a:	eb 81       	ldd	r30, Y+3	; 0x03
    5b4c:	fc 81       	ldd	r31, Y+4	; 0x04
    5b4e:	80 83       	st	Z, r24
	if(I2C_u8GetStatus() != I2C_MR_DATA_NACK )
    5b50:	0e 94 b0 24 	call	0x4960	; 0x4960 <I2C_u8GetStatus>
    5b54:	88 35       	cpi	r24, 0x58	; 88
    5b56:	19 f0       	breq	.+6      	; 0x5b5e <EEPROM_enuReadByte+0x84>
	{
		return 6 ;
    5b58:	86 e0       	ldi	r24, 0x06	; 6
    5b5a:	8d 83       	std	Y+5, r24	; 0x05
    5b5c:	03 c0       	rjmp	.+6      	; 0x5b64 <EEPROM_enuReadByte+0x8a>
	}
	I2C_voidStop();
    5b5e:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <I2C_voidStop>
	return EOK ; 
    5b62:	1d 82       	std	Y+5, r1	; 0x05
    5b64:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5b66:	0f 90       	pop	r0
    5b68:	0f 90       	pop	r0
    5b6a:	0f 90       	pop	r0
    5b6c:	0f 90       	pop	r0
    5b6e:	0f 90       	pop	r0
    5b70:	cf 91       	pop	r28
    5b72:	df 91       	pop	r29
    5b74:	08 95       	ret

00005b76 <AppStart>:
// array of strings have welcome message
uint8 String[4][22]={"*******************","*login press 1    *","*new user press 2 *","*******************",};
/**********************************************************************************************************************/

int AppStart(void)
{
    5b76:	ef 92       	push	r14
    5b78:	ff 92       	push	r15
    5b7a:	0f 93       	push	r16
    5b7c:	df 93       	push	r29
    5b7e:	cf 93       	push	r28
    5b80:	cd b7       	in	r28, 0x3d	; 61
    5b82:	de b7       	in	r29, 0x3e	; 62
	/**************************************start of system initializations**************************************************/
    DIO_Init();
    5b84:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <DIO_Init>
    UART_voidInit();
    5b88:	0e 94 62 22 	call	0x44c4	; 0x44c4 <UART_voidInit>
    LCD_voidInit();
    5b8c:	0e 94 87 2b 	call	0x570e	; 0x570e <LCD_voidInit>
    LM35_vidinit();
    5b90:	0e 94 29 2a 	call	0x5452	; 0x5452 <LM35_vidinit>
    TIM2_voidinit();
    5b94:	0e 94 33 23 	call	0x4666	; 0x4666 <TIM2_voidinit>
    TIM2_voidEnable(TIM2_PRESCALER_1);
    5b98:	81 e0       	ldi	r24, 0x01	; 1
    5b9a:	0e 94 72 23 	call	0x46e4	; 0x46e4 <TIM2_voidEnable>
    I2C_voidInit();
    5b9e:	0e 94 81 24 	call	0x4902	; 0x4902 <I2C_voidInit>
    /**************************************End of system initializations**************************************************/


    /**************************************start of Queue Creation**************************************************/
    Queue_LM35 = xQueueCreate(1, sizeof(uint32));
    5ba2:	81 e0       	ldi	r24, 0x01	; 1
    5ba4:	64 e0       	ldi	r22, 0x04	; 4
    5ba6:	40 e0       	ldi	r20, 0x00	; 0
    5ba8:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <xQueueGenericCreate>
    5bac:	90 93 ab 06 	sts	0x06AB, r25
    5bb0:	80 93 aa 06 	sts	0x06AA, r24
    /**************************************End of Queue Creation**************************************************/


    /**************************************start of Semaphor Creation**************************************************/
    LCD_Semaphore = xSemaphoreCreateBinary();
    5bb4:	81 e0       	ldi	r24, 0x01	; 1
    5bb6:	60 e0       	ldi	r22, 0x00	; 0
    5bb8:	43 e0       	ldi	r20, 0x03	; 3
    5bba:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <xQueueGenericCreate>
    5bbe:	90 93 a3 06 	sts	0x06A3, r25
    5bc2:	80 93 a2 06 	sts	0x06A2, r24
    /**************************************end of Semaphor Creation**************************************************/



    /**************************************start of Task Creation**************************************************/
    xTaskCreate(vLogin , "login" , 200 , NULL , 1 , &vtask_Login);
    5bc6:	8f e1       	ldi	r24, 0x1F	; 31
    5bc8:	9e e2       	ldi	r25, 0x2E	; 46
    5bca:	23 e7       	ldi	r18, 0x73	; 115
    5bcc:	30 e0       	ldi	r19, 0x00	; 0
    5bce:	e0 ea       	ldi	r30, 0xA0	; 160
    5bd0:	f6 e0       	ldi	r31, 0x06	; 6
    5bd2:	b9 01       	movw	r22, r18
    5bd4:	48 ec       	ldi	r20, 0xC8	; 200
    5bd6:	50 e0       	ldi	r21, 0x00	; 0
    5bd8:	20 e0       	ldi	r18, 0x00	; 0
    5bda:	30 e0       	ldi	r19, 0x00	; 0
    5bdc:	01 e0       	ldi	r16, 0x01	; 1
    5bde:	7f 01       	movw	r14, r30
    5be0:	0e 94 05 13 	call	0x260a	; 0x260a <xTaskCreate>
    xTaskCreate(vLM35  , "LM35"  , 150 , NULL , 2 , &vtask_LM35 );
    5be4:	87 e7       	ldi	r24, 0x77	; 119
    5be6:	92 e3       	ldi	r25, 0x32	; 50
    5be8:	29 e7       	ldi	r18, 0x79	; 121
    5bea:	30 e0       	ldi	r19, 0x00	; 0
    5bec:	ee e9       	ldi	r30, 0x9E	; 158
    5bee:	f6 e0       	ldi	r31, 0x06	; 6
    5bf0:	b9 01       	movw	r22, r18
    5bf2:	46 e9       	ldi	r20, 0x96	; 150
    5bf4:	50 e0       	ldi	r21, 0x00	; 0
    5bf6:	20 e0       	ldi	r18, 0x00	; 0
    5bf8:	30 e0       	ldi	r19, 0x00	; 0
    5bfa:	02 e0       	ldi	r16, 0x02	; 2
    5bfc:	7f 01       	movw	r14, r30
    5bfe:	0e 94 05 13 	call	0x260a	; 0x260a <xTaskCreate>
    xTaskCreate(vFAN   , "FAN"   , 150 , NULL , 3 , &vtask_Fan  );
    5c02:	85 ea       	ldi	r24, 0xA5	; 165
    5c04:	92 e3       	ldi	r25, 0x32	; 50
    5c06:	2e e7       	ldi	r18, 0x7E	; 126
    5c08:	30 e0       	ldi	r19, 0x00	; 0
    5c0a:	ec e9       	ldi	r30, 0x9C	; 156
    5c0c:	f6 e0       	ldi	r31, 0x06	; 6
    5c0e:	b9 01       	movw	r22, r18
    5c10:	46 e9       	ldi	r20, 0x96	; 150
    5c12:	50 e0       	ldi	r21, 0x00	; 0
    5c14:	20 e0       	ldi	r18, 0x00	; 0
    5c16:	30 e0       	ldi	r19, 0x00	; 0
    5c18:	03 e0       	ldi	r16, 0x03	; 3
    5c1a:	7f 01       	movw	r14, r30
    5c1c:	0e 94 05 13 	call	0x260a	; 0x260a <xTaskCreate>
    /**************************************end of Task Creation**************************************************/


    /********************************************Suspended Tasks *******************************************************************/
    vTaskSuspend(vtask_Fan);
    5c20:	80 91 9c 06 	lds	r24, 0x069C
    5c24:	90 91 9d 06 	lds	r25, 0x069D
    5c28:	0e 94 80 16 	call	0x2d00	; 0x2d00 <vTaskSuspend>
    vTaskSuspend(vtask_LM35);
    5c2c:	80 91 9e 06 	lds	r24, 0x069E
    5c30:	90 91 9f 06 	lds	r25, 0x069F
    5c34:	0e 94 80 16 	call	0x2d00	; 0x2d00 <vTaskSuspend>

    /* Start the scheduler*/
    vTaskStartScheduler();
    5c38:	0e 94 e5 17 	call	0x2fca	; 0x2fca <vTaskStartScheduler>
    5c3c:	ff cf       	rjmp	.-2      	; 0x5c3c <AppStart+0xc6>

00005c3e <vLogin>:
    while (1);
}


void vLogin(void *pvParameters)
{
    5c3e:	df 93       	push	r29
    5c40:	cf 93       	push	r28
    5c42:	cd b7       	in	r28, 0x3d	; 61
    5c44:	de b7       	in	r29, 0x3e	; 62
    5c46:	c7 56       	subi	r28, 0x67	; 103
    5c48:	d0 40       	sbci	r29, 0x00	; 0
    5c4a:	0f b6       	in	r0, 0x3f	; 63
    5c4c:	f8 94       	cli
    5c4e:	de bf       	out	0x3e, r29	; 62
    5c50:	0f be       	out	0x3f, r0	; 63
    5c52:	cd bf       	out	0x3d, r28	; 61
    5c54:	fe 01       	movw	r30, r28
    5c56:	ec 59       	subi	r30, 0x9C	; 156
    5c58:	ff 4f       	sbci	r31, 0xFF	; 255
    5c5a:	91 83       	std	Z+1, r25	; 0x01
    5c5c:	80 83       	st	Z, r24
	/*Definitions of Local variable of Login task*/
	uint8 user_name[16],user_pass[16];
	uint8 entry_data;
	uint8 option,Key=3;
    5c5e:	fe 01       	movw	r30, r28
    5c60:	ef 5b       	subi	r30, 0xBF	; 191
    5c62:	ff 4f       	sbci	r31, 0xFF	; 255
    5c64:	83 e0       	ldi	r24, 0x03	; 3
    5c66:	80 83       	st	Z, r24
	while(1)
	{
		xSemaphoreTake(LCD_Semaphore,(TickType_t)30);
    5c68:	80 91 a2 06 	lds	r24, 0x06A2
    5c6c:	90 91 a3 06 	lds	r25, 0x06A3
    5c70:	60 e0       	ldi	r22, 0x00	; 0
    5c72:	70 e0       	ldi	r23, 0x00	; 0
    5c74:	4e e1       	ldi	r20, 0x1E	; 30
    5c76:	50 e0       	ldi	r21, 0x00	; 0
    5c78:	20 e0       	ldi	r18, 0x00	; 0
    5c7a:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <xQueueGenericReceive>

		/*****************************************start of sending interface message****************************************************/
		for(uint8 row_itr=0;row_itr < 4; row_itr ++)
    5c7e:	fe 01       	movw	r30, r28
    5c80:	e0 5c       	subi	r30, 0xC0	; 192
    5c82:	ff 4f       	sbci	r31, 0xFF	; 255
    5c84:	10 82       	st	Z, r1
    5c86:	39 c0       	rjmp	.+114    	; 0x5cfa <vLogin+0xbc>
		{
			for(uint8 col_itr=0;col_itr < 20; col_itr ++)
    5c88:	1f ae       	std	Y+63, r1	; 0x3f
    5c8a:	27 c0       	rjmp	.+78     	; 0x5cda <vLogin+0x9c>
			{
				UART_voidSend(String[row_itr][col_itr]);
    5c8c:	fe 01       	movw	r30, r28
    5c8e:	e0 5c       	subi	r30, 0xC0	; 192
    5c90:	ff 4f       	sbci	r31, 0xFF	; 255
    5c92:	80 81       	ld	r24, Z
    5c94:	48 2f       	mov	r20, r24
    5c96:	50 e0       	ldi	r21, 0x00	; 0
    5c98:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c9a:	68 2f       	mov	r22, r24
    5c9c:	70 e0       	ldi	r23, 0x00	; 0
    5c9e:	ca 01       	movw	r24, r20
    5ca0:	9c 01       	movw	r18, r24
    5ca2:	22 0f       	add	r18, r18
    5ca4:	33 1f       	adc	r19, r19
    5ca6:	24 0f       	add	r18, r20
    5ca8:	35 1f       	adc	r19, r21
    5caa:	c9 01       	movw	r24, r18
    5cac:	88 0f       	add	r24, r24
    5cae:	99 1f       	adc	r25, r25
    5cb0:	88 0f       	add	r24, r24
    5cb2:	99 1f       	adc	r25, r25
    5cb4:	88 0f       	add	r24, r24
    5cb6:	99 1f       	adc	r25, r25
    5cb8:	82 1b       	sub	r24, r18
    5cba:	93 0b       	sbc	r25, r19
    5cbc:	84 0f       	add	r24, r20
    5cbe:	95 1f       	adc	r25, r21
    5cc0:	86 0f       	add	r24, r22
    5cc2:	97 1f       	adc	r25, r23
    5cc4:	fc 01       	movw	r30, r24
    5cc6:	ef 50       	subi	r30, 0x0F	; 15
    5cc8:	fe 4f       	sbci	r31, 0xFE	; 254
    5cca:	80 81       	ld	r24, Z
    5ccc:	88 2f       	mov	r24, r24
    5cce:	90 e0       	ldi	r25, 0x00	; 0
    5cd0:	0e 94 97 22 	call	0x452e	; 0x452e <UART_voidSend>
		xSemaphoreTake(LCD_Semaphore,(TickType_t)30);

		/*****************************************start of sending interface message****************************************************/
		for(uint8 row_itr=0;row_itr < 4; row_itr ++)
		{
			for(uint8 col_itr=0;col_itr < 20; col_itr ++)
    5cd4:	8f ad       	ldd	r24, Y+63	; 0x3f
    5cd6:	8f 5f       	subi	r24, 0xFF	; 255
    5cd8:	8f af       	std	Y+63, r24	; 0x3f
    5cda:	8f ad       	ldd	r24, Y+63	; 0x3f
    5cdc:	84 31       	cpi	r24, 0x14	; 20
    5cde:	b0 f2       	brcs	.-84     	; 0x5c8c <vLogin+0x4e>
			{
				UART_voidSend(String[row_itr][col_itr]);
			}
			UART_voidSend('\r');
    5ce0:	8d e0       	ldi	r24, 0x0D	; 13
    5ce2:	90 e0       	ldi	r25, 0x00	; 0
    5ce4:	0e 94 97 22 	call	0x452e	; 0x452e <UART_voidSend>
	while(1)
	{
		xSemaphoreTake(LCD_Semaphore,(TickType_t)30);

		/*****************************************start of sending interface message****************************************************/
		for(uint8 row_itr=0;row_itr < 4; row_itr ++)
    5ce8:	fe 01       	movw	r30, r28
    5cea:	e0 5c       	subi	r30, 0xC0	; 192
    5cec:	ff 4f       	sbci	r31, 0xFF	; 255
    5cee:	80 81       	ld	r24, Z
    5cf0:	8f 5f       	subi	r24, 0xFF	; 255
    5cf2:	fe 01       	movw	r30, r28
    5cf4:	e0 5c       	subi	r30, 0xC0	; 192
    5cf6:	ff 4f       	sbci	r31, 0xFF	; 255
    5cf8:	80 83       	st	Z, r24
    5cfa:	fe 01       	movw	r30, r28
    5cfc:	e0 5c       	subi	r30, 0xC0	; 192
    5cfe:	ff 4f       	sbci	r31, 0xFF	; 255
    5d00:	80 81       	ld	r24, Z
    5d02:	84 30       	cpi	r24, 0x04	; 4
    5d04:	08 f2       	brcs	.-126    	; 0x5c88 <vLogin+0x4a>
		}
		/*****************************************end of sending interface message****************************************************/


		/***********************************start loading user name *****************************************************************/
		for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5d06:	1e ae       	std	Y+62, r1	; 0x3e
    5d08:	1e c0       	rjmp	.+60     	; 0x5d46 <vLogin+0x108>
		{
			EEPROM_enuReadByte(0,(USER_NAME_BASE_ADDRESS|u8Counter) ,&USER_NAME[u8Counter]);
    5d0a:	20 91 ed 01 	lds	r18, 0x01ED
    5d0e:	30 91 ee 01 	lds	r19, 0x01EE
    5d12:	8e ad       	ldd	r24, Y+62	; 0x3e
    5d14:	88 2f       	mov	r24, r24
    5d16:	90 e0       	ldi	r25, 0x00	; 0
    5d18:	28 0f       	add	r18, r24
    5d1a:	39 1f       	adc	r19, r25
    5d1c:	80 e0       	ldi	r24, 0x00	; 0
    5d1e:	6e ad       	ldd	r22, Y+62	; 0x3e
    5d20:	a9 01       	movw	r20, r18
    5d22:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <EEPROM_enuReadByte>
			if(USER_NAME[u8Counter] == '\0')
    5d26:	20 91 ed 01 	lds	r18, 0x01ED
    5d2a:	30 91 ee 01 	lds	r19, 0x01EE
    5d2e:	8e ad       	ldd	r24, Y+62	; 0x3e
    5d30:	88 2f       	mov	r24, r24
    5d32:	90 e0       	ldi	r25, 0x00	; 0
    5d34:	f9 01       	movw	r30, r18
    5d36:	e8 0f       	add	r30, r24
    5d38:	f9 1f       	adc	r31, r25
    5d3a:	80 81       	ld	r24, Z
    5d3c:	88 23       	and	r24, r24
    5d3e:	31 f0       	breq	.+12     	; 0x5d4c <vLogin+0x10e>
		}
		/*****************************************end of sending interface message****************************************************/


		/***********************************start loading user name *****************************************************************/
		for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5d40:	8e ad       	ldd	r24, Y+62	; 0x3e
    5d42:	8f 5f       	subi	r24, 0xFF	; 255
    5d44:	8e af       	std	Y+62, r24	; 0x3e
    5d46:	8e ad       	ldd	r24, Y+62	; 0x3e
    5d48:	80 31       	cpi	r24, 0x10	; 16
    5d4a:	f8 f2       	brcs	.-66     	; 0x5d0a <vLogin+0xcc>
		}
		/***********************************end loading user name ********************************************************************/


		/***********************************start loading user password **************************************************************/
		for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5d4c:	1d ae       	std	Y+61, r1	; 0x3d
    5d4e:	2d c0       	rjmp	.+90     	; 0x5daa <vLogin+0x16c>
		{
			EEPROM_enuReadByte(0,(USER_PASS_BASE_ADDRESS|u8Counter) ,&USER_PASS[u8Counter]);
    5d50:	8d ad       	ldd	r24, Y+61	; 0x3d
    5d52:	48 2f       	mov	r20, r24
    5d54:	40 6f       	ori	r20, 0xF0	; 240
    5d56:	20 91 ef 01 	lds	r18, 0x01EF
    5d5a:	30 91 f0 01 	lds	r19, 0x01F0
    5d5e:	8d ad       	ldd	r24, Y+61	; 0x3d
    5d60:	88 2f       	mov	r24, r24
    5d62:	90 e0       	ldi	r25, 0x00	; 0
    5d64:	28 0f       	add	r18, r24
    5d66:	39 1f       	adc	r19, r25
    5d68:	80 e0       	ldi	r24, 0x00	; 0
    5d6a:	64 2f       	mov	r22, r20
    5d6c:	a9 01       	movw	r20, r18
    5d6e:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <EEPROM_enuReadByte>
			if(USER_PASS[u8Counter] == '\0')
    5d72:	20 91 ef 01 	lds	r18, 0x01EF
    5d76:	30 91 f0 01 	lds	r19, 0x01F0
    5d7a:	8d ad       	ldd	r24, Y+61	; 0x3d
    5d7c:	88 2f       	mov	r24, r24
    5d7e:	90 e0       	ldi	r25, 0x00	; 0
    5d80:	f9 01       	movw	r30, r18
    5d82:	e8 0f       	add	r30, r24
    5d84:	f9 1f       	adc	r31, r25
    5d86:	80 81       	ld	r24, Z
    5d88:	88 23       	and	r24, r24
    5d8a:	61 f4       	brne	.+24     	; 0x5da4 <vLogin+0x166>
			{
				USER_PASS[u8Counter] = '\0';
    5d8c:	20 91 ef 01 	lds	r18, 0x01EF
    5d90:	30 91 f0 01 	lds	r19, 0x01F0
    5d94:	8d ad       	ldd	r24, Y+61	; 0x3d
    5d96:	88 2f       	mov	r24, r24
    5d98:	90 e0       	ldi	r25, 0x00	; 0
    5d9a:	f9 01       	movw	r30, r18
    5d9c:	e8 0f       	add	r30, r24
    5d9e:	f9 1f       	adc	r31, r25
    5da0:	10 82       	st	Z, r1
    5da2:	06 c0       	rjmp	.+12     	; 0x5db0 <vLogin+0x172>
		}
		/***********************************end loading user name ********************************************************************/


		/***********************************start loading user password **************************************************************/
		for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5da4:	8d ad       	ldd	r24, Y+61	; 0x3d
    5da6:	8f 5f       	subi	r24, 0xFF	; 255
    5da8:	8d af       	std	Y+61, r24	; 0x3d
    5daa:	8d ad       	ldd	r24, Y+61	; 0x3d
    5dac:	80 31       	cpi	r24, 0x10	; 16
    5dae:	80 f2       	brcs	.-96     	; 0x5d50 <vLogin+0x112>
		}
		/***********************************end loading user password ****************************************************************/


		/*take user choice*/
		UART_enuRecieve(&option);
    5db0:	ce 01       	movw	r24, r28
    5db2:	8d 59       	subi	r24, 0x9D	; 157
    5db4:	9f 4f       	sbci	r25, 0xFF	; 255
    5db6:	0e 94 b3 22 	call	0x4566	; 0x4566 <UART_enuRecieve>
		switch(option)
    5dba:	fe 01       	movw	r30, r28
    5dbc:	ed 59       	subi	r30, 0x9D	; 157
    5dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    5dc0:	80 81       	ld	r24, Z
    5dc2:	28 2f       	mov	r18, r24
    5dc4:	30 e0       	ldi	r19, 0x00	; 0
    5dc6:	a8 96       	adiw	r28, 0x28	; 40
    5dc8:	3f af       	std	Y+63, r19	; 0x3f
    5dca:	2e af       	std	Y+62, r18	; 0x3e
    5dcc:	a8 97       	sbiw	r28, 0x28	; 40
    5dce:	a8 96       	adiw	r28, 0x28	; 40
    5dd0:	8e ad       	ldd	r24, Y+62	; 0x3e
    5dd2:	9f ad       	ldd	r25, Y+63	; 0x3f
    5dd4:	a8 97       	sbiw	r28, 0x28	; 40
    5dd6:	81 33       	cpi	r24, 0x31	; 49
    5dd8:	91 05       	cpc	r25, r1
    5dda:	49 f0       	breq	.+18     	; 0x5dee <vLogin+0x1b0>
    5ddc:	a8 96       	adiw	r28, 0x28	; 40
    5dde:	2e ad       	ldd	r18, Y+62	; 0x3e
    5de0:	3f ad       	ldd	r19, Y+63	; 0x3f
    5de2:	a8 97       	sbiw	r28, 0x28	; 40
    5de4:	22 33       	cpi	r18, 0x32	; 50
    5de6:	31 05       	cpc	r19, r1
    5de8:	09 f4       	brne	.+2      	; 0x5dec <vLogin+0x1ae>
    5dea:	6f c2       	rjmp	.+1246   	; 0x62ca <vLogin+0x68c>
    5dec:	70 c3       	rjmp	.+1760   	; 0x64ce <vLogin+0x890>
		{
			case '1':
				/***********************************start receiving  user name *****************************************/
				UART_voidSend('\r');
    5dee:	8d e0       	ldi	r24, 0x0D	; 13
    5df0:	90 e0       	ldi	r25, 0x00	; 0
    5df2:	0e 94 97 22 	call	0x452e	; 0x452e <UART_voidSend>
				LCD_voidGotoxy(0,0);
    5df6:	80 e0       	ldi	r24, 0x00	; 0
    5df8:	60 e0       	ldi	r22, 0x00	; 0
    5dfa:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
				LCD_voidSendString("user name ");
    5dfe:	82 e8       	ldi	r24, 0x82	; 130
    5e00:	90 e0       	ldi	r25, 0x00	; 0
    5e02:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5e06:	1c ae       	std	Y+60, r1	; 0x3c
    5e08:	34 c0       	rjmp	.+104    	; 0x5e72 <vLogin+0x234>
				{
					UART_enuRecieve(&user_name[u8Counter]);
    5e0a:	9e 01       	movw	r18, r28
    5e0c:	2e 5b       	subi	r18, 0xBE	; 190
    5e0e:	3f 4f       	sbci	r19, 0xFF	; 255
    5e10:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e12:	88 2f       	mov	r24, r24
    5e14:	90 e0       	ldi	r25, 0x00	; 0
    5e16:	82 0f       	add	r24, r18
    5e18:	93 1f       	adc	r25, r19
    5e1a:	0e 94 b3 22 	call	0x4566	; 0x4566 <UART_enuRecieve>
					if(user_name[u8Counter] == '\r')
    5e1e:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e20:	28 2f       	mov	r18, r24
    5e22:	30 e0       	ldi	r19, 0x00	; 0
    5e24:	ce 01       	movw	r24, r28
    5e26:	8e 5b       	subi	r24, 0xBE	; 190
    5e28:	9f 4f       	sbci	r25, 0xFF	; 255
    5e2a:	fc 01       	movw	r30, r24
    5e2c:	e2 0f       	add	r30, r18
    5e2e:	f3 1f       	adc	r31, r19
    5e30:	80 81       	ld	r24, Z
    5e32:	8d 30       	cpi	r24, 0x0D	; 13
    5e34:	59 f4       	brne	.+22     	; 0x5e4c <vLogin+0x20e>
					{
						user_name[u8Counter] = '\0';
    5e36:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e38:	28 2f       	mov	r18, r24
    5e3a:	30 e0       	ldi	r19, 0x00	; 0
    5e3c:	ce 01       	movw	r24, r28
    5e3e:	8e 5b       	subi	r24, 0xBE	; 190
    5e40:	9f 4f       	sbci	r25, 0xFF	; 255
    5e42:	fc 01       	movw	r30, r24
    5e44:	e2 0f       	add	r30, r18
    5e46:	f3 1f       	adc	r31, r19
    5e48:	10 82       	st	Z, r1
    5e4a:	16 c0       	rjmp	.+44     	; 0x5e78 <vLogin+0x23a>
						break;
					}
					LCD_voidGotoxy(u8Counter,1);
    5e4c:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e4e:	61 e0       	ldi	r22, 0x01	; 1
    5e50:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendData(user_name[u8Counter]);
    5e54:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e56:	28 2f       	mov	r18, r24
    5e58:	30 e0       	ldi	r19, 0x00	; 0
    5e5a:	ce 01       	movw	r24, r28
    5e5c:	8e 5b       	subi	r24, 0xBE	; 190
    5e5e:	9f 4f       	sbci	r25, 0xFF	; 255
    5e60:	fc 01       	movw	r30, r24
    5e62:	e2 0f       	add	r30, r18
    5e64:	f3 1f       	adc	r31, r19
    5e66:	80 81       	ld	r24, Z
    5e68:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
			case '1':
				/***********************************start receiving  user name *****************************************/
				UART_voidSend('\r');
				LCD_voidGotoxy(0,0);
				LCD_voidSendString("user name ");
				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5e6c:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e6e:	8f 5f       	subi	r24, 0xFF	; 255
    5e70:	8c af       	std	Y+60, r24	; 0x3c
    5e72:	8c ad       	ldd	r24, Y+60	; 0x3c
    5e74:	80 31       	cpi	r24, 0x10	; 16
    5e76:	48 f2       	brcs	.-110    	; 0x5e0a <vLogin+0x1cc>
				}
				/***********************************end receiving  user name *****************************************/


				/***********************************start receiving  user password *****************************************/
				LCD_voidSendCommand(0x01);
    5e78:	81 e0       	ldi	r24, 0x01	; 1
    5e7a:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
				LCD_voidGotoxy(0,0);
    5e7e:	80 e0       	ldi	r24, 0x00	; 0
    5e80:	60 e0       	ldi	r22, 0x00	; 0
    5e82:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
				LCD_voidSendString("password");
    5e86:	8d e8       	ldi	r24, 0x8D	; 141
    5e88:	90 e0       	ldi	r25, 0x00	; 0
    5e8a:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5e8e:	1b ae       	std	Y+59, r1	; 0x3b
    5e90:	ad c0       	rjmp	.+346    	; 0x5fec <vLogin+0x3ae>
				{
					UART_enuRecieve(&user_pass[u8Counter]);
    5e92:	9e 01       	movw	r18, r28
    5e94:	2e 5a       	subi	r18, 0xAE	; 174
    5e96:	3f 4f       	sbci	r19, 0xFF	; 255
    5e98:	8b ad       	ldd	r24, Y+59	; 0x3b
    5e9a:	88 2f       	mov	r24, r24
    5e9c:	90 e0       	ldi	r25, 0x00	; 0
    5e9e:	82 0f       	add	r24, r18
    5ea0:	93 1f       	adc	r25, r19
    5ea2:	0e 94 b3 22 	call	0x4566	; 0x4566 <UART_enuRecieve>
					if(user_pass[u8Counter] == '\r')
    5ea6:	8b ad       	ldd	r24, Y+59	; 0x3b
    5ea8:	28 2f       	mov	r18, r24
    5eaa:	30 e0       	ldi	r19, 0x00	; 0
    5eac:	ce 01       	movw	r24, r28
    5eae:	8e 5a       	subi	r24, 0xAE	; 174
    5eb0:	9f 4f       	sbci	r25, 0xFF	; 255
    5eb2:	fc 01       	movw	r30, r24
    5eb4:	e2 0f       	add	r30, r18
    5eb6:	f3 1f       	adc	r31, r19
    5eb8:	80 81       	ld	r24, Z
    5eba:	8d 30       	cpi	r24, 0x0D	; 13
    5ebc:	59 f4       	brne	.+22     	; 0x5ed4 <vLogin+0x296>
					{
						user_pass[u8Counter] = '\0';
    5ebe:	8b ad       	ldd	r24, Y+59	; 0x3b
    5ec0:	28 2f       	mov	r18, r24
    5ec2:	30 e0       	ldi	r19, 0x00	; 0
    5ec4:	ce 01       	movw	r24, r28
    5ec6:	8e 5a       	subi	r24, 0xAE	; 174
    5ec8:	9f 4f       	sbci	r25, 0xFF	; 255
    5eca:	fc 01       	movw	r30, r24
    5ecc:	e2 0f       	add	r30, r18
    5ece:	f3 1f       	adc	r31, r19
    5ed0:	10 82       	st	Z, r1
    5ed2:	90 c0       	rjmp	.+288    	; 0x5ff4 <vLogin+0x3b6>
						break;
					}
					LCD_voidGotoxy(u8Counter,1);
    5ed4:	8b ad       	ldd	r24, Y+59	; 0x3b
    5ed6:	61 e0       	ldi	r22, 0x01	; 1
    5ed8:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendData(user_pass[u8Counter]);
    5edc:	8b ad       	ldd	r24, Y+59	; 0x3b
    5ede:	28 2f       	mov	r18, r24
    5ee0:	30 e0       	ldi	r19, 0x00	; 0
    5ee2:	ce 01       	movw	r24, r28
    5ee4:	8e 5a       	subi	r24, 0xAE	; 174
    5ee6:	9f 4f       	sbci	r25, 0xFF	; 255
    5ee8:	fc 01       	movw	r30, r24
    5eea:	e2 0f       	add	r30, r18
    5eec:	f3 1f       	adc	r31, r19
    5eee:	80 81       	ld	r24, Z
    5ef0:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
    5ef4:	80 e0       	ldi	r24, 0x00	; 0
    5ef6:	90 e0       	ldi	r25, 0x00	; 0
    5ef8:	a8 ec       	ldi	r26, 0xC8	; 200
    5efa:	b2 e4       	ldi	r27, 0x42	; 66
    5efc:	8d ab       	std	Y+53, r24	; 0x35
    5efe:	9e ab       	std	Y+54, r25	; 0x36
    5f00:	af ab       	std	Y+55, r26	; 0x37
    5f02:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5f04:	6d a9       	ldd	r22, Y+53	; 0x35
    5f06:	7e a9       	ldd	r23, Y+54	; 0x36
    5f08:	8f a9       	ldd	r24, Y+55	; 0x37
    5f0a:	98 ad       	ldd	r25, Y+56	; 0x38
    5f0c:	20 e0       	ldi	r18, 0x00	; 0
    5f0e:	30 e0       	ldi	r19, 0x00	; 0
    5f10:	4a e7       	ldi	r20, 0x7A	; 122
    5f12:	55 e4       	ldi	r21, 0x45	; 69
    5f14:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5f18:	dc 01       	movw	r26, r24
    5f1a:	cb 01       	movw	r24, r22
    5f1c:	89 ab       	std	Y+49, r24	; 0x31
    5f1e:	9a ab       	std	Y+50, r25	; 0x32
    5f20:	ab ab       	std	Y+51, r26	; 0x33
    5f22:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5f24:	69 a9       	ldd	r22, Y+49	; 0x31
    5f26:	7a a9       	ldd	r23, Y+50	; 0x32
    5f28:	8b a9       	ldd	r24, Y+51	; 0x33
    5f2a:	9c a9       	ldd	r25, Y+52	; 0x34
    5f2c:	20 e0       	ldi	r18, 0x00	; 0
    5f2e:	30 e0       	ldi	r19, 0x00	; 0
    5f30:	40 e8       	ldi	r20, 0x80	; 128
    5f32:	5f e3       	ldi	r21, 0x3F	; 63
    5f34:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5f38:	88 23       	and	r24, r24
    5f3a:	2c f4       	brge	.+10     	; 0x5f46 <vLogin+0x308>
		__ticks = 1;
    5f3c:	81 e0       	ldi	r24, 0x01	; 1
    5f3e:	90 e0       	ldi	r25, 0x00	; 0
    5f40:	98 ab       	std	Y+48, r25	; 0x30
    5f42:	8f a7       	std	Y+47, r24	; 0x2f
    5f44:	3f c0       	rjmp	.+126    	; 0x5fc4 <vLogin+0x386>
	else if (__tmp > 65535)
    5f46:	69 a9       	ldd	r22, Y+49	; 0x31
    5f48:	7a a9       	ldd	r23, Y+50	; 0x32
    5f4a:	8b a9       	ldd	r24, Y+51	; 0x33
    5f4c:	9c a9       	ldd	r25, Y+52	; 0x34
    5f4e:	20 e0       	ldi	r18, 0x00	; 0
    5f50:	3f ef       	ldi	r19, 0xFF	; 255
    5f52:	4f e7       	ldi	r20, 0x7F	; 127
    5f54:	57 e4       	ldi	r21, 0x47	; 71
    5f56:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5f5a:	18 16       	cp	r1, r24
    5f5c:	4c f5       	brge	.+82     	; 0x5fb0 <vLogin+0x372>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5f5e:	6d a9       	ldd	r22, Y+53	; 0x35
    5f60:	7e a9       	ldd	r23, Y+54	; 0x36
    5f62:	8f a9       	ldd	r24, Y+55	; 0x37
    5f64:	98 ad       	ldd	r25, Y+56	; 0x38
    5f66:	20 e0       	ldi	r18, 0x00	; 0
    5f68:	30 e0       	ldi	r19, 0x00	; 0
    5f6a:	40 e2       	ldi	r20, 0x20	; 32
    5f6c:	51 e4       	ldi	r21, 0x41	; 65
    5f6e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5f72:	dc 01       	movw	r26, r24
    5f74:	cb 01       	movw	r24, r22
    5f76:	bc 01       	movw	r22, r24
    5f78:	cd 01       	movw	r24, r26
    5f7a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5f7e:	dc 01       	movw	r26, r24
    5f80:	cb 01       	movw	r24, r22
    5f82:	98 ab       	std	Y+48, r25	; 0x30
    5f84:	8f a7       	std	Y+47, r24	; 0x2f
    5f86:	0f c0       	rjmp	.+30     	; 0x5fa6 <vLogin+0x368>
    5f88:	80 e9       	ldi	r24, 0x90	; 144
    5f8a:	91 e0       	ldi	r25, 0x01	; 1
    5f8c:	9e a7       	std	Y+46, r25	; 0x2e
    5f8e:	8d a7       	std	Y+45, r24	; 0x2d
    5f90:	8d a5       	ldd	r24, Y+45	; 0x2d
    5f92:	9e a5       	ldd	r25, Y+46	; 0x2e
    5f94:	01 97       	sbiw	r24, 0x01	; 1
    5f96:	f1 f7       	brne	.-4      	; 0x5f94 <vLogin+0x356>
    5f98:	9e a7       	std	Y+46, r25	; 0x2e
    5f9a:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5f9c:	8f a5       	ldd	r24, Y+47	; 0x2f
    5f9e:	98 a9       	ldd	r25, Y+48	; 0x30
    5fa0:	01 97       	sbiw	r24, 0x01	; 1
    5fa2:	98 ab       	std	Y+48, r25	; 0x30
    5fa4:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5fa6:	8f a5       	ldd	r24, Y+47	; 0x2f
    5fa8:	98 a9       	ldd	r25, Y+48	; 0x30
    5faa:	00 97       	sbiw	r24, 0x00	; 0
    5fac:	69 f7       	brne	.-38     	; 0x5f88 <vLogin+0x34a>
    5fae:	14 c0       	rjmp	.+40     	; 0x5fd8 <vLogin+0x39a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5fb0:	69 a9       	ldd	r22, Y+49	; 0x31
    5fb2:	7a a9       	ldd	r23, Y+50	; 0x32
    5fb4:	8b a9       	ldd	r24, Y+51	; 0x33
    5fb6:	9c a9       	ldd	r25, Y+52	; 0x34
    5fb8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5fbc:	dc 01       	movw	r26, r24
    5fbe:	cb 01       	movw	r24, r22
    5fc0:	98 ab       	std	Y+48, r25	; 0x30
    5fc2:	8f a7       	std	Y+47, r24	; 0x2f
    5fc4:	8f a5       	ldd	r24, Y+47	; 0x2f
    5fc6:	98 a9       	ldd	r25, Y+48	; 0x30
    5fc8:	9c a7       	std	Y+44, r25	; 0x2c
    5fca:	8b a7       	std	Y+43, r24	; 0x2b
    5fcc:	8b a5       	ldd	r24, Y+43	; 0x2b
    5fce:	9c a5       	ldd	r25, Y+44	; 0x2c
    5fd0:	01 97       	sbiw	r24, 0x01	; 1
    5fd2:	f1 f7       	brne	.-4      	; 0x5fd0 <vLogin+0x392>
    5fd4:	9c a7       	std	Y+44, r25	; 0x2c
    5fd6:	8b a7       	std	Y+43, r24	; 0x2b
					_delay_ms(100);
					LCD_voidGotoxy(u8Counter,1);
    5fd8:	8b ad       	ldd	r24, Y+59	; 0x3b
    5fda:	61 e0       	ldi	r22, 0x01	; 1
    5fdc:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendData('*');
    5fe0:	8a e2       	ldi	r24, 0x2A	; 42
    5fe2:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>

				/***********************************start receiving  user password *****************************************/
				LCD_voidSendCommand(0x01);
				LCD_voidGotoxy(0,0);
				LCD_voidSendString("password");
				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    5fe6:	8b ad       	ldd	r24, Y+59	; 0x3b
    5fe8:	8f 5f       	subi	r24, 0xFF	; 255
    5fea:	8b af       	std	Y+59, r24	; 0x3b
    5fec:	8b ad       	ldd	r24, Y+59	; 0x3b
    5fee:	80 31       	cpi	r24, 0x10	; 16
    5ff0:	08 f4       	brcc	.+2      	; 0x5ff4 <vLogin+0x3b6>
    5ff2:	4f cf       	rjmp	.-354    	; 0x5e92 <vLogin+0x254>
					LCD_voidSendData('*');
				}
				/***********************************end receiving  user password *****************************************/

				/*checking user name and password*/
				if((strcmp(user_name,USER_NAME)==0) && (strcmp(user_pass,USER_PASS)==0))
    5ff4:	20 91 ed 01 	lds	r18, 0x01ED
    5ff8:	30 91 ee 01 	lds	r19, 0x01EE
    5ffc:	ce 01       	movw	r24, r28
    5ffe:	8e 5b       	subi	r24, 0xBE	; 190
    6000:	9f 4f       	sbci	r25, 0xFF	; 255
    6002:	b9 01       	movw	r22, r18
    6004:	0e 94 81 33 	call	0x6702	; 0x6702 <strcmp>
    6008:	00 97       	sbiw	r24, 0x00	; 0
    600a:	09 f0       	breq	.+2      	; 0x600e <vLogin+0x3d0>
    600c:	be c0       	rjmp	.+380    	; 0x618a <vLogin+0x54c>
    600e:	20 91 ef 01 	lds	r18, 0x01EF
    6012:	30 91 f0 01 	lds	r19, 0x01F0
    6016:	ce 01       	movw	r24, r28
    6018:	8e 5a       	subi	r24, 0xAE	; 174
    601a:	9f 4f       	sbci	r25, 0xFF	; 255
    601c:	b9 01       	movw	r22, r18
    601e:	0e 94 81 33 	call	0x6702	; 0x6702 <strcmp>
    6022:	00 97       	sbiw	r24, 0x00	; 0
    6024:	09 f0       	breq	.+2      	; 0x6028 <vLogin+0x3ea>
    6026:	b1 c0       	rjmp	.+354    	; 0x618a <vLogin+0x54c>
				{
					/*Incase correct user name and password return Key value to default */
					Key=3;
    6028:	fe 01       	movw	r30, r28
    602a:	ef 5b       	subi	r30, 0xBF	; 191
    602c:	ff 4f       	sbci	r31, 0xFF	; 255
    602e:	83 e0       	ldi	r24, 0x03	; 3
    6030:	80 83       	st	Z, r24

					/*Open the Door lock*/
					DIO_enuWritePin(DOOR_PIN,DIO_HIGH);
    6032:	82 e0       	ldi	r24, 0x02	; 2
    6034:	61 e0       	ldi	r22, 0x01	; 1
    6036:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>


					/*welcome the user*/
					LCD_voidSendCommand(0x01);
    603a:	81 e0       	ldi	r24, 0x01	; 1
    603c:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
					LCD_voidGotoxy(0,0);
    6040:	80 e0       	ldi	r24, 0x00	; 0
    6042:	60 e0       	ldi	r22, 0x00	; 0
    6044:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendString("Welcome ");
    6048:	86 e9       	ldi	r24, 0x96	; 150
    604a:	90 e0       	ldi	r25, 0x00	; 0
    604c:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
					LCD_voidSendString(USER_NAME);
    6050:	80 91 ed 01 	lds	r24, 0x01ED
    6054:	90 91 ee 01 	lds	r25, 0x01EE
    6058:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
    605c:	80 e0       	ldi	r24, 0x00	; 0
    605e:	90 e0       	ldi	r25, 0x00	; 0
    6060:	aa e7       	ldi	r26, 0x7A	; 122
    6062:	b4 e4       	ldi	r27, 0x44	; 68
    6064:	8f a3       	std	Y+39, r24	; 0x27
    6066:	98 a7       	std	Y+40, r25	; 0x28
    6068:	a9 a7       	std	Y+41, r26	; 0x29
    606a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    606c:	6f a1       	ldd	r22, Y+39	; 0x27
    606e:	78 a5       	ldd	r23, Y+40	; 0x28
    6070:	89 a5       	ldd	r24, Y+41	; 0x29
    6072:	9a a5       	ldd	r25, Y+42	; 0x2a
    6074:	20 e0       	ldi	r18, 0x00	; 0
    6076:	30 e0       	ldi	r19, 0x00	; 0
    6078:	4a e7       	ldi	r20, 0x7A	; 122
    607a:	55 e4       	ldi	r21, 0x45	; 69
    607c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6080:	dc 01       	movw	r26, r24
    6082:	cb 01       	movw	r24, r22
    6084:	8b a3       	std	Y+35, r24	; 0x23
    6086:	9c a3       	std	Y+36, r25	; 0x24
    6088:	ad a3       	std	Y+37, r26	; 0x25
    608a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    608c:	6b a1       	ldd	r22, Y+35	; 0x23
    608e:	7c a1       	ldd	r23, Y+36	; 0x24
    6090:	8d a1       	ldd	r24, Y+37	; 0x25
    6092:	9e a1       	ldd	r25, Y+38	; 0x26
    6094:	20 e0       	ldi	r18, 0x00	; 0
    6096:	30 e0       	ldi	r19, 0x00	; 0
    6098:	40 e8       	ldi	r20, 0x80	; 128
    609a:	5f e3       	ldi	r21, 0x3F	; 63
    609c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    60a0:	88 23       	and	r24, r24
    60a2:	2c f4       	brge	.+10     	; 0x60ae <vLogin+0x470>
		__ticks = 1;
    60a4:	81 e0       	ldi	r24, 0x01	; 1
    60a6:	90 e0       	ldi	r25, 0x00	; 0
    60a8:	9a a3       	std	Y+34, r25	; 0x22
    60aa:	89 a3       	std	Y+33, r24	; 0x21
    60ac:	3f c0       	rjmp	.+126    	; 0x612c <vLogin+0x4ee>
	else if (__tmp > 65535)
    60ae:	6b a1       	ldd	r22, Y+35	; 0x23
    60b0:	7c a1       	ldd	r23, Y+36	; 0x24
    60b2:	8d a1       	ldd	r24, Y+37	; 0x25
    60b4:	9e a1       	ldd	r25, Y+38	; 0x26
    60b6:	20 e0       	ldi	r18, 0x00	; 0
    60b8:	3f ef       	ldi	r19, 0xFF	; 255
    60ba:	4f e7       	ldi	r20, 0x7F	; 127
    60bc:	57 e4       	ldi	r21, 0x47	; 71
    60be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    60c2:	18 16       	cp	r1, r24
    60c4:	4c f5       	brge	.+82     	; 0x6118 <vLogin+0x4da>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    60c6:	6f a1       	ldd	r22, Y+39	; 0x27
    60c8:	78 a5       	ldd	r23, Y+40	; 0x28
    60ca:	89 a5       	ldd	r24, Y+41	; 0x29
    60cc:	9a a5       	ldd	r25, Y+42	; 0x2a
    60ce:	20 e0       	ldi	r18, 0x00	; 0
    60d0:	30 e0       	ldi	r19, 0x00	; 0
    60d2:	40 e2       	ldi	r20, 0x20	; 32
    60d4:	51 e4       	ldi	r21, 0x41	; 65
    60d6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    60da:	dc 01       	movw	r26, r24
    60dc:	cb 01       	movw	r24, r22
    60de:	bc 01       	movw	r22, r24
    60e0:	cd 01       	movw	r24, r26
    60e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    60e6:	dc 01       	movw	r26, r24
    60e8:	cb 01       	movw	r24, r22
    60ea:	9a a3       	std	Y+34, r25	; 0x22
    60ec:	89 a3       	std	Y+33, r24	; 0x21
    60ee:	0f c0       	rjmp	.+30     	; 0x610e <vLogin+0x4d0>
    60f0:	80 e9       	ldi	r24, 0x90	; 144
    60f2:	91 e0       	ldi	r25, 0x01	; 1
    60f4:	98 a3       	std	Y+32, r25	; 0x20
    60f6:	8f 8f       	std	Y+31, r24	; 0x1f
    60f8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    60fa:	98 a1       	ldd	r25, Y+32	; 0x20
    60fc:	01 97       	sbiw	r24, 0x01	; 1
    60fe:	f1 f7       	brne	.-4      	; 0x60fc <vLogin+0x4be>
    6100:	98 a3       	std	Y+32, r25	; 0x20
    6102:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6104:	89 a1       	ldd	r24, Y+33	; 0x21
    6106:	9a a1       	ldd	r25, Y+34	; 0x22
    6108:	01 97       	sbiw	r24, 0x01	; 1
    610a:	9a a3       	std	Y+34, r25	; 0x22
    610c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    610e:	89 a1       	ldd	r24, Y+33	; 0x21
    6110:	9a a1       	ldd	r25, Y+34	; 0x22
    6112:	00 97       	sbiw	r24, 0x00	; 0
    6114:	69 f7       	brne	.-38     	; 0x60f0 <vLogin+0x4b2>
    6116:	14 c0       	rjmp	.+40     	; 0x6140 <vLogin+0x502>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6118:	6b a1       	ldd	r22, Y+35	; 0x23
    611a:	7c a1       	ldd	r23, Y+36	; 0x24
    611c:	8d a1       	ldd	r24, Y+37	; 0x25
    611e:	9e a1       	ldd	r25, Y+38	; 0x26
    6120:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6124:	dc 01       	movw	r26, r24
    6126:	cb 01       	movw	r24, r22
    6128:	9a a3       	std	Y+34, r25	; 0x22
    612a:	89 a3       	std	Y+33, r24	; 0x21
    612c:	89 a1       	ldd	r24, Y+33	; 0x21
    612e:	9a a1       	ldd	r25, Y+34	; 0x22
    6130:	9e 8f       	std	Y+30, r25	; 0x1e
    6132:	8d 8f       	std	Y+29, r24	; 0x1d
    6134:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6136:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6138:	01 97       	sbiw	r24, 0x01	; 1
    613a:	f1 f7       	brne	.-4      	; 0x6138 <vLogin+0x4fa>
    613c:	9e 8f       	std	Y+30, r25	; 0x1e
    613e:	8d 8f       	std	Y+29, r24	; 0x1d


					/*after one second close Door again*/
					_delay_ms(1000);
					DIO_enuWritePin(DOOR_PIN,DIO_LOW);
    6140:	82 e0       	ldi	r24, 0x02	; 2
    6142:	60 e0       	ldi	r22, 0x00	; 0
    6144:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>
					LCD_voidSendCommand(0x01);
    6148:	81 e0       	ldi	r24, 0x01	; 1
    614a:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>

					/*release LCD semaphor*/
					xSemaphoreGive(LCD_Semaphore);
    614e:	80 91 a2 06 	lds	r24, 0x06A2
    6152:	90 91 a3 06 	lds	r25, 0x06A3
    6156:	60 e0       	ldi	r22, 0x00	; 0
    6158:	70 e0       	ldi	r23, 0x00	; 0
    615a:	40 e0       	ldi	r20, 0x00	; 0
    615c:	50 e0       	ldi	r21, 0x00	; 0
    615e:	20 e0       	ldi	r18, 0x00	; 0
    6160:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <xQueueGenericSend>

					/*resume all tasks except login task*/
					vTaskResume(vtask_Fan);
    6164:	80 91 9c 06 	lds	r24, 0x069C
    6168:	90 91 9d 06 	lds	r25, 0x069D
    616c:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <vTaskResume>
					vTaskResume(vtask_LM35);
    6170:	80 91 9e 06 	lds	r24, 0x069E
    6174:	90 91 9f 06 	lds	r25, 0x069F
    6178:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <vTaskResume>
					vTaskSuspend(vtask_Login);
    617c:	80 91 a0 06 	lds	r24, 0x06A0
    6180:	90 91 a1 06 	lds	r25, 0x06A1
    6184:	0e 94 80 16 	call	0x2d00	; 0x2d00 <vTaskSuspend>
    6188:	a2 c1       	rjmp	.+836    	; 0x64ce <vLogin+0x890>

				}
				else
				{
					/*Incase Wrong Passorwd or user name decrement Key's value*/
					Key--;
    618a:	de 01       	movw	r26, r28
    618c:	af 5b       	subi	r26, 0xBF	; 191
    618e:	bf 4f       	sbci	r27, 0xFF	; 255
    6190:	fe 01       	movw	r30, r28
    6192:	ef 5b       	subi	r30, 0xBF	; 191
    6194:	ff 4f       	sbci	r31, 0xFF	; 255
    6196:	80 81       	ld	r24, Z
    6198:	81 50       	subi	r24, 0x01	; 1
    619a:	8c 93       	st	X, r24
					LCD_voidSendCommand(0x01);
    619c:	81 e0       	ldi	r24, 0x01	; 1
    619e:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
					LCD_voidGotoxy(0,0);
    61a2:	80 e0       	ldi	r24, 0x00	; 0
    61a4:	60 e0       	ldi	r22, 0x00	; 0
    61a6:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendString("invalid user");
    61aa:	8f e9       	ldi	r24, 0x9F	; 159
    61ac:	90 e0       	ldi	r25, 0x00	; 0
    61ae:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
    61b2:	80 e0       	ldi	r24, 0x00	; 0
    61b4:	90 e0       	ldi	r25, 0x00	; 0
    61b6:	aa e7       	ldi	r26, 0x7A	; 122
    61b8:	b4 e4       	ldi	r27, 0x44	; 68
    61ba:	89 8f       	std	Y+25, r24	; 0x19
    61bc:	9a 8f       	std	Y+26, r25	; 0x1a
    61be:	ab 8f       	std	Y+27, r26	; 0x1b
    61c0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    61c2:	69 8d       	ldd	r22, Y+25	; 0x19
    61c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    61c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    61c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    61ca:	20 e0       	ldi	r18, 0x00	; 0
    61cc:	30 e0       	ldi	r19, 0x00	; 0
    61ce:	4a e7       	ldi	r20, 0x7A	; 122
    61d0:	55 e4       	ldi	r21, 0x45	; 69
    61d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    61d6:	dc 01       	movw	r26, r24
    61d8:	cb 01       	movw	r24, r22
    61da:	8d 8b       	std	Y+21, r24	; 0x15
    61dc:	9e 8b       	std	Y+22, r25	; 0x16
    61de:	af 8b       	std	Y+23, r26	; 0x17
    61e0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    61e2:	6d 89       	ldd	r22, Y+21	; 0x15
    61e4:	7e 89       	ldd	r23, Y+22	; 0x16
    61e6:	8f 89       	ldd	r24, Y+23	; 0x17
    61e8:	98 8d       	ldd	r25, Y+24	; 0x18
    61ea:	20 e0       	ldi	r18, 0x00	; 0
    61ec:	30 e0       	ldi	r19, 0x00	; 0
    61ee:	40 e8       	ldi	r20, 0x80	; 128
    61f0:	5f e3       	ldi	r21, 0x3F	; 63
    61f2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    61f6:	88 23       	and	r24, r24
    61f8:	2c f4       	brge	.+10     	; 0x6204 <vLogin+0x5c6>
		__ticks = 1;
    61fa:	81 e0       	ldi	r24, 0x01	; 1
    61fc:	90 e0       	ldi	r25, 0x00	; 0
    61fe:	9c 8b       	std	Y+20, r25	; 0x14
    6200:	8b 8b       	std	Y+19, r24	; 0x13
    6202:	3f c0       	rjmp	.+126    	; 0x6282 <vLogin+0x644>
	else if (__tmp > 65535)
    6204:	6d 89       	ldd	r22, Y+21	; 0x15
    6206:	7e 89       	ldd	r23, Y+22	; 0x16
    6208:	8f 89       	ldd	r24, Y+23	; 0x17
    620a:	98 8d       	ldd	r25, Y+24	; 0x18
    620c:	20 e0       	ldi	r18, 0x00	; 0
    620e:	3f ef       	ldi	r19, 0xFF	; 255
    6210:	4f e7       	ldi	r20, 0x7F	; 127
    6212:	57 e4       	ldi	r21, 0x47	; 71
    6214:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6218:	18 16       	cp	r1, r24
    621a:	4c f5       	brge	.+82     	; 0x626e <vLogin+0x630>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    621c:	69 8d       	ldd	r22, Y+25	; 0x19
    621e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6220:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6222:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6224:	20 e0       	ldi	r18, 0x00	; 0
    6226:	30 e0       	ldi	r19, 0x00	; 0
    6228:	40 e2       	ldi	r20, 0x20	; 32
    622a:	51 e4       	ldi	r21, 0x41	; 65
    622c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6230:	dc 01       	movw	r26, r24
    6232:	cb 01       	movw	r24, r22
    6234:	bc 01       	movw	r22, r24
    6236:	cd 01       	movw	r24, r26
    6238:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    623c:	dc 01       	movw	r26, r24
    623e:	cb 01       	movw	r24, r22
    6240:	9c 8b       	std	Y+20, r25	; 0x14
    6242:	8b 8b       	std	Y+19, r24	; 0x13
    6244:	0f c0       	rjmp	.+30     	; 0x6264 <vLogin+0x626>
    6246:	80 e9       	ldi	r24, 0x90	; 144
    6248:	91 e0       	ldi	r25, 0x01	; 1
    624a:	9a 8b       	std	Y+18, r25	; 0x12
    624c:	89 8b       	std	Y+17, r24	; 0x11
    624e:	89 89       	ldd	r24, Y+17	; 0x11
    6250:	9a 89       	ldd	r25, Y+18	; 0x12
    6252:	01 97       	sbiw	r24, 0x01	; 1
    6254:	f1 f7       	brne	.-4      	; 0x6252 <vLogin+0x614>
    6256:	9a 8b       	std	Y+18, r25	; 0x12
    6258:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    625a:	8b 89       	ldd	r24, Y+19	; 0x13
    625c:	9c 89       	ldd	r25, Y+20	; 0x14
    625e:	01 97       	sbiw	r24, 0x01	; 1
    6260:	9c 8b       	std	Y+20, r25	; 0x14
    6262:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6264:	8b 89       	ldd	r24, Y+19	; 0x13
    6266:	9c 89       	ldd	r25, Y+20	; 0x14
    6268:	00 97       	sbiw	r24, 0x00	; 0
    626a:	69 f7       	brne	.-38     	; 0x6246 <vLogin+0x608>
    626c:	14 c0       	rjmp	.+40     	; 0x6296 <vLogin+0x658>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    626e:	6d 89       	ldd	r22, Y+21	; 0x15
    6270:	7e 89       	ldd	r23, Y+22	; 0x16
    6272:	8f 89       	ldd	r24, Y+23	; 0x17
    6274:	98 8d       	ldd	r25, Y+24	; 0x18
    6276:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    627a:	dc 01       	movw	r26, r24
    627c:	cb 01       	movw	r24, r22
    627e:	9c 8b       	std	Y+20, r25	; 0x14
    6280:	8b 8b       	std	Y+19, r24	; 0x13
    6282:	8b 89       	ldd	r24, Y+19	; 0x13
    6284:	9c 89       	ldd	r25, Y+20	; 0x14
    6286:	98 8b       	std	Y+16, r25	; 0x10
    6288:	8f 87       	std	Y+15, r24	; 0x0f
    628a:	8f 85       	ldd	r24, Y+15	; 0x0f
    628c:	98 89       	ldd	r25, Y+16	; 0x10
    628e:	01 97       	sbiw	r24, 0x01	; 1
    6290:	f1 f7       	brne	.-4      	; 0x628e <vLogin+0x650>
    6292:	98 8b       	std	Y+16, r25	; 0x10
    6294:	8f 87       	std	Y+15, r24	; 0x0f

					/*after one second clear screen*/
					_delay_ms(1000);
					LCD_voidSendCommand(0x01);
    6296:	81 e0       	ldi	r24, 0x01	; 1
    6298:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>

					/*in thrid trial Locked the system*/
					if(Key == 0)
    629c:	fe 01       	movw	r30, r28
    629e:	ef 5b       	subi	r30, 0xBF	; 191
    62a0:	ff 4f       	sbci	r31, 0xFF	; 255
    62a2:	80 81       	ld	r24, Z
    62a4:	88 23       	and	r24, r24
    62a6:	09 f0       	breq	.+2      	; 0x62aa <vLogin+0x66c>
    62a8:	12 c1       	rjmp	.+548    	; 0x64ce <vLogin+0x890>
					{
						/*after one second clear screen*/
						LCD_voidSendCommand(0x01);
    62aa:	81 e0       	ldi	r24, 0x01	; 1
    62ac:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>

						/*Set alarm*/
						DIO_enuWritePin(BUZZER_PIN,DIO_HIGH);
    62b0:	83 e0       	ldi	r24, 0x03	; 3
    62b2:	61 e0       	ldi	r22, 0x01	; 1
    62b4:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <DIO_enuWritePin>

						/*inform user that system is locked*/
						LCD_voidGotoxy(0,0);
    62b8:	80 e0       	ldi	r24, 0x00	; 0
    62ba:	60 e0       	ldi	r22, 0x00	; 0
    62bc:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
						LCD_voidSendString("System Locked");
    62c0:	8c ea       	ldi	r24, 0xAC	; 172
    62c2:	90 e0       	ldi	r25, 0x00	; 0
    62c4:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
    62c8:	ff cf       	rjmp	.-2      	; 0x62c8 <vLogin+0x68a>
					}
				}
				break;
			case '2':
				/***********************************start storing user name *****************************************/
				UART_voidSend('\r');
    62ca:	8d e0       	ldi	r24, 0x0D	; 13
    62cc:	90 e0       	ldi	r25, 0x00	; 0
    62ce:	0e 94 97 22 	call	0x452e	; 0x452e <UART_voidSend>
				/*ask about user name*/
				LCD_voidGotoxy(0,0);
    62d2:	80 e0       	ldi	r24, 0x00	; 0
    62d4:	60 e0       	ldi	r22, 0x00	; 0
    62d6:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
				LCD_voidSendString("user name ?");
    62da:	8a eb       	ldi	r24, 0xBA	; 186
    62dc:	90 e0       	ldi	r25, 0x00	; 0
    62de:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>

				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    62e2:	1a ae       	std	Y+58, r1	; 0x3a
    62e4:	2f c0       	rjmp	.+94     	; 0x6344 <vLogin+0x706>
				{
					/*receiving name byte by byte*/
					UART_enuRecieve(&entry_data);
    62e6:	ce 01       	movw	r24, r28
    62e8:	8e 59       	subi	r24, 0x9E	; 158
    62ea:	9f 4f       	sbci	r25, 0xFF	; 255
    62ec:	0e 94 b3 22 	call	0x4566	; 0x4566 <UART_enuRecieve>

					/*stop at Enter*/
					if(entry_data == '\r')
    62f0:	fe 01       	movw	r30, r28
    62f2:	ee 59       	subi	r30, 0x9E	; 158
    62f4:	ff 4f       	sbci	r31, 0xFF	; 255
    62f6:	80 81       	ld	r24, Z
    62f8:	8d 30       	cpi	r24, 0x0D	; 13
    62fa:	71 f4       	brne	.+28     	; 0x6318 <vLogin+0x6da>
					{
						/*store end of name at EEPROM*/
						entry_data= '\0';
    62fc:	fe 01       	movw	r30, r28
    62fe:	ee 59       	subi	r30, 0x9E	; 158
    6300:	ff 4f       	sbci	r31, 0xFF	; 255
    6302:	10 82       	st	Z, r1
						EEPROM_enuWriteByte(0,(USER_NAME_BASE_ADDRESS|u8Counter) ,entry_data);
    6304:	fe 01       	movw	r30, r28
    6306:	ee 59       	subi	r30, 0x9E	; 158
    6308:	ff 4f       	sbci	r31, 0xFF	; 255
    630a:	90 81       	ld	r25, Z
    630c:	80 e0       	ldi	r24, 0x00	; 0
    630e:	6a ad       	ldd	r22, Y+58	; 0x3a
    6310:	49 2f       	mov	r20, r25
    6312:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <EEPROM_enuWriteByte>
    6316:	19 c0       	rjmp	.+50     	; 0x634a <vLogin+0x70c>
						break;
					}
					/*store data at EEPROM*/
					EEPROM_enuWriteByte(0,(USER_NAME_BASE_ADDRESS|u8Counter) ,entry_data);
    6318:	fe 01       	movw	r30, r28
    631a:	ee 59       	subi	r30, 0x9E	; 158
    631c:	ff 4f       	sbci	r31, 0xFF	; 255
    631e:	90 81       	ld	r25, Z
    6320:	80 e0       	ldi	r24, 0x00	; 0
    6322:	6a ad       	ldd	r22, Y+58	; 0x3a
    6324:	49 2f       	mov	r20, r25
    6326:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <EEPROM_enuWriteByte>
					/*show character at LCD screen*/
					LCD_voidGotoxy(u8Counter,1);
    632a:	8a ad       	ldd	r24, Y+58	; 0x3a
    632c:	61 e0       	ldi	r22, 0x01	; 1
    632e:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendData(entry_data);
    6332:	fe 01       	movw	r30, r28
    6334:	ee 59       	subi	r30, 0x9E	; 158
    6336:	ff 4f       	sbci	r31, 0xFF	; 255
    6338:	80 81       	ld	r24, Z
    633a:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
				UART_voidSend('\r');
				/*ask about user name*/
				LCD_voidGotoxy(0,0);
				LCD_voidSendString("user name ?");

				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    633e:	8a ad       	ldd	r24, Y+58	; 0x3a
    6340:	8f 5f       	subi	r24, 0xFF	; 255
    6342:	8a af       	std	Y+58, r24	; 0x3a
    6344:	8a ad       	ldd	r24, Y+58	; 0x3a
    6346:	80 31       	cpi	r24, 0x10	; 16
    6348:	70 f2       	brcs	.-100    	; 0x62e6 <vLogin+0x6a8>
					LCD_voidSendData(entry_data);
				}
				/***********************************end storing user name *****************************************/

				/***********************************start storing user password *****************************************/
				LCD_voidSendCommand(0x01);
    634a:	81 e0       	ldi	r24, 0x01	; 1
    634c:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>

				/*ask about user password*/
				LCD_voidGotoxy(0,0);
    6350:	80 e0       	ldi	r24, 0x00	; 0
    6352:	60 e0       	ldi	r22, 0x00	; 0
    6354:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
				LCD_voidSendString("user password ?");
    6358:	86 ec       	ldi	r24, 0xC6	; 198
    635a:	90 e0       	ldi	r25, 0x00	; 0
    635c:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>

				/*receiving password byte by byte*/
				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    6360:	19 ae       	std	Y+57, r1	; 0x39
    6362:	ae c0       	rjmp	.+348    	; 0x64c0 <vLogin+0x882>
				{
					UART_enuRecieve(&entry_data);
    6364:	ce 01       	movw	r24, r28
    6366:	8e 59       	subi	r24, 0x9E	; 158
    6368:	9f 4f       	sbci	r25, 0xFF	; 255
    636a:	0e 94 b3 22 	call	0x4566	; 0x4566 <UART_enuRecieve>
					if(entry_data == '\r')
    636e:	fe 01       	movw	r30, r28
    6370:	ee 59       	subi	r30, 0x9E	; 158
    6372:	ff 4f       	sbci	r31, 0xFF	; 255
    6374:	80 81       	ld	r24, Z
    6376:	8d 30       	cpi	r24, 0x0D	; 13
    6378:	89 f4       	brne	.+34     	; 0x639c <vLogin+0x75e>
					{
						/*store end of password at EEPROM*/
						entry_data= '\0';
    637a:	fe 01       	movw	r30, r28
    637c:	ee 59       	subi	r30, 0x9E	; 158
    637e:	ff 4f       	sbci	r31, 0xFF	; 255
    6380:	10 82       	st	Z, r1
						EEPROM_enuWriteByte(0,(USER_PASS_BASE_ADDRESS|u8Counter) ,entry_data);
    6382:	89 ad       	ldd	r24, Y+57	; 0x39
    6384:	28 2f       	mov	r18, r24
    6386:	20 6f       	ori	r18, 0xF0	; 240
    6388:	fe 01       	movw	r30, r28
    638a:	ee 59       	subi	r30, 0x9E	; 158
    638c:	ff 4f       	sbci	r31, 0xFF	; 255
    638e:	90 81       	ld	r25, Z
    6390:	80 e0       	ldi	r24, 0x00	; 0
    6392:	62 2f       	mov	r22, r18
    6394:	49 2f       	mov	r20, r25
    6396:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <EEPROM_enuWriteByte>
    639a:	96 c0       	rjmp	.+300    	; 0x64c8 <vLogin+0x88a>
						break;
					}
					/*store data at EEPROM*/
					EEPROM_enuWriteByte(0,(USER_PASS_BASE_ADDRESS|u8Counter) ,entry_data);
    639c:	89 ad       	ldd	r24, Y+57	; 0x39
    639e:	28 2f       	mov	r18, r24
    63a0:	20 6f       	ori	r18, 0xF0	; 240
    63a2:	fe 01       	movw	r30, r28
    63a4:	ee 59       	subi	r30, 0x9E	; 158
    63a6:	ff 4f       	sbci	r31, 0xFF	; 255
    63a8:	90 81       	ld	r25, Z
    63aa:	80 e0       	ldi	r24, 0x00	; 0
    63ac:	62 2f       	mov	r22, r18
    63ae:	49 2f       	mov	r20, r25
    63b0:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <EEPROM_enuWriteByte>
					/*show character at LCD screen*/
					LCD_voidGotoxy(u8Counter,1);
    63b4:	89 ad       	ldd	r24, Y+57	; 0x39
    63b6:	61 e0       	ldi	r22, 0x01	; 1
    63b8:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendData(entry_data);
    63bc:	fe 01       	movw	r30, r28
    63be:	ee 59       	subi	r30, 0x9E	; 158
    63c0:	ff 4f       	sbci	r31, 0xFF	; 255
    63c2:	80 81       	ld	r24, Z
    63c4:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
    63c8:	80 e0       	ldi	r24, 0x00	; 0
    63ca:	90 e0       	ldi	r25, 0x00	; 0
    63cc:	a8 ec       	ldi	r26, 0xC8	; 200
    63ce:	b2 e4       	ldi	r27, 0x42	; 66
    63d0:	8b 87       	std	Y+11, r24	; 0x0b
    63d2:	9c 87       	std	Y+12, r25	; 0x0c
    63d4:	ad 87       	std	Y+13, r26	; 0x0d
    63d6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    63d8:	6b 85       	ldd	r22, Y+11	; 0x0b
    63da:	7c 85       	ldd	r23, Y+12	; 0x0c
    63dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    63de:	9e 85       	ldd	r25, Y+14	; 0x0e
    63e0:	20 e0       	ldi	r18, 0x00	; 0
    63e2:	30 e0       	ldi	r19, 0x00	; 0
    63e4:	4a e7       	ldi	r20, 0x7A	; 122
    63e6:	55 e4       	ldi	r21, 0x45	; 69
    63e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    63ec:	dc 01       	movw	r26, r24
    63ee:	cb 01       	movw	r24, r22
    63f0:	8f 83       	std	Y+7, r24	; 0x07
    63f2:	98 87       	std	Y+8, r25	; 0x08
    63f4:	a9 87       	std	Y+9, r26	; 0x09
    63f6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    63f8:	6f 81       	ldd	r22, Y+7	; 0x07
    63fa:	78 85       	ldd	r23, Y+8	; 0x08
    63fc:	89 85       	ldd	r24, Y+9	; 0x09
    63fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    6400:	20 e0       	ldi	r18, 0x00	; 0
    6402:	30 e0       	ldi	r19, 0x00	; 0
    6404:	40 e8       	ldi	r20, 0x80	; 128
    6406:	5f e3       	ldi	r21, 0x3F	; 63
    6408:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    640c:	88 23       	and	r24, r24
    640e:	2c f4       	brge	.+10     	; 0x641a <vLogin+0x7dc>
		__ticks = 1;
    6410:	81 e0       	ldi	r24, 0x01	; 1
    6412:	90 e0       	ldi	r25, 0x00	; 0
    6414:	9e 83       	std	Y+6, r25	; 0x06
    6416:	8d 83       	std	Y+5, r24	; 0x05
    6418:	3f c0       	rjmp	.+126    	; 0x6498 <vLogin+0x85a>
	else if (__tmp > 65535)
    641a:	6f 81       	ldd	r22, Y+7	; 0x07
    641c:	78 85       	ldd	r23, Y+8	; 0x08
    641e:	89 85       	ldd	r24, Y+9	; 0x09
    6420:	9a 85       	ldd	r25, Y+10	; 0x0a
    6422:	20 e0       	ldi	r18, 0x00	; 0
    6424:	3f ef       	ldi	r19, 0xFF	; 255
    6426:	4f e7       	ldi	r20, 0x7F	; 127
    6428:	57 e4       	ldi	r21, 0x47	; 71
    642a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    642e:	18 16       	cp	r1, r24
    6430:	4c f5       	brge	.+82     	; 0x6484 <vLogin+0x846>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6432:	6b 85       	ldd	r22, Y+11	; 0x0b
    6434:	7c 85       	ldd	r23, Y+12	; 0x0c
    6436:	8d 85       	ldd	r24, Y+13	; 0x0d
    6438:	9e 85       	ldd	r25, Y+14	; 0x0e
    643a:	20 e0       	ldi	r18, 0x00	; 0
    643c:	30 e0       	ldi	r19, 0x00	; 0
    643e:	40 e2       	ldi	r20, 0x20	; 32
    6440:	51 e4       	ldi	r21, 0x41	; 65
    6442:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6446:	dc 01       	movw	r26, r24
    6448:	cb 01       	movw	r24, r22
    644a:	bc 01       	movw	r22, r24
    644c:	cd 01       	movw	r24, r26
    644e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6452:	dc 01       	movw	r26, r24
    6454:	cb 01       	movw	r24, r22
    6456:	9e 83       	std	Y+6, r25	; 0x06
    6458:	8d 83       	std	Y+5, r24	; 0x05
    645a:	0f c0       	rjmp	.+30     	; 0x647a <vLogin+0x83c>
    645c:	80 e9       	ldi	r24, 0x90	; 144
    645e:	91 e0       	ldi	r25, 0x01	; 1
    6460:	9c 83       	std	Y+4, r25	; 0x04
    6462:	8b 83       	std	Y+3, r24	; 0x03
    6464:	8b 81       	ldd	r24, Y+3	; 0x03
    6466:	9c 81       	ldd	r25, Y+4	; 0x04
    6468:	01 97       	sbiw	r24, 0x01	; 1
    646a:	f1 f7       	brne	.-4      	; 0x6468 <vLogin+0x82a>
    646c:	9c 83       	std	Y+4, r25	; 0x04
    646e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6470:	8d 81       	ldd	r24, Y+5	; 0x05
    6472:	9e 81       	ldd	r25, Y+6	; 0x06
    6474:	01 97       	sbiw	r24, 0x01	; 1
    6476:	9e 83       	std	Y+6, r25	; 0x06
    6478:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    647a:	8d 81       	ldd	r24, Y+5	; 0x05
    647c:	9e 81       	ldd	r25, Y+6	; 0x06
    647e:	00 97       	sbiw	r24, 0x00	; 0
    6480:	69 f7       	brne	.-38     	; 0x645c <vLogin+0x81e>
    6482:	14 c0       	rjmp	.+40     	; 0x64ac <vLogin+0x86e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6484:	6f 81       	ldd	r22, Y+7	; 0x07
    6486:	78 85       	ldd	r23, Y+8	; 0x08
    6488:	89 85       	ldd	r24, Y+9	; 0x09
    648a:	9a 85       	ldd	r25, Y+10	; 0x0a
    648c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6490:	dc 01       	movw	r26, r24
    6492:	cb 01       	movw	r24, r22
    6494:	9e 83       	std	Y+6, r25	; 0x06
    6496:	8d 83       	std	Y+5, r24	; 0x05
    6498:	8d 81       	ldd	r24, Y+5	; 0x05
    649a:	9e 81       	ldd	r25, Y+6	; 0x06
    649c:	9a 83       	std	Y+2, r25	; 0x02
    649e:	89 83       	std	Y+1, r24	; 0x01
    64a0:	89 81       	ldd	r24, Y+1	; 0x01
    64a2:	9a 81       	ldd	r25, Y+2	; 0x02
    64a4:	01 97       	sbiw	r24, 0x01	; 1
    64a6:	f1 f7       	brne	.-4      	; 0x64a4 <vLogin+0x866>
    64a8:	9a 83       	std	Y+2, r25	; 0x02
    64aa:	89 83       	std	Y+1, r24	; 0x01
					_delay_ms(100);
					LCD_voidGotoxy(u8Counter,1);
    64ac:	89 ad       	ldd	r24, Y+57	; 0x39
    64ae:	61 e0       	ldi	r22, 0x01	; 1
    64b0:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
					LCD_voidSendData('*');
    64b4:	8a e2       	ldi	r24, 0x2A	; 42
    64b6:	0e 94 4b 2b 	call	0x5696	; 0x5696 <LCD_voidSendData>
				/*ask about user password*/
				LCD_voidGotoxy(0,0);
				LCD_voidSendString("user password ?");

				/*receiving password byte by byte*/
				for(uint8 u8Counter=0;u8Counter<16 ; u8Counter++ )
    64ba:	89 ad       	ldd	r24, Y+57	; 0x39
    64bc:	8f 5f       	subi	r24, 0xFF	; 255
    64be:	89 af       	std	Y+57, r24	; 0x39
    64c0:	89 ad       	ldd	r24, Y+57	; 0x39
    64c2:	80 31       	cpi	r24, 0x10	; 16
    64c4:	08 f4       	brcc	.+2      	; 0x64c8 <vLogin+0x88a>
    64c6:	4e cf       	rjmp	.-356    	; 0x6364 <vLogin+0x726>
					LCD_voidSendData(entry_data);
					_delay_ms(100);
					LCD_voidGotoxy(u8Counter,1);
					LCD_voidSendData('*');
				}
				LCD_voidSendCommand(0x01);
    64c8:	81 e0       	ldi	r24, 0x01	; 1
    64ca:	0e 94 69 2b 	call	0x56d2	; 0x56d2 <LCD_voidSendCommand>
				/***********************************end storing user password *****************************************/
				break;
		}
		/*release LCD semaphor*/
		xSemaphoreGive(LCD_Semaphore);
    64ce:	80 91 a2 06 	lds	r24, 0x06A2
    64d2:	90 91 a3 06 	lds	r25, 0x06A3
    64d6:	60 e0       	ldi	r22, 0x00	; 0
    64d8:	70 e0       	ldi	r23, 0x00	; 0
    64da:	40 e0       	ldi	r20, 0x00	; 0
    64dc:	50 e0       	ldi	r21, 0x00	; 0
    64de:	20 e0       	ldi	r18, 0x00	; 0
    64e0:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <xQueueGenericSend>

		/*get task in waiting state*/
		vTaskDelay(pdMS_TO_TICKS(1000));
    64e4:	80 e1       	ldi	r24, 0x10	; 16
    64e6:	90 e0       	ldi	r25, 0x00	; 0
    64e8:	0e 94 94 15 	call	0x2b28	; 0x2b28 <vTaskDelay>
    64ec:	bd cb       	rjmp	.-2182   	; 0x5c68 <vLogin+0x2a>

000064ee <vLM35>:
	}
}

/* Task to Reading of LM35*/
void vLM35(void *pvParameters)
{
    64ee:	df 93       	push	r29
    64f0:	cf 93       	push	r28
    64f2:	00 d0       	rcall	.+0      	; 0x64f4 <vLM35+0x6>
    64f4:	00 d0       	rcall	.+0      	; 0x64f6 <vLM35+0x8>
    64f6:	00 d0       	rcall	.+0      	; 0x64f8 <vLM35+0xa>
    64f8:	cd b7       	in	r28, 0x3d	; 61
    64fa:	de b7       	in	r29, 0x3e	; 62
    64fc:	9e 83       	std	Y+6, r25	; 0x06
    64fe:	8d 83       	std	Y+5, r24	; 0x05
  //  uint8 Message[20];  // Allocate fixed buffer for message
    uint32 temp=0;
    6500:	19 82       	std	Y+1, r1	; 0x01
    6502:	1a 82       	std	Y+2, r1	; 0x02
    6504:	1b 82       	std	Y+3, r1	; 0x03
    6506:	1c 82       	std	Y+4, r1	; 0x04
    while (1)
    {
    	/*Taking LM35 sensor readings*/
        temp = LM35_f32Reading(ADC0);
    6508:	80 e0       	ldi	r24, 0x00	; 0
    650a:	0e 94 34 2a 	call	0x5468	; 0x5468 <LM35_f32Reading>
    650e:	dc 01       	movw	r26, r24
    6510:	cb 01       	movw	r24, r22
    6512:	bc 01       	movw	r22, r24
    6514:	cd 01       	movw	r24, r26
    6516:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    651a:	dc 01       	movw	r26, r24
    651c:	cb 01       	movw	r24, r22
    651e:	89 83       	std	Y+1, r24	; 0x01
    6520:	9a 83       	std	Y+2, r25	; 0x02
    6522:	ab 83       	std	Y+3, r26	; 0x03
    6524:	bc 83       	std	Y+4, r27	; 0x04

        /*Send Temperature degree to Fan Task using Queue*/
        xQueueSend(Queue_LM35, ( void *)&temp,portMAX_DELAY);
    6526:	80 91 aa 06 	lds	r24, 0x06AA
    652a:	90 91 ab 06 	lds	r25, 0x06AB
    652e:	9e 01       	movw	r18, r28
    6530:	2f 5f       	subi	r18, 0xFF	; 255
    6532:	3f 4f       	sbci	r19, 0xFF	; 255
    6534:	b9 01       	movw	r22, r18
    6536:	4f ef       	ldi	r20, 0xFF	; 255
    6538:	5f ef       	ldi	r21, 0xFF	; 255
    653a:	20 e0       	ldi	r18, 0x00	; 0
    653c:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <xQueueGenericSend>

        // Delay to prevent constant task execution
        vTaskDelay(pdMS_TO_TICKS(1000));
    6540:	80 e1       	ldi	r24, 0x10	; 16
    6542:	90 e0       	ldi	r25, 0x00	; 0
    6544:	0e 94 94 15 	call	0x2b28	; 0x2b28 <vTaskDelay>
    6548:	df cf       	rjmp	.-66     	; 0x6508 <vLM35+0x1a>

0000654a <vFAN>:
}


/* Task to handle displaying of Temperature*/
void vFAN(void *pvParameters)
{
    654a:	df 93       	push	r29
    654c:	cf 93       	push	r28
    654e:	00 d0       	rcall	.+0      	; 0x6550 <vFAN+0x6>
    6550:	00 d0       	rcall	.+0      	; 0x6552 <vFAN+0x8>
    6552:	00 d0       	rcall	.+0      	; 0x6554 <vFAN+0xa>
    6554:	cd b7       	in	r28, 0x3d	; 61
    6556:	de b7       	in	r29, 0x3e	; 62
    6558:	9e 83       	std	Y+6, r25	; 0x06
    655a:	8d 83       	std	Y+5, r24	; 0x05
    uint32 temp_value=0;
    655c:	19 82       	std	Y+1, r1	; 0x01
    655e:	1a 82       	std	Y+2, r1	; 0x02
    6560:	1b 82       	std	Y+3, r1	; 0x03
    6562:	1c 82       	std	Y+4, r1	; 0x04
    while (1)
    {
    	/* take LCD semaphor to start using it*/
    	xSemaphoreTake(LCD_Semaphore,(TickType_t)10);
    6564:	80 91 a2 06 	lds	r24, 0x06A2
    6568:	90 91 a3 06 	lds	r25, 0x06A3
    656c:	60 e0       	ldi	r22, 0x00	; 0
    656e:	70 e0       	ldi	r23, 0x00	; 0
    6570:	4a e0       	ldi	r20, 0x0A	; 10
    6572:	50 e0       	ldi	r21, 0x00	; 0
    6574:	20 e0       	ldi	r18, 0x00	; 0
    6576:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <xQueueGenericReceive>

    	/*Receive Temperature degree from LM35 Task using Queue*/
    	xQueueReceive(Queue_LM35,( void *)&temp_value,portMAX_DELAY);
    657a:	80 91 aa 06 	lds	r24, 0x06AA
    657e:	90 91 ab 06 	lds	r25, 0x06AB
    6582:	9e 01       	movw	r18, r28
    6584:	2f 5f       	subi	r18, 0xFF	; 255
    6586:	3f 4f       	sbci	r19, 0xFF	; 255
    6588:	b9 01       	movw	r22, r18
    658a:	4f ef       	ldi	r20, 0xFF	; 255
    658c:	5f ef       	ldi	r21, 0xFF	; 255
    658e:	20 e0       	ldi	r18, 0x00	; 0
    6590:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <xQueueGenericReceive>

    	/*Show Temperature Degree on Screen*/
		LCD_voidGotoxy(0,0);
    6594:	80 e0       	ldi	r24, 0x00	; 0
    6596:	60 e0       	ldi	r22, 0x00	; 0
    6598:	0e 94 4a 2c 	call	0x5894	; 0x5894 <LCD_voidGotoxy>
		LCD_voidSendString("Temperature:");
    659c:	86 ed       	ldi	r24, 0xD6	; 214
    659e:	90 e0       	ldi	r25, 0x00	; 0
    65a0:	0e 94 21 2c 	call	0x5842	; 0x5842 <LCD_voidSendString>
		LCD_voidSendNumber(temp_value);
    65a4:	89 81       	ldd	r24, Y+1	; 0x01
    65a6:	9a 81       	ldd	r25, Y+2	; 0x02
    65a8:	ab 81       	ldd	r26, Y+3	; 0x03
    65aa:	bc 81       	ldd	r27, Y+4	; 0x04
    65ac:	bc 01       	movw	r22, r24
    65ae:	cd 01       	movw	r24, r26
    65b0:	0e 94 b4 2c 	call	0x5968	; 0x5968 <LCD_voidSendNumber>

		/*Controling Fan Speed according to Temperature Degree*/
		if(temp_value <= 30)TIM2_voidSetOCRValue(0);
    65b4:	89 81       	ldd	r24, Y+1	; 0x01
    65b6:	9a 81       	ldd	r25, Y+2	; 0x02
    65b8:	ab 81       	ldd	r26, Y+3	; 0x03
    65ba:	bc 81       	ldd	r27, Y+4	; 0x04
    65bc:	8f 31       	cpi	r24, 0x1F	; 31
    65be:	91 05       	cpc	r25, r1
    65c0:	a1 05       	cpc	r26, r1
    65c2:	b1 05       	cpc	r27, r1
    65c4:	20 f4       	brcc	.+8      	; 0x65ce <vFAN+0x84>
    65c6:	80 e0       	ldi	r24, 0x00	; 0
    65c8:	0e 94 05 24 	call	0x480a	; 0x480a <TIM2_voidSetOCRValue>
    65cc:	1d c0       	rjmp	.+58     	; 0x6608 <vFAN+0xbe>
		else if(temp_value <= 50)TIM2_voidSetOCRValue(80);
    65ce:	89 81       	ldd	r24, Y+1	; 0x01
    65d0:	9a 81       	ldd	r25, Y+2	; 0x02
    65d2:	ab 81       	ldd	r26, Y+3	; 0x03
    65d4:	bc 81       	ldd	r27, Y+4	; 0x04
    65d6:	83 33       	cpi	r24, 0x33	; 51
    65d8:	91 05       	cpc	r25, r1
    65da:	a1 05       	cpc	r26, r1
    65dc:	b1 05       	cpc	r27, r1
    65de:	20 f4       	brcc	.+8      	; 0x65e8 <vFAN+0x9e>
    65e0:	80 e5       	ldi	r24, 0x50	; 80
    65e2:	0e 94 05 24 	call	0x480a	; 0x480a <TIM2_voidSetOCRValue>
    65e6:	10 c0       	rjmp	.+32     	; 0x6608 <vFAN+0xbe>
		else if(temp_value <= 70)TIM2_voidSetOCRValue(155);
    65e8:	89 81       	ldd	r24, Y+1	; 0x01
    65ea:	9a 81       	ldd	r25, Y+2	; 0x02
    65ec:	ab 81       	ldd	r26, Y+3	; 0x03
    65ee:	bc 81       	ldd	r27, Y+4	; 0x04
    65f0:	87 34       	cpi	r24, 0x47	; 71
    65f2:	91 05       	cpc	r25, r1
    65f4:	a1 05       	cpc	r26, r1
    65f6:	b1 05       	cpc	r27, r1
    65f8:	20 f4       	brcc	.+8      	; 0x6602 <vFAN+0xb8>
    65fa:	8b e9       	ldi	r24, 0x9B	; 155
    65fc:	0e 94 05 24 	call	0x480a	; 0x480a <TIM2_voidSetOCRValue>
    6600:	03 c0       	rjmp	.+6      	; 0x6608 <vFAN+0xbe>
		else TIM2_voidSetOCRValue(255);
    6602:	8f ef       	ldi	r24, 0xFF	; 255
    6604:	0e 94 05 24 	call	0x480a	; 0x480a <TIM2_voidSetOCRValue>

		/*release LCD semaphor*/
		xSemaphoreGive(LCD_Semaphore);
    6608:	80 91 a2 06 	lds	r24, 0x06A2
    660c:	90 91 a3 06 	lds	r25, 0x06A3
    6610:	60 e0       	ldi	r22, 0x00	; 0
    6612:	70 e0       	ldi	r23, 0x00	; 0
    6614:	40 e0       	ldi	r20, 0x00	; 0
    6616:	50 e0       	ldi	r21, 0x00	; 0
    6618:	20 e0       	ldi	r18, 0x00	; 0
    661a:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <xQueueGenericSend>
		// Delay to prevent constant task execution
		vTaskDelay(pdMS_TO_TICKS(1000));
    661e:	80 e1       	ldi	r24, 0x10	; 16
    6620:	90 e0       	ldi	r25, 0x00	; 0
    6622:	0e 94 94 15 	call	0x2b28	; 0x2b28 <vTaskDelay>
    6626:	9e cf       	rjmp	.-196    	; 0x6564 <vFAN+0x1a>

00006628 <main>:
#include "LIB/STD_TYPES.h"
#include "LIB/BIT_MATH.h"
#include "Application/App.h"

int main()
{
    6628:	df 93       	push	r29
    662a:	cf 93       	push	r28
    662c:	cd b7       	in	r28, 0x3d	; 61
    662e:	de b7       	in	r29, 0x3e	; 62
	AppStart();
    6630:	0e 94 bb 2d 	call	0x5b76	; 0x5b76 <AppStart>
    6634:	80 e0       	ldi	r24, 0x00	; 0
    6636:	90 e0       	ldi	r25, 0x00	; 0
}
    6638:	cf 91       	pop	r28
    663a:	df 91       	pop	r29
    663c:	08 95       	ret

0000663e <__udivmodsi4>:
    663e:	a1 e2       	ldi	r26, 0x21	; 33
    6640:	1a 2e       	mov	r1, r26
    6642:	aa 1b       	sub	r26, r26
    6644:	bb 1b       	sub	r27, r27
    6646:	fd 01       	movw	r30, r26
    6648:	0d c0       	rjmp	.+26     	; 0x6664 <__udivmodsi4_ep>

0000664a <__udivmodsi4_loop>:
    664a:	aa 1f       	adc	r26, r26
    664c:	bb 1f       	adc	r27, r27
    664e:	ee 1f       	adc	r30, r30
    6650:	ff 1f       	adc	r31, r31
    6652:	a2 17       	cp	r26, r18
    6654:	b3 07       	cpc	r27, r19
    6656:	e4 07       	cpc	r30, r20
    6658:	f5 07       	cpc	r31, r21
    665a:	20 f0       	brcs	.+8      	; 0x6664 <__udivmodsi4_ep>
    665c:	a2 1b       	sub	r26, r18
    665e:	b3 0b       	sbc	r27, r19
    6660:	e4 0b       	sbc	r30, r20
    6662:	f5 0b       	sbc	r31, r21

00006664 <__udivmodsi4_ep>:
    6664:	66 1f       	adc	r22, r22
    6666:	77 1f       	adc	r23, r23
    6668:	88 1f       	adc	r24, r24
    666a:	99 1f       	adc	r25, r25
    666c:	1a 94       	dec	r1
    666e:	69 f7       	brne	.-38     	; 0x664a <__udivmodsi4_loop>
    6670:	60 95       	com	r22
    6672:	70 95       	com	r23
    6674:	80 95       	com	r24
    6676:	90 95       	com	r25
    6678:	9b 01       	movw	r18, r22
    667a:	ac 01       	movw	r20, r24
    667c:	bd 01       	movw	r22, r26
    667e:	cf 01       	movw	r24, r30
    6680:	08 95       	ret

00006682 <__prologue_saves__>:
    6682:	2f 92       	push	r2
    6684:	3f 92       	push	r3
    6686:	4f 92       	push	r4
    6688:	5f 92       	push	r5
    668a:	6f 92       	push	r6
    668c:	7f 92       	push	r7
    668e:	8f 92       	push	r8
    6690:	9f 92       	push	r9
    6692:	af 92       	push	r10
    6694:	bf 92       	push	r11
    6696:	cf 92       	push	r12
    6698:	df 92       	push	r13
    669a:	ef 92       	push	r14
    669c:	ff 92       	push	r15
    669e:	0f 93       	push	r16
    66a0:	1f 93       	push	r17
    66a2:	cf 93       	push	r28
    66a4:	df 93       	push	r29
    66a6:	cd b7       	in	r28, 0x3d	; 61
    66a8:	de b7       	in	r29, 0x3e	; 62
    66aa:	ca 1b       	sub	r28, r26
    66ac:	db 0b       	sbc	r29, r27
    66ae:	0f b6       	in	r0, 0x3f	; 63
    66b0:	f8 94       	cli
    66b2:	de bf       	out	0x3e, r29	; 62
    66b4:	0f be       	out	0x3f, r0	; 63
    66b6:	cd bf       	out	0x3d, r28	; 61
    66b8:	09 94       	ijmp

000066ba <__epilogue_restores__>:
    66ba:	2a 88       	ldd	r2, Y+18	; 0x12
    66bc:	39 88       	ldd	r3, Y+17	; 0x11
    66be:	48 88       	ldd	r4, Y+16	; 0x10
    66c0:	5f 84       	ldd	r5, Y+15	; 0x0f
    66c2:	6e 84       	ldd	r6, Y+14	; 0x0e
    66c4:	7d 84       	ldd	r7, Y+13	; 0x0d
    66c6:	8c 84       	ldd	r8, Y+12	; 0x0c
    66c8:	9b 84       	ldd	r9, Y+11	; 0x0b
    66ca:	aa 84       	ldd	r10, Y+10	; 0x0a
    66cc:	b9 84       	ldd	r11, Y+9	; 0x09
    66ce:	c8 84       	ldd	r12, Y+8	; 0x08
    66d0:	df 80       	ldd	r13, Y+7	; 0x07
    66d2:	ee 80       	ldd	r14, Y+6	; 0x06
    66d4:	fd 80       	ldd	r15, Y+5	; 0x05
    66d6:	0c 81       	ldd	r16, Y+4	; 0x04
    66d8:	1b 81       	ldd	r17, Y+3	; 0x03
    66da:	aa 81       	ldd	r26, Y+2	; 0x02
    66dc:	b9 81       	ldd	r27, Y+1	; 0x01
    66de:	ce 0f       	add	r28, r30
    66e0:	d1 1d       	adc	r29, r1
    66e2:	0f b6       	in	r0, 0x3f	; 63
    66e4:	f8 94       	cli
    66e6:	de bf       	out	0x3e, r29	; 62
    66e8:	0f be       	out	0x3f, r0	; 63
    66ea:	cd bf       	out	0x3d, r28	; 61
    66ec:	ed 01       	movw	r28, r26
    66ee:	08 95       	ret

000066f0 <memcpy>:
    66f0:	fb 01       	movw	r30, r22
    66f2:	dc 01       	movw	r26, r24
    66f4:	02 c0       	rjmp	.+4      	; 0x66fa <memcpy+0xa>
    66f6:	01 90       	ld	r0, Z+
    66f8:	0d 92       	st	X+, r0
    66fa:	41 50       	subi	r20, 0x01	; 1
    66fc:	50 40       	sbci	r21, 0x00	; 0
    66fe:	d8 f7       	brcc	.-10     	; 0x66f6 <memcpy+0x6>
    6700:	08 95       	ret

00006702 <strcmp>:
    6702:	fb 01       	movw	r30, r22
    6704:	dc 01       	movw	r26, r24
    6706:	8d 91       	ld	r24, X+
    6708:	01 90       	ld	r0, Z+
    670a:	80 19       	sub	r24, r0
    670c:	01 10       	cpse	r0, r1
    670e:	d9 f3       	breq	.-10     	; 0x6706 <strcmp+0x4>
    6710:	99 0b       	sbc	r25, r25
    6712:	08 95       	ret

00006714 <_exit>:
    6714:	f8 94       	cli

00006716 <__stop_program>:
    6716:	ff cf       	rjmp	.-2      	; 0x6716 <__stop_program>
